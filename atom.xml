<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blessing Studio</title>
  
  <subtitle>半吊子全栈开发者的日常</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blessing.studio/"/>
  <updated>2018-11-01T15:00:10.000Z</updated>
  <id>https://blessing.studio/</id>
  
  <author>
    <name>printempw</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows 下手动搭建 PHP + Nginx/Apache 开发环境</title>
    <link href="https://blessing.studio/setup-nginx-php-on-windows/"/>
    <id>https://blessing.studio/setup-nginx-php-on-windows/</id>
    <published>2018-11-01T15:00:10.000Z</published>
    <updated>2018-11-01T15:00:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>看到这个标题，有人可能会想吐槽：</p><p><strong>你他娘的写了这么久 PHP，怎么现在想起来搭建开发环境了？</strong></p><p>呃，情况呢是这么个情况，我之前开发的那个 PHP 项目 (<a href="https://github.com/printempw/blessing-skin-server/" target="_blank" rel="noopener">printempw/blessing-skin-server</a>) 在两个月前发布 v3.5.0 版本后基本就已经告一段落了。虽然我本意是不再更新<del>（弃坑的委婉说法）</del>，因为当前的版本已经足够完善，该有的东西都有了（而且说实话搞了这么久我也腻味，不仅是对这个程序，还有对国内 Minecraft 开发生态以及用户群体的失望）。</p><p>不过我的朋友 <a href="https://blog.gplane.win/" target="_blank" rel="noopener">g-plane</a> 说他愿意接坑，所以现在这个项目的后续开发都是他在搞。而我也乐得清闲，做个甩手掌柜 <a href="https://blessing.studio/vscode-c-cpp-configuration-for-acm-oj/">搞别的</a> 去了。当我摸鱼正快活时，他过来联系我说准备发布 4.0.0-alpha 了，我才想起来这茬：「啊，我连新版本长啥样都还不知道呢！😂」于是急急忙忙 pull 了新代码准备 review 一下，却发现我的新笔电上甚至压根儿就没安装 PHP 开发环境，只能说是非常地真实。</p><p>因为 <a href="https://blessing.studio/phpstudy-prober-page-502-bad-gateway/">某些原因</a>，我不想继续使用那些 PHP 一键包来搭建开发环境了，所以这次我打算全部自己来。本文记录了我手动安装配置 PHP + Nginx/Apache 开发环境的过程，希望能帮到后来人。</p><p>注意，本文中的配置适用于本地开发环境，应用至生产环境时要注意哦。</p><a id="more"></a><h2 id="0x01-安装-Nginx-Apache"><a href="#0x01-安装-Nginx-Apache" class="headerlink" title="0x01 安装 Nginx / Apache"></a>0x01 安装 Nginx / Apache</h2><p><strong>如果你用的是 Nginx：</strong></p><ul><li>去 <a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">官网</a> 下载 Windows 版的 Nginx（我下载的是 <code>nginx-1.14.0.zip</code>）；</li><li>解压至你喜欢的地方（我放在 <code>E:\environment\nginx</code> 里）；</li><li>直接双击运行 <code>nginx.exe</code>；</li><li>如果能正常访问 <code>http://localhost:80</code>，就可以进行下一步了。</li></ul><p>推荐修改的 <code>nginx.conf</code> 配置如下：</p><pre><code class="nginx"># 可以适当调高，但不要超过 CPU 核心数量worker_processes  4;events {    # 开发环境下不用太考虑 worker 最大并发连接数    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile      on;    keepalive_timeout 65;    # 启用 gzip    gzip on;    gzip_disable &quot;MSIE [1-6].(?!.*SV1)&quot;;    gzip_http_version 1.1;    gzip_vary on;    gzip_proxied any;    gzip_min_length 1000;    gzip_buffers 16 8k;    gzip_comp_level 6;    gzip_types text/plain text/css text/xml text/javascript application/json application/x-javascript application/xml application/xml+rss;    # 这里面的内容等 0x03 再细说    include vhosts.conf;}</code></pre><p><strong>如果你用的是 Apache：</strong></p><ul><li>因为 Apache 官网并不提供 Windows 版的构建下载，所以需要去 <a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">Apache Lounge</a> 或者其他 <a href="https://httpd.apache.org/docs/current/platform/windows.html#down" target="_blank" rel="noopener">官方推荐的站点</a> 下载预编译二进制包（我下载的是 <code>httpd-2.4.37-win64-VC15.zip</code>，你愿意的话也可以自己编译）；</li><li>解压至你喜欢的地方（我放在 <code>E:\environment\apache</code> 里）；</li><li>直接双击运行 <code>bin/httpd.exe</code>；</li><li>如果能正常访问 <code>http://localhost:80</code>，就可以进行下一步了。</li></ul><p>推荐修改的 <code>httpd.conf</code> 配置如下：</p><pre><code class="apache"># 修改为你的安装目录Define SRVROOT &quot;E:\environment\apache&quot;ServerRoot &quot;${SRVROOT}&quot;Listen 80ServerName localhost# 按需启用模块LoadModule rewrite_module modules/mod_rewrite.soLoadModule ...# 推荐注释掉自带的 DocumentRoot 和 &lt;Directory&gt;# 这里面的内容等 0x03 再细说Include conf/extra/httpd-php.confInclude conf/vhosts.conf</code></pre><h2 id="0x02-安装-PHP"><a href="#0x02-安装-PHP" class="headerlink" title="0x02 安装 PHP"></a>0x02 安装 PHP</h2><p>Windows 版 PHP 下载地址：</p><p><a href="https://windows.php.net/download" target="_blank" rel="noopener">https://windows.php.net/download</a></p><p>其中有 NTS（Non Thread Safe，非线程安全）和 TS（Thread Safe，线程安全）两种版本，简单来说就是 <strong>Nginx 用 NTS 版，Apache 通常用 TS 版</strong>（也可以用 NTS），它们之间的具体区别有兴趣的话可以自己去了解一下。</p><p>为了同时兼容 Nginx 与 Apache，本文将以 NTS 版为例进行配置。</p><ul><li>下载合适的版本（我下载的是 <code>php-7.2.11-nts-Win32-VC15-x64.zip</code>）；</li><li>解压至你喜欢的位置（我放在 <code>E:\environment\php</code> 里）；</li><li>复制一份 <code>php.ini-development</code>，重命名为 <code>php.ini</code> 并适当修改其中配置；</li><li>直接双击运行 <code>php.exe</code>；</li><li>如果能正常打开 PHP Interactive Shell，就可以进入下一步了。</li></ul><p><strong>如果无法运行，请检查你是否安装了对应的 VC 运行库。</strong></p><p>推荐修改的 <code>php.ini</code> 配置如下：</p><pre><code class="ini">; 扩展所在的目录，自行修改extension_dir = &quot;E:\environment\php\ext&quot;; 按自己的需求启用扩展extension=pdo_mysqlextension=...; 各种缓存的位置sys_temp_dir = &quot;E:\environment\php\temp&quot;upload_tmp_dir = &quot;E:\environment\php\temp&quot;session.save_path = &quot;E:\environment\php\temp&quot;; 其他杂七杂八的upload_max_filesize = 100Mdate.timezone = Asia/Shanghai</code></pre><h2 id="0x03-配置-FastCGI-转发"><a href="#0x03-配置-FastCGI-转发" class="headerlink" title="0x03 配置 FastCGI 转发"></a>0x03 配置 FastCGI 转发</h2><p>接下来才是重头戏，我们要让 Web Server 与 PHP 能够互相通信以完成请求。</p><p>作为 Web Server 的后端时，PHP 主要有两种运行方式，一种是 <strong>独立进程、使用 <a href="http://www.nowamagic.net/librarys/veda/detail/1319" target="_blank" rel="noopener">FastCGI 协议</a> 与 Web Server 通信</strong>（Nginx 用的就是这种），另外一种是 <strong>作为模块直接加载到 Web Server 中</strong>（比如 Apache 的 <code>mod_php</code> 模块，不过 Apache 也支持 FastCGI 方式）。详细的原理我就不介绍了，有兴趣的选手可以去了解一下。</p><p>为了能够同时兼容 Nginx 和 Apache，<strong>本文均使用 FastCGI 方式加载 PHP</strong>。</p><hr><p>首先我们需要配置一下 PHP 的 FastCGI 进程管理器。为什么呢？因为直接运行 PHP 的 FastCGI 进程（在 Windows 上就是 <code>php-cgi.exe</code>）有以下缺点：</p><ul><li>配置文件 <code>php.ini</code> 修改后无法平滑重载，需要重新启动 <code>php-cgi</code> 进程；</li><li>Windows 下 <code>php-cgi</code> 默认处理 500 个请求后就自动退出（<code>PHP_FCGI_MAX_REQUESTS</code>）；</li><li>如果因为其他原因造成 <code>php-cgi</code> 进程崩溃，就无法处理后续请求了。</li></ul><p>所以我们需要一个类似守护进程的东西，来保证始终有一定数量的 <code>php-cgi</code> 进程在运行。<a href="http://php.net/manual/zh/install.fpm.php" target="_blank" rel="noopener">PHP-FPM</a> (PHP FastCGI Process Manager) 是 PHP 官方钦定的 FastCGI 进程管理器，但遗憾的是，它只适用于类 Unix 系统。在 Windows 上，我们可以使用这些替代品来实现类似的功能（<strong>Apache 用户不需要配置这些东西</strong>，因为它的 <code>mod_fcgid</code> 模块自带 FastCGI 进程管理功能）：</p><ul><li><a href="https://github.com/78/xxfpm" target="_blank" rel="noopener">xxfpm</a></li><li><a href="https://github.com/deemru/php-cgi-spawner" target="_blank" rel="noopener">php-cgi-spawner</a></li><li><a href="https://github.com/lighttpd/spawn-fcgi" target="_blank" rel="noopener">spawn-fcgi</a></li></ul><p>本文将以 php-cgi-spawner 为例进行配置。</p><ul><li><p>在 <a href="https://github.com/deemru/php-cgi-spawner/releases" target="_blank" rel="noopener">这里</a> 下载编译好的 <code>php-cgi-spawner.exe</code>；</p></li><li><p>放到 PHP 的安装目录下（本文为 <code>E:\environment\php</code>）；</p></li><li><p>打开 PowerShell 或者 CMD，运行命令：</p><pre><code class="powershell"># 令 PHP FastCGI 处理程序监听在 9000 端口上# 至少开启 4 个 php-cgi 进程，高负载时最多可以开到 16 个.\php-cgi-spawner.exe &quot;php-cgi.exe -c php.ini&quot; 9000 4+16</code></pre></li><li><p>如果一切正常，你将可以在任务管理器中看到同时运行的多个 <code>php-cgi</code> 进程。</p></li></ul><p><img src="https://img.blessing.studio/images/2018/11/01/php-cgi-processes.png" alt="php-cgi-processes"></p><p><strong>接下来修改 Nginx 配置</strong>（即 0x01 中提到的 <code>vhosts.conf</code> 中的内容），通过 FastCGI 协议将请求转发给监听在 9000 端口上的 PHP 进行处理：</p><pre><code class="nginx">server {    listen       80;    server_name  localhost;    root   E:/wwwroot;    index  index.html index.htm index.php;    location ~ [^/]\.php(/|$) {        # 从 URI 中分离出 $fastcgi_script_name 和 $fastcgi_path_info 的值        # 不推荐使用 php.ini 中的 cgi.fix_pathinfo 选项，这可能会造成安全隐患        # 虽然我感觉 8012 年了应该没人用 PATH_INFO 了……不需要的话去掉即可        fastcgi_split_path_info  ^(.+?\.php)(/.*)$;        fastcgi_param  PATH_INFO  $fastcgi_path_info;        # 当请求的 .php 文件不存在时直接返回 404        # 不然交给 PHP 处理的话那边就会返回 No input file specified.        if (!-f $document_root$fastcgi_script_name) {            return 404;        }        fastcgi_pass   127.0.0.1:9000;        fastcgi_index  index.php;        # 自带的配置文件，里面设置了一大堆 CGI 协议中的变量        include        fastcgi.conf;    }}</code></pre><hr><p><strong>Apache 用户不需要手动配置 PHP FastCGI 进程管理器，相对简单一些：</strong></p><ul><li>在上面提到的 <a href="https://www.apachelounge.com/download/" target="_blank" rel="noopener">Apache Lounge</a> 上下载编译好的 <code>mod_fcgid</code> 模块；</li><li>解压后，将 <code>mod_fcgid.so</code> 放入 Apache 的 <code>modules</code> 目录；</li><li>编辑配置文件加载模块（即 0x01 中提到的 <code>conf/extra/httpd-php.conf</code>）：</li></ul><pre><code class="apache"># 如果嫌麻烦的话这一段也可以直接放到 httpd.conf 里面去LoadModule fcgid_module modules/mod_fcgid.so&lt;IfModule fcgid_module&gt;FcgidInitialEnv PHPRC &quot;E:/environment/php/&quot;FcgidInitialEnv PHP_FCGI_MAX_REQUESTS 1000AddHandler fcgid-script .phpFcgidWrapper &quot;E:/environment/php/php-cgi.exe&quot; .phpFcgidIOTimeout 384FcgidConnectTimeout 360FcgidOutputBufferSize 128FcgidMaxRequestsPerProcess 1000FcgidMinProcessesPerClass 0FcgidMaxProcesses 16FcgidMaxRequestLen 268435456ProcessLifeTime 360&lt;/IfModule&gt;</code></pre><ul><li>编辑 <code>conf/vhosts.conf</code> 允许运行 CGI 程序：</li></ul><pre><code class="apache">&lt;VirtualHost localhost:80&gt;  DocumentRoot &quot;E:\wwwroot&quot;  &lt;Directory &quot;E:\wwwroot&quot;&gt;    DirectoryIndex index.html index.php    # 注意这里的 +ExecCGI，不加的话会 403    Options -Indexes -FollowSymLinks +ExecCGI    AllowOverride All    Order allow,deny    Allow from all    Require all granted  &lt;/Directory&gt;&lt;/VirtualHost&gt;</code></pre><p>如果一切配置正确，你应该就能正常访问 PHP 网页了。</p><p><img src="https://img.blessing.studio/images/2018/11/01/nginx-php-works.png" alt="nginx-php-works"></p><h2 id="0x04-编写启停脚本"><a href="#0x04-编写启停脚本" class="headerlink" title="0x04 编写启停脚本"></a>0x04 编写启停脚本</h2><p>虽然整个系统是跑起来了，但总不能每次启动都得开一大堆控制台窗口吧？弄个小工具管理 Nginx/Apache 和 PHP 的进程还是很有必要的。各种一键包中一般都自带了方便好用的界面来管理这些进程，不过既然我们选择了手动配置，那这一块也得我们自己搞定了。因为图方便，我选择使用 Windows 的批处理脚本（Batch File）来完成这项需求，保存为 <code>.bat</code> 文件双击运行就完事儿了。</p><p><strong>启动 Nginx 和 PHP：</strong></p><pre><code class="cmd">@ECHO OFFset nginx_home=..\nginxset php_home=..\phpECHO Starting PHP FastCGI....\RunHiddenConsole.exe %php_home%\php-cgi-spawner.exe &quot;%php_home%\php-cgi.exe -c %php_home%\php.ini&quot; 9000 4+16ECHO Starting Nginx....\RunHiddenConsole.exe %nginx_home%\nginx.exe -p %nginx_home%</code></pre><p><strong>停止 Nginx 和 PHP：</strong></p><pre><code class="cmd">@ECHO OFFECHO Stopping nginx...taskkill /F /IM nginx.exe &gt; nulECHO Stopping PHP FastCGI...taskkill /F /IM php-cgi-spawner.exe &gt; nultaskkill /F /IM php-cgi.exe &gt; nul</code></pre><p><strong>重载 Nginx 配置：</strong></p><pre><code class="cmd">@ECHO OFFset nginx_home=..\nginxECHO Reloading Nginx...%nginx_home%\nginx.exe -s reload</code></pre><p><strong>启动 Apache</strong>（Apache 会帮我们启动 PHP 的）：</p><pre><code class="cmd">@ECHO OFFset apache_home=..\apacheECHO Starting Apache Httpd....\RunHiddenConsole.exe %apache_home%\bin\httpd.exe</code></pre><p><strong>停止 Apache：</strong></p><pre><code class="cmd">@ECHO OFFECHO Stopping Apache Httpd...taskkill /F /IM httpd.exe &gt; nul</code></pre><p>这些脚本我放在 <code>E:\environment\scripts</code> 目录中，如果你需要放在其他地方，请适当修改脚本中的可执行文件路径。另外，脚本中用到了 <code>RunHiddenConsole.exe</code> 来隐藏命令行窗口，你可以在 <a href="http://redmine.lighttpd.net/attachments/660/RunHiddenConsole.zip" target="_blank" rel="noopener">这里</a> 下载到这个小工具。</p><p><img src="https://img.blessing.studio/images/2018/11/01/wnmp-all-processes.png" alt="wnmp-all-processes"></p><h2 id="0x05-后记"><a href="#0x05-后记" class="headerlink" title="0x05 后记"></a>0x05 后记</h2><p>配置完成后的目录结构大概是这样的（有省略）：</p><pre><code class="text">E:\environment&gt; tree.├── apache│   ├── bin│   ├── cgi-bin│   ├── conf│   │   ├── extra│   │   ├── original│   │   ├── charset.conv│   │   ├── httpd.conf *│   │   ├── magic│   │   ├── mime.types│   │   ├── openssl.cnf│   │   └── vhosts.conf *│   ├── include│   ├── lib│   ├── logs│   └── modules├── mysql│   ├── bin│   ├── data│   ├── include│   ├── lib│   └── share├── nginx│   ├── conf│   │   ├── fastcgi.conf│   │   ├── fastcgi_params│   │   ├── koi-utf│   │   ├── koi-win│   │   ├── mime.types│   │   ├── nginx.conf *│   │   ├── scgi_params│   │   ├── uwsgi_params│   │   ├── vhosts.conf *│   │   └── win-utf│   ├── contrib│   ├── logs│   └── nginx.exe├── php│   ├── dev│   ├── ext│   ├── extras│   ├── lib│   ├── sasl2│   ├── temp│   ├── ...│   ├── php7.dll│   ├── php-cgi.exe│   ├── php-cgi-spawner.exe *│   ├── php.exe│   └── php.ini *└── scripts    ├── reload-nginx.bat    ├── restart-nginx.bat    ├── RunHiddenConsole.exe    ├── start-all.bat    ├── start-apache.bat    ├── start-mysql.bat    ├── start-nginx.bat    ├── stop-all.bat    ├── stop-apache.bat    ├── stop-mysql.bat    └── stop-nginx.bat</code></pre><p>非常清爽，有种一切尽在掌控中的感觉，我喜欢。</p><p>如果你是一名 PHP 开发者，却从来没有手动配置过 PHP 环境的话，那我建议你尝试一下。虽然生产环境上一般都是采用成熟的一键包，不过手动配置一下这一套东西可以更深入地了解 PHP 与 Web Server 的协作机制，这对于编写上层应用以及运维也是很有好处的。</p><p>本来想顺带凑齐一套 WNMP，但是 MySQL 的安装配置相对比较简单，而且也不像 PHP 与 Web Server 那样耦合紧密，所以这里就按下不表。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到这个标题，有人可能会想吐槽：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你他娘的写了这么久 PHP，怎么现在想起来搭建开发环境了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;呃，情况呢是这么个情况，我之前开发的那个 PHP 项目 (&lt;a href=&quot;https://github.com/printempw/blessing-skin-server/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;printempw/blessing-skin-server&lt;/a&gt;) 在两个月前发布 v3.5.0 版本后基本就已经告一段落了。虽然我本意是不再更新&lt;del&gt;（弃坑的委婉说法）&lt;/del&gt;，因为当前的版本已经足够完善，该有的东西都有了（而且说实话搞了这么久我也腻味，不仅是对这个程序，还有对国内 Minecraft 开发生态以及用户群体的失望）。&lt;/p&gt;
&lt;p&gt;不过我的朋友 &lt;a href=&quot;https://blog.gplane.win/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;g-plane&lt;/a&gt; 说他愿意接坑，所以现在这个项目的后续开发都是他在搞。而我也乐得清闲，做个甩手掌柜 &lt;a href=&quot;https://blessing.studio/vscode-c-cpp-configuration-for-acm-oj/&quot;&gt;搞别的&lt;/a&gt; 去了。当我摸鱼正快活时，他过来联系我说准备发布 4.0.0-alpha 了，我才想起来这茬：「啊，我连新版本长啥样都还不知道呢！😂」于是急急忙忙 pull 了新代码准备 review 一下，却发现我的新笔电上甚至压根儿就没安装 PHP 开发环境，只能说是非常地真实。&lt;/p&gt;
&lt;p&gt;因为 &lt;a href=&quot;https://blessing.studio/phpstudy-prober-page-502-bad-gateway/&quot;&gt;某些原因&lt;/a&gt;，我不想继续使用那些 PHP 一键包来搭建开发环境了，所以这次我打算全部自己来。本文记录了我手动安装配置 PHP + Nginx/Apache 开发环境的过程，希望能帮到后来人。&lt;/p&gt;
&lt;p&gt;注意，本文中的配置适用于本地开发环境，应用至生产环境时要注意哦。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="Nginx" scheme="https://blessing.studio/tag/Nginx/"/>
    
      <category term="PHP" scheme="https://blessing.studio/tag/PHP/"/>
    
      <category term="Apache" scheme="https://blessing.studio/tag/Apache/"/>
    
  </entry>
  
  <entry>
    <title>一种监测 VTuber 直播并自动录像的方法</title>
    <link href="https://blessing.studio/live-stream-recorder-for-vtuber-fans/"/>
    <id>https://blessing.studio/live-stream-recorder-for-vtuber-fans/</id>
    <published>2018-10-29T15:45:36.000Z</published>
    <updated>2018-10-29T15:45:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>首先是惯例的闲聊时间。</p><p>虽然这是我第一次在这个博客中提到 <a href="https://zh.wikipedia.org/zh-cn/%E8%99%9B%E6%93%ACYouTuber" target="_blank" rel="noopener">Virtual YouTuber</a>，不过我大概也算是比较早开始看 VTuber 的那一批人了。从始皇帝老爱（<a href="https://zh.wikipedia.org/wiki/%E7%B5%86%E6%84%9B" target="_blank" rel="noopener">キズナアイ</a>）诞生、四天王聚首，到年初 <a href="https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%BC%E3%83%81%E3%83%A3%E3%83%AB%E3%81%AE%E3%81%98%E3%82%83%E3%83%AD%E3%83%AA%E7%8B%90%E5%A8%98Youtuber%E3%81%8A%E3%81%98%E3%81%95%E3%82%93" target="_blank" rel="noopener">狐叔</a> 引领的个人势井喷，再到以彩虹社（<a href="https://ja.wikipedia.org/wiki/%E3%81%AB%E3%81%98%E3%81%95%E3%82%93%E3%81%98" target="_blank" rel="noopener">にじさんじ</a>）为首的 2D 势、杂谈生放势展示了 VTuber 更大的可能性，而注意到这块肥肉的资本们也纷纷入场，百花争鸣的 VTuber 战国时代就此拉开序幕……如此种种，VTuber 界的快速发展令人眼花缭乱，也难怪有「一个月 = VTuber 历一年」的说法。</p><p>不如说 VTuber 的世界实在过于精彩，每天都有大量好玩的内容产出，以至于我甚至已经很久没有看新番动画等传统 ACG 作品，就连游戏也不玩了，只能说 VTuber 沼恐怖如斯。</p><p><img src="https://img.blessing.studio/images/2018/10/29/meme_i_am_ok.jpg" alt="meme_i_am_ok"></p><p>为什么突然谈起这茬？其实我一直都想写一篇关于 VTuber 的文章，但是当时由于学业之类的原因只能搁置。然而到了现在，时间和精力确实是有了，但是正处繁荣期的 VTuber 市场的复杂度，却已经不再是我这孱弱的文笔能够描绘的了。只能说，非常遗憾。</p><p>既然写不出来，那就不写，这是我写博客的标准。如果参考别人的文章照猫画虎、东拼西凑，确实是能挤出一点像样的文字，但那种中途半端的东西又有什么意思呢？我写博客是给自己看的，不是拿去哗众取宠的。所以，牛逼的文章就交给牛逼的人去写，我只管写我自己能写得出来的东西就够了。</p><p>好了，闲话休题，今天我们的主题是「如何对 VTuber 的直播进行自动录像」。</p><a id="more"></a><hr><p>为什么会有这个需求呢？</p><p>简单来说，直播系的 VTuber 虽然有着视频系所无法比肩的「亲近感」与「参与感」，但是直播的形式也不可避免地要消耗观众更多的时间与精力（关于直播系与视频系优缺点的讨论网上有很多，我这里就不再深入）。毕竟当个 NEET 一天 25 小时高强度看直播还是比较有难度的，所以碰到上课、上班时喜欢的 VTuber 正好开播的话就很吃瘪。</p><p>虽然大部分直播系 VTuber 都有为学畜社畜着想、基本都会留下直播的存档录像，但还是有好几个「臭名昭著」的，喜欢突击直播又不爱留档的选手，比如说 —— <a href="https://twitter.com/Freeze_Mea" target="_blank" rel="noopener">神楽めあ</a>。<del>（本来想在这里稍微介绍一下这位屑女仆，但是我发现三言两语根本解释不清 Mea 这个混沌且复杂的 VTuber，遂作罢。或许我下篇关于 VTuber 的博文会是「浅谈神楽めあ的魅力」也说不定，咕咕咕）</del></p><p>但是我又特别喜欢看她的直播、不想错过，怎么办呢？</p><p>要么就他力本願，拜托录像班录好上传，要么就自己动手、丰衣足食。</p><hr><p>好歹我也会捣鼓点代码，于是我就写了几个脚本来完成我的需求（让计算机按照自己的意愿工作，我觉得这就是编程的醍醐味），监视 YouTube、OPENREC、Twitch、TwitCasting 等平台，只要主播一开播就自动开始录像。代码开源在 GitHub 上：</p><p>👉 <a href="https://github.com/printempw/live-stream-recorder" target="_blank" rel="noopener"><strong>printempw/live-stream-recorder</strong></a> 👈</p><p>脚本是我几个月前写的，跑得还算安稳，也成功帮我录下了不少惨遭 Mea 削除存档的直播，可喜可贺。因为当时搜索类似解决方案时基本没看到几个，所以最近把代码整理了一下，糊了个像样的文档分享出来。使用方法都在项目 README 里说明了，这里就不再赘述。</p><p>这玩意儿的原理其实很简单，就是每隔 30s 查询一次直播状态（这一块比较难搞），如果在播就开始录像。录像方面，使用 <a href="https://github.com/rg3/youtube-dl/" target="_blank" rel="noopener">youtube-dl</a> 或者 <a href="https://github.com/streamlink/streamlink" target="_blank" rel="noopener">streamlink</a> 等工具获取直播 HLS 的 <code>.m3u8</code> 地址，然后直接交给 ffmpeg 进行录制（还能顺带推流转播，不得不说 ffmpeg 真是神器）。</p><p><img src="https://img.blessing.studio/images/2018/10/30/live-stream-recorder_logs.png" alt="live-stream-recorder_logs"></p><p>因为功能就这么点，所以我选择了用 Shell 脚本来完成，之后有时间的话或许会用 PHP 给它套个便于操控的网页前端。也可以再优化一下，把轮询模式改为 Pub/Sub 模式，节省点资源（不过我那台 VPS 就是为了录像买的，所以说实话怎样都好）。总之，有缘再说吧。</p><hr><p>其他类似的项目：</p><ul><li><a href="https://www.bilibili.com/read/cv1083415" target="_blank" rel="noopener">【转播 man】其他平台转播到 bilibili 的一种方法</a></li><li><a href="https://www.bilibili.com/read/mobile/1122933" target="_blank" rel="noopener">简单易用 外网直播流转播至 B 站的小工具</a></li><li><a href="https://www.bilibili.com/read/cv1388431" target="_blank" rel="noopener">AutoYtB —— 自动检测 youtube 与推特进行自动转播至 B 站并进行录制与转码</a></li></ul><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;首先是惯例的闲聊时间。&lt;/p&gt;
&lt;p&gt;虽然这是我第一次在这个博客中提到 &lt;a href=&quot;https://zh.wikipedia.org/zh-cn/%E8%99%9B%E6%93%ACYouTuber&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Virtual YouTuber&lt;/a&gt;，不过我大概也算是比较早开始看 VTuber 的那一批人了。从始皇帝老爱（&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B5%86%E6%84%9B&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;キズナアイ&lt;/a&gt;）诞生、四天王聚首，到年初 &lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%83%90%E3%83%BC%E3%83%81%E3%83%A3%E3%83%AB%E3%81%AE%E3%81%98%E3%82%83%E3%83%AD%E3%83%AA%E7%8B%90%E5%A8%98Youtuber%E3%81%8A%E3%81%98%E3%81%95%E3%82%93&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;狐叔&lt;/a&gt; 引领的个人势井喷，再到以彩虹社（&lt;a href=&quot;https://ja.wikipedia.org/wiki/%E3%81%AB%E3%81%98%E3%81%95%E3%82%93%E3%81%98&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;にじさんじ&lt;/a&gt;）为首的 2D 势、杂谈生放势展示了 VTuber 更大的可能性，而注意到这块肥肉的资本们也纷纷入场，百花争鸣的 VTuber 战国时代就此拉开序幕……如此种种，VTuber 界的快速发展令人眼花缭乱，也难怪有「一个月 = VTuber 历一年」的说法。&lt;/p&gt;
&lt;p&gt;不如说 VTuber 的世界实在过于精彩，每天都有大量好玩的内容产出，以至于我甚至已经很久没有看新番动画等传统 ACG 作品，就连游戏也不玩了，只能说 VTuber 沼恐怖如斯。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.blessing.studio/images/2018/10/29/meme_i_am_ok.jpg&quot; alt=&quot;meme_i_am_ok&quot;&gt;&lt;/p&gt;
&lt;p&gt;为什么突然谈起这茬？其实我一直都想写一篇关于 VTuber 的文章，但是当时由于学业之类的原因只能搁置。然而到了现在，时间和精力确实是有了，但是正处繁荣期的 VTuber 市场的复杂度，却已经不再是我这孱弱的文笔能够描绘的了。只能说，非常遗憾。&lt;/p&gt;
&lt;p&gt;既然写不出来，那就不写，这是我写博客的标准。如果参考别人的文章照猫画虎、东拼西凑，确实是能挤出一点像样的文字，但那种中途半端的东西又有什么意思呢？我写博客是给自己看的，不是拿去哗众取宠的。所以，牛逼的文章就交给牛逼的人去写，我只管写我自己能写得出来的东西就够了。&lt;/p&gt;
&lt;p&gt;好了，闲话休题，今天我们的主题是「如何对 VTuber 的直播进行自动录像」。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="VTuber" scheme="https://blessing.studio/tag/VTuber/"/>
    
      <category term="音视频处理" scheme="https://blessing.studio/tag/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>phpStudy 访问探针页面出现 502 Bad Gateway 的解决方法</title>
    <link href="https://blessing.studio/phpstudy-prober-page-502-bad-gateway/"/>
    <id>https://blessing.studio/phpstudy-prober-page-502-bad-gateway/</id>
    <published>2018-10-21T12:36:42.000Z</published>
    <updated>2018-10-21T12:36:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>不要问我为什么要用 phpStudy，我也不想。</p><h2 id="TL-DR-太长不看"><a href="#TL-DR-太长不看" class="headerlink" title="TL;DR 太长不看"></a>TL;DR 太长不看</h2><p>Windows 环境下的 <strong>PHP 7.2.1 / 7.1.13</strong> 这两个版本有问题，在执行 <code>getenv()</code> 函数且第二个参数为 <code>false</code> 时，会造成 PHP FastCGI 进程 ( <code>php-cgi.exe</code> ) 崩溃。这是一个已知的 <a href="https://bugs.php.net/bug.php?id=75794" target="_blank" rel="noopener">BUG</a>，并且已经在 <strong>2018-02-01</strong> 发布的 <strong>PHP 7.2.2</strong> 与 <strong>PHP 7.1.14</strong> 中 <a href="http://www.php.net/ChangeLog-7.php#7.2.2" target="_blank" rel="noopener">被修复</a> 了。</p><p>然而遗憾的是，你现在（截至发稿日 2018-10-21）能在 phpStudy 官网下载到的最新的集成环境，其中的 PHP 版本依然停留在 7.2.1 与 7.1.13。惊不惊喜，意不意外？</p><p><img src="https://img.blessing.studio/images/2018/10/21/phpstudy-fake-version-7210.png" alt="phpstudy-fake-version-7210"></p><p>最绝的是，phpStudy 明明自带的是 <strong>7.2.1</strong> 版本的 PHP，却在界面上显示成了 <strong>7.2.10</strong>，是我瞎了还是你瞎了？补零也不是你这么补的啊兄弟……</p><p>修复方法也很简单，<strong>升级 PHP 版本即可</strong>。</p><p>下面开始讲废话。</p><a id="more"></a><h2 id="0x01-问题描述"><a href="#0x01-问题描述" class="headerlink" title="0x01 问题描述"></a>0x01 问题描述</h2><p>因为某些原因，我需要在 Windows 开发机上重新配置 PHP 开发环境（这个原因等下一篇博文再细说）。以前我一直用的是 <a href="http://www.upupw.net/" target="_blank" rel="noopener">UPUPW 一键包</a>，虽然它很好用，不过考虑到它的默认配置更适用于生产环境而非开发环境，而且相比起来 <a href="http://phpstudy.php.cn/" target="_blank" rel="noopener">phpStudy</a> 可以更方便地切换 PHP 版本与 Web 服务器（有时候测试兼容性要用到），所以最后我选择了使用 phpStudy 进行开发环境的配置。</p><p>然后坑就来了。</p><p>安装完 phpStudy 后，按照我个人的习惯先访问 PHP 探针页面，结果就被糊了一脸 <strong>502 Bad Gateway</strong>。懵了一阵子，开始找日志排查原因。先看 Nginx 的错误日志 <code>error.log</code>：</p><pre><code class="text">2018/10/21 11:45:14 [error] 81019#14893: *10 WSARecv() failed (10054: An existing connection was forcibly closed by the remote host) while reading response header from upstream, client: 127.0.0.1, server: localhost, request: &quot;GET /l.php HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;localhost&quot;</code></pre><p>呃……远程主机强迫关闭了一个现有的连接？从日志来看，Nginx 是正常收到了请求，所以应该是 Nginx 通过 CGI 协议将请求交给 PHP 解析器处理时出现问题了，也就是监听在 <code>127.0.0.1:9000</code> 上的 PHP FastCGI 进程出了问题。（看不懂？那你应该去复习一下 <a href="https://segmentfault.com/q/1010000000256516/a-1020000000259560" target="_blank" rel="noopener">Nginx 与 PHP 交互的流程</a> 了。）</p><h2 id="0x02-问题排查"><a href="#0x02-问题排查" class="headerlink" title="0x02 问题排查"></a>0x02 问题排查</h2><p>接着去看一下 PHP 的错误日志。</p><p>phpStudy 中的 <code>php.ini</code> 默认设置了 <code>log_errors = On</code> 但是没有指定 <code>error_log</code> 的值，所以错误信息会被发送至 SAPI 错误记录器（前提是 <code>error_reporting</code> 设置正确）。在此例中，PHP 会将错误信息通过 CGI 发送至 Nginx，Nginx 捕获后会将错误记录至 <code>error.log</code>，就像这样：</p><pre><code class="test">2018/10/21 11:45:14 [error] 81019#14893: *16 FastCGI sent in stderr: &quot;PHP Fatal error:  Uncaught Error: Call to undefined function test() in E:\environment\bundle\php-study\PHPTutorial\WWW\l.php:183Stack trace:#0 {main}  thrown in E:\environment\bundle\php-study\PHPTutorial\WWW\l.php on line 183&quot; while reading response header from upstream, client: 127.0.0.1, server: localhost, request: &quot;GET /l.php HTTP/1.1&quot;, upstream: &quot;fastcgi://127.0.0.1:9000&quot;, host: &quot;localhost&quot;</code></pre><p>然而我并没有在 <code>error.log</code> 中找到任何 PHP 的错误日志，也就是说……我不信邪，将 <code>error_log</code> 设置为文件日志后，却依然没有任何错误信息。草，没有错误日志你让我玩个屁啊！</p><p>好吧，这种情况下就只能靠万能的 Google 大老师了。</p><p>用关键词「Windows PHP 502 Bad Gateway」查了一下，似乎有说是 <code>php-cgi.exe</code> 进程开太少，造成并发阻塞的话会造成 502。我这才想起来，php-fpm 只适用于类 Unix 系统，Windows 版的 PHP 是没有自带 FastCGI 进程管理器的。打开任务管理器看了一下，果然，phpStudy 只开了一个 <code>php-cgi.exe</code>。</p><p><img src="https://img.blessing.studio/images/2018/10/21/phpstudy-single-php-cgi-process.png" alt="phpstudy-single-php-cgi-process"></p><p>看起来挺靠谱啊！难道就是这玩意造成的 502？</p><p>为了验证，我手动开启了几个 <code>php-cgi.exe</code> 进程，并修改 <code>nginx.conf</code> 如下：</p><pre><code class="nginx">upstream php_fastcgi {    server 127.0.0.1:9000;    server 127.0.0.1:9001;    server 127.0.0.1:9002;}server {    # ...    location ~ ^.+\.php {        # 原来是 fastcgi_pass 127.0.0.1:9000;        fastcgi_pass php_fastcgi;        # ...    }}</code></pre><p>重启 Nginx 后尝试访问之前出问题的页面，很遗憾地，依然是 502 Bad Gateway。不过，虽然问题并不是 <code>php-cgi.exe</code> 进程过少造成的，但是这次尝试并没有白费，我在这次测试中发现了一个现象：</p><p><strong>每次访问这个页面，<code>php-cgi.exe</code> 进程就会异常退出。</strong></p><p>因为 phpStudy 自带守护进程，就算 <code>php-cgi.exe</code> 崩溃了也会马上新开一个，所以我之前一直没有注意到。把所有配置还原成默认状态后观察进程，发现每次访问探针页面时，<code>php-cgi.exe</code> 进程都会死掉然后马上变成新的，然后 Nginx 那边就 502 了。至此，问题基本就能确定了：</p><p><strong>该页面中的某些 PHP 代码会造成 <code>php-cgi.exe</code> 进程崩溃。</strong></p><p>找到问题就好办了，用二分法最后定位到了 <a href="http://www.yahei.net/" target="_blank" rel="noopener">探针</a> 中造成问题的代码：</p><pre><code class="php">&lt;?phpecho getenv(&quot;HTTP_ACCEPT_LANGUAGE&quot;);</code></pre><h2 id="0x03-问题解决"><a href="#0x03-问题解决" class="headerlink" title="0x03 问题解决"></a>0x03 问题解决</h2><p>Google 了一下「php getenv FastCGI crash」，找到不少类似的问题 ( <a href="https://stackoverflow.com/questions/48286208/getenvanystring-is-causing-an-internal-server-error" target="_blank" rel="noopener">#1</a>, <a href="https://segmentfault.com/q/1010000015345101/" target="_blank" rel="noopener">#2</a>, <a href="https://blog.csdn.net/smile12393/article/details/81132040" target="_blank" rel="noopener">#3</a> )，看来并不是个例。就像 TL;DR 中说的一样，这是只有运行在 FastCGI 模式下的 Windows 版 PHP 7.2.1 / 7.1.13 会遇到的一个 <a href="https://bugs.php.net/bug.php?id=75794" target="_blank" rel="noopener">BUG</a>，当 <code>getenv()</code> 的第二参数为 <code>false</code>（默认值）时就会造成 <code>php-cgi.exe</code> 崩溃。Apache 因为基本都是以模块的方式加载 PHP 的，一般不会受此影响，然而 phpStudy 中的 Apache 也是通过 FastCGI 加载 PHP 的，所以一样会中招。</p><p>解决方法也和上面说的一样：<strong>升级 PHP 版本即可</strong>。</p><p>排查这问题前前后后花了我将近一天的时间……因为很不爽所以写了这么一大段来抱怨，还请诸位见谅。另外，我已经受够这些 PHP 集成环境了，所以下一篇博文将是手动配置 WNMP 环境的教程。</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要问我为什么要用 phpStudy，我也不想。&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-太长不看&quot;&gt;&lt;a href=&quot;#TL-DR-太长不看&quot; class=&quot;headerlink&quot; title=&quot;TL;DR 太长不看&quot;&gt;&lt;/a&gt;TL;DR 太长不看&lt;/h2&gt;&lt;p&gt;Windows 环境下的 &lt;strong&gt;PHP 7.2.1 / 7.1.13&lt;/strong&gt; 这两个版本有问题，在执行 &lt;code&gt;getenv()&lt;/code&gt; 函数且第二个参数为 &lt;code&gt;false&lt;/code&gt; 时，会造成 PHP FastCGI 进程 ( &lt;code&gt;php-cgi.exe&lt;/code&gt; ) 崩溃。这是一个已知的 &lt;a href=&quot;https://bugs.php.net/bug.php?id=75794&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;BUG&lt;/a&gt;，并且已经在 &lt;strong&gt;2018-02-01&lt;/strong&gt; 发布的 &lt;strong&gt;PHP 7.2.2&lt;/strong&gt; 与 &lt;strong&gt;PHP 7.1.14&lt;/strong&gt; 中 &lt;a href=&quot;http://www.php.net/ChangeLog-7.php#7.2.2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;被修复&lt;/a&gt; 了。&lt;/p&gt;
&lt;p&gt;然而遗憾的是，你现在（截至发稿日 2018-10-21）能在 phpStudy 官网下载到的最新的集成环境，其中的 PHP 版本依然停留在 7.2.1 与 7.1.13。惊不惊喜，意不意外？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.blessing.studio/images/2018/10/21/phpstudy-fake-version-7210.png&quot; alt=&quot;phpstudy-fake-version-7210&quot;&gt;&lt;/p&gt;
&lt;p&gt;最绝的是，phpStudy 明明自带的是 &lt;strong&gt;7.2.1&lt;/strong&gt; 版本的 PHP，却在界面上显示成了 &lt;strong&gt;7.2.10&lt;/strong&gt;，是我瞎了还是你瞎了？补零也不是你这么补的啊兄弟……&lt;/p&gt;
&lt;p&gt;修复方法也很简单，&lt;strong&gt;升级 PHP 版本即可&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;下面开始讲废话。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="记录" scheme="https://blessing.studio/tag/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="PHP" scheme="https://blessing.studio/tag/PHP/"/>
    
  </entry>
  
  <entry>
    <title>新的网络昵称：PRIN 🍮</title>
    <link href="https://blessing.studio/new-nickname-prin/"/>
    <id>https://blessing.studio/new-nickname-prin/</id>
    <published>2018-10-03T04:24:52.000Z</published>
    <updated>2018-11-03T17:01:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>这不是我第一次这么想：</p><p><strong>我的常用 ID <code>printempw</code> 太难读了。</strong></p><p>有多难读呢？难读到连我自己都不知道这玩意该怎么读。</p><p>这个 ID 的词源是法语的 <em>printemps</em>（春天，春季），将这个单词尾部的 <em>s</em> 替换为 <em>w</em> 后……才怪嘞！我又不会法语，怎么可能是这么高大上的理由嘛（笑）。虽然词源确实是法语，但这个单词是我看了<a href="https://zh.moegirl.org/LoveLive!" target="_blank" rel="noopener">《LoveLive!》</a>后才知道的 —— <a href="https://zh.moegirl.org/zh-hans/Printemps" target="_blank" rel="noopener">Printemps</a> 同时也是企划中 高坂穗乃果、南ことり、小泉花阳 组成的 μ’s 三个小分队之一。当时正好沉迷 LL，取 ID 时顺手就用了这个，因为 <em>printemps</em> 已经被占用了就稍微修改了一下变成现在的 <em>printempw</em> ……</p><p>嗯，真的是个怎样都好的理由。XD</p><hr><p>关于读音，法语单词 <em>printemps</em> 的读音是 [prɛ̃tɑ̃]，LL 中 <em>printemps</em> 的读音是 [プランタン]（到这里就改得没原型了……日本人的外来语发音一如既往地奇妙），按照英语的发音习惯 <em>printemps</em> 大概可以读成 [prɪnˈtemps]，而将单词尾部的 <em>s</em> 修改为 <em>w</em> 后应该读作……</p><p><img src="https://img.blessing.studio/images/2018/10/03/meme-duck-question-mark.jpg" alt="meme-duck-question-mark"></p><p>因此，这几年我一直致力于给自己起一个简单易懂、中日英三语都易于发音、和 <code>printempw</code> 这个常用 ID 有关联、最好能够可爱一些的昵称，但是苦于一直找不到合适的。</p><p>然而就在前几天的高数课上（？），我灵光一闪：</p><blockquote><p> printempw -&gt; PRIN -&gt; プリン -&gt; 🍮 -&gt; 布丁！</p></blockquote><p><del>唉，我他娘的可真是个天才。（不）</del></p><hr><p>情况呢就是这么个情况，这就是我以后的昵称了：</p><ul><li>书写：<strong>PRIN</strong>（中文语境下也可以写成 <strong>布丁</strong>）；</li><li>读音：[プリン] 或者 <em>[prɪn]</em>；</li><li>变动的只是昵称，ID <code>printempw</code> 依然保持不变；</li><li>当然，你不用这个称呼我也不会介意的。:P</li></ul><p>以后博客标题可能也会作出改动，请多关照。🍮</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这不是我第一次这么想：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我的常用 ID &lt;code&gt;printempw&lt;/code&gt; 太难读了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有多难读呢？难读到连我自己都不知道这玩意该怎么读。&lt;/p&gt;
&lt;p&gt;这个 ID 的词源是法语的 &lt;em&gt;printe
      
    
    </summary>
    
      <category term="日常" scheme="https://blessing.studio/categories/diary/"/>
    
    
      <category term="水" scheme="https://blessing.studio/tag/%E6%B0%B4/"/>
    
  </entry>
  
  <entry>
    <title>使用 VS Code 搭建适用于 ACM 练习的 C/C++ 开发环境</title>
    <link href="https://blessing.studio/vscode-c-cpp-configuration-for-acm-oj/"/>
    <id>https://blessing.studio/vscode-c-cpp-configuration-for-acm-oj/</id>
    <published>2018-10-02T10:17:00.000Z</published>
    <updated>2018-10-02T10:17:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>大学入学也快一个月了，总的来说，我过得很开心，不枉我花费一年的时间 <a href="https://blessing.studio/check-in-2018-07/">高考复读</a>。具体哪里令人开心呢？我觉得最主要的是，比起初高中，大学的时间分配更为自由。</p><p><strong>中学时代，学生的时间基本都被学校安排得死死的</strong>：早上什么时间必须到校，然后开始早读、上午五节课下午三节课、晚读、晚自习，最后在规定的时间离校（住宿生还要在规定的时间就寝），可以自由分配的时间少得可怜，在某些管理严格的学校甚至连人身自由都要被限制。虽然学生们苦中作乐的摸鱼技巧也不容小觑，但考虑到升学的压力，如果在兴趣上分配的时间过多，很有可能就会像我去年一样落得个无法升学的尴尬境地。</p><p><strong>而大学相对来说就没有那么多破规矩</strong>：有课就上，没课的话时间就随你安排，回寝室睡觉也好出门嗨皮也罢，突出一个爱干嘛干嘛。在这些闲暇时间里，有人选择加入社团以及各种各样的学生组织，有人寻欢作乐讴歌青春，有人一头扎进自己的兴趣爱好中，也有人选择当个快乐摸鱼侠无事一身轻。</p><p>而我就比较硬核了，我选择参加可能让我基本告别头发的 ACM 程序设计竞赛（不）。</p><p><img src="https://img.blessing.studio/images/2018/10/02/cs-no-hair.jpg" alt="cs-no-hair"></p><p>好啦言归正传，今天我们的主题是在 VS Code 编辑器中搭建适用于 ACM 练习的 C/C++ 开发环境。</p><a id="more"></a><h2 id="0x01-需求分析"><a href="#0x01-需求分析" class="headerlink" title="0x01 需求分析"></a>0x01 需求分析</h2><p>在我们学校，大一新生想要参加 ACM 集训队，必须先在学校的 OJ (Online Judge) 平台上刷完 200 道入门程序题。可选的语言有 C、C++ 和 Java，经过 <a href="https://twitter.com/printempw/status/1040451170962071552" target="_blank" rel="noopener">一番权衡</a> 后，我选择使用 C 语言来完成这些题目。</p><p>由于我之前基本上没有用过 C，所以上手第一步自然是搭建开发环境。</p><p>关于开发环境，C 程序设计的课以及学校 ACM 的讨论群里推荐的一般都是 <a href="http://www.programarts.com/cfree_ch/" target="_blank" rel="noopener">C-Free</a>、<a href="http://www.codeblocks.org/home" target="_blank" rel="noopener">Code::Blocks</a>、<a href="https://sourceforge.net/projects/orwelldevcpp/" target="_blank" rel="noopener">Dev-C++</a> 这类适用于初学者入门的老牌 IDE，但是我不喜欢这些软件，<strong>因为它们太丑了</strong>（直球）。而如果直接用那些现代化的大型 IDE（Visual Studio、CLion 等）的话，大材小用且不说，光启动就要半天我可受不了。所以我选择继续用我最爱的代码编辑器 —— <a href="https://code.visualstudio.com/" target="_blank" rel="noopener">Visual Studio Code</a> 来搭建 C 语言（也适用于 C++）的开发环境。</p><p>另外，鉴于 ACM 这类算法竞赛的特殊性，我们并不需要特别关注开发环境的工程相关特性（比如说依赖管理、代码导航、单元测试、代码重构等），所以我在这篇文章中介绍的开发环境配置基本不会涉及这些功能。如果想要用 C/C++ 开发大型项目，那么还是出门左转乖乖用 IDE 吧。</p><p>我对这个开发环境有如下需求：</p><ul><li><strong>好看</strong>（语法高亮、界面配色等）；</li><li>运行速度快；</li><li>智能提示、自动补全、语法检查；</li><li>一键编译运行；</li><li>断点调试、变量追踪等。</li></ul><p>得益于 VS Code 强大的扩展功能，这些特性通过简单的配置即可实现。</p><h2 id="0x02-安装-C-C-编译器"><a href="#0x02-安装-C-C-编译器" class="headerlink" title="0x02 安装 C/C++ 编译器"></a>0x02 安装 C/C++ 编译器</h2><p>有点常识的选手都知道，程序源码想要运行，必须要经过编译、连接等各种步骤。你在 IDE 上按个按钮就能直接跑，<strong>只是因为 IDE 默默地帮你把这些活儿都干了</strong>（所以一直以来都有人呼吁让编程初学者不要使用 IDE，原因是这会让新手难以了解底层的细节，其实也不是没有道理）。现在，我们得自己来干这些活儿了。</p><p>以下列出主流的 C/C++ 编译器及其适用平台以供参考：</p><ul><li><p><a href="https://gcc.gnu.org/" target="_blank" rel="noopener"><strong>GCC</strong></a> (GNU Compiler Collection)</p><p>相信大家或多或少都听说过 GCC 以及 GNU 工具链的鼎鼎大名。</p><p><em>适用平台：GNU/Linux, Windows (MinGW), Unix, macOS.</em></p></li><li><p><a href="http://clang.llvm.org/" target="_blank" rel="noopener"><strong>Clang</strong></a></p><p>另一个流行的 C/C++/Objective C 编译器，使用 LLVM 后端。</p><p><em>适用平台：GNU/Linux, Windows, Unix, macOS.</em></p></li><li><p><a href="https://blogs.msdn.microsoft.com/vcblog/2017/03/07/msvc-the-best-choice-for-windows/" target="_blank" rel="noopener"><strong>MSVC</strong></a> (Microsoft Visual C++ compiler and libraries toolset)</p><p>微软官方出品的 C/C++ 编译器，Visual Studio 中默认使用的就是这个。后来出了 standalone 版本，现在可以和其他一票 MSVC 工具集一起在 <a href="https://aka.ms/buildtools" target="_blank" rel="noopener">Visual Studio Build Tools</a> 中下载到。</p><p><em>适用平台：Windows.</em></p></li></ul><p>使用什么编译器看个人喜好与实际需求，如果不知道怎么选那就用 GCC，准没错。本文后续的配置也均基于 Windows 上的 GCC 进行，如果你打算使用其他编译器，配置也都是一个道理，自己改改就好了。</p><p>想在 Windows 上使用 GCC，必须安装 <a href="http://www.mingw.org/" target="_blank" rel="noopener">MinGW</a>、<a href="https://www.cygwin.com/" target="_blank" rel="noopener">Cygwin</a> 或者 <a href="http://tdm-gcc.tdragon.net/" target="_blank" rel="noopener">TDM-GCC</a> 这类 GCC 移植版与配套环境。下文将以 <a href="http://mingw-w64.org/" target="_blank" rel="noopener">MinGW-w64</a> （简单来说就是 MinGW 的增强版，如果你想知道它俩之间的那些破事儿也可以自己去搜一搜）为例进行配置。</p><blockquote><p>当然，你也可以安装 <a href="https://blessing.studio/wsl-guide/">WSL (Windows Subsystem for Linux)</a>，在 WSL 中安装 GCC，然后在 Windows 下 <a href="https://github.com/Microsoft/vscode-cpptools/blob/master/Documentation/LanguageServer/Windows%20Subsystem%20for%20Linux.md" target="_blank" rel="noopener">调用 WSL 中的 GCC 编译源码为 Linux 可执行程序</a> 并直接在 WSL 中运行。</p><p><del>如果你愿意，你甚至可以在 WSL 中安装 mingw-w64 交叉编译工具集，然后在 Windows 上调用 WSL 中的 <code>x86_64-w64-mingw32-gcc</code> 交叉编译器在 WSL 中把源码交叉编译为 Windows 可执行程序，最后在 WSL 中运行 Windows 可执行程序……但是没事谁这么蛋疼呢？</del></p></blockquote><p>MinGW-w64 的安装过程我就不赘述了，在 <a href="https://sourceforge.net/projects/mingw-w64/files/" target="_blank" rel="noopener">这里</a> 下载安装包，一路点安装就完事儿了（便携版用户请注意将安装目录下的 <code>bin</code> 目录添加至 <code>PATH</code> 环境变量）。如果你需要，这里也有一个傻瓜教程：<a href="http://rsreland.net/archives/1760" target="_blank" rel="noopener">《⑨也懂系列：MinGW-w64 安装教程》著名 C/C++ 编译器 GCC 的 Windows 版本</a>。</p><p>安装过程中会要求你设置一些选项（这些同样适用于便携版的选择）：</p><ul><li><strong>Version</strong>：GCC 版本，没特殊要求就选最高；</li><li><strong>Architecture</strong>：系统架构，64 位选 <code>x86_64</code>，32 位选 <code>i686</code>；</li><li><strong>Threads</strong>：操作系统 API，拿不准的话就选 <code>win32</code>；</li><li><strong>Exception</strong>：异常处理模型，<code>seh</code> 只支持 64 位系统，<code>sjlj</code> 兼容 32 位；</li><li><strong>Build revision</strong>：修订版本，保持默认即可。</li></ul><p><img src="https://img.blessing.studio/images/2018/10/02/installing-mingw-w64.png" alt="installing-mingw-w64"></p><p>安装完后，在 <code>cmd.exe</code> 或者 PowerShell 中运行 <code>gcc --version</code> 命令，如果看到类似下面这样的输出，那么 MinGW-w64 就算安装完成了。</p><pre><code class="text">gcc.exe (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 5.4.0Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><h2 id="0x03-配置-VS-Code-扩展"><a href="#0x03-配置-VS-Code-扩展" class="headerlink" title="0x03 配置 VS Code 扩展"></a>0x03 配置 VS Code 扩展</h2><p>想要实现我们在第一节提出的需求，必不可少的就是 Microsoft 官方推出的 VS Code <a href="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools" target="_blank" rel="noopener">C/C++ 扩展</a>。这个扩展提供了针对 C/C++ 的 IntelliSense 与调试等功能，搜索「C/C++」即可直接安装。</p><p><img src="https://img.blessing.studio/images/2018/10/02/ms-vscode-cpptools.png" alt="ms-vscode-cpptools"></p><p>安装完后，<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> 打开命令面板运行 <strong>C/Cpp: Edit configurations</strong>，这会自动在当前打开的目录下创建 <code>.vscode/c_cpp_properties.json</code> 配置文件。由于下面的配置文件都是存储在当前文件夹下的 <code>.vscode</code> 目录中而非全局的，所以我推荐专门开一个工作区用于 C/C++ 开发（废话）。</p><p>生成的 <code>c_cpp_properties.json</code> 文件自带模板，你只需要修改其中的 <code>compilerPath</code> 为你的编译器可执行文件所在目录即可。如果你在上一步正确的安装步骤正确，VS Code 甚至可以自动检测你的编译器位置，无需任何修改。在我的机器上，这个文件的内容如下：</p><pre><code class="json">{    &quot;configurations&quot;: [        {            &quot;name&quot;: &quot;MinGW&quot;,            &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;,            &quot;compilerPath&quot;: &quot;C:\\Portable\\mingw64\\bin\\gcc.exe&quot;,            &quot;includePath&quot;: [                &quot;${workspaceFolder}/**&quot;            ],            &quot;defines&quot;: [],            &quot;cStandard&quot;: &quot;c11&quot;,            &quot;cppStandard&quot;: &quot;c++17&quot;        }    ],    &quot;version&quot;: 4}</code></pre><p>另外需要注意的是，网上不少教程都在 <code>includePath</code> 中添加了一大堆乱七八糟的目录，但是现在的 VS Code C/C++ 扩展已经可以通过 <code>compilerPath</code> 自动推断头文件以及库文件所在的目录，所以无需手动配置。</p><p>配置好此文件后，你就可以正常使用 IntelliSense 等功能了。</p><h2 id="0x04-配置一键编译运行"><a href="#0x04-配置一键编译运行" class="headerlink" title="0x04 配置一键编译运行"></a>0x04 配置一键编译运行</h2><p>虽然我们可以写完源码后切换至终端手动运行命令来编译运行：</p><pre><code>$ gcc A.c -o A.exe$ ./A.exe</code></pre><p>但是这样未免也太麻烦，像我这种懒人，一键编译运行肯定是要搞一个的。</p><p>正如标题中提到的，本文所配置的开发环境主要目的是用于 ACM 练习。这些练习题基本上在单文件内即可完成，很少会需要用到多个源文件，更别提 Makefile 之类的工程化构建了。所以针对这些单文件的编译运行，我们有两种方法。其中一种比较简单，另一种稍微复杂一些。</p><p><strong>第一种，使用 Code Runner 扩展。</strong></p><p>这个扩展非常强大，可以让你在 VS Code 中直接运行各种语言的代码。虽然它并不支持复杂的构建流程，但是对于我们这种「编译运行单文件」的需求，Code Runner 正好胜任，而且更为简单快捷。</p><p><img src="https://img.blessing.studio/images/2018/10/02/vsc-code-runner.png" alt="vsc-code-runner"></p><p>扩展安装完成后，进入设置页面搜索 <code>code-runner</code>，可以看到这个扩展提供了很多配置项。这里我推荐各位将自定义的配置项 <strong>保存至工作区</strong>（别告诉我你用了这么久 VS Code 还不知道工作区是啥）而非全局，因为这个扩展也可以用于其他语言，最好不要让我们之后做出的一些专门针对 C/C++ 的配置污染到全局作用域中。</p><p>配置项有很多，各位可以根据自己的实际需求进行修改。以下是一些推荐修改的配置项：</p><pre><code class="javascript">{    // 在终端中运行编译命令，否则我们无法与程序通过标准输入交互    &quot;code-runner.runInTerminal&quot;: true,    // 如果你全局设置中的默认终端是 WSL 之类的，那么可以在工作区设置中改回 PowerShell    &quot;terminal.integrated.shell.windows&quot;: &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe&quot;,    // 运行代码之前清除之前的输出    &quot;code-runner.clearPreviousOutput&quot;: true,    // 开启这个后在运行编译命令之前会自动 cd 至文件所在目录    &quot;code-runner.fileDirectoryAsCwd&quot;: true,    // 因为上面那个选项会自动 cd，所以我删除了默认编译命令中的 cd 语句    // 同时我将编译结果的输出目录修改为了同目录下的 build 文件夹    // 不然源码文件和编译结果混杂在一个目录中非常杂乱（尤其是刷题时）    // 这里只保留了 C 和 C++ 的编译命令，有需要其他语言的请自行添加    &quot;code-runner.executorMap&quot;: {        &quot;c&quot;: &quot;gcc $fileName -o build/$fileNameWithoutExt &amp;&amp; .\\build\\$fileNameWithoutExt&quot;,        &quot;cpp&quot;: &quot;g++ $fileName -o build/$fileNameWithoutExt &amp;&amp; .\\build\\$fileNameWithoutExt&quot;,    },    // 运行代码后切换焦点至终端，方便直接输入测试数据    &quot;code-runner.preserveFocus&quot;: false,    // 在运行代码之前保存文件    &quot;code-runner.saveFileBeforeRun&quot;: true,}</code></pre><p>配置完成后，你可以通过 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>N</kbd> 快捷键（可以自定义，我改成了 <kbd>F5</kbd>）或者右键菜单等方式编译运行当前编辑器中打开的文件，非常方便。效果如下：</p><p><img src="https://img.blessing.studio/images/2018/10/02/code-runner-demo.png" alt="code-runner-demo"></p><p><strong>除了使用 Code Runner，另一种在 VS Code 内执行编译的方法就是定义 Task。</strong></p><p>因为 Code Runner 只适用于单文件的编译运行（这对于 ACM 刷题的练习基本上已经足够），但如果你的程序涉及更复杂的编译流程，或者你需要使用 Debugger，那么就必须定义一个 Task 来完成构建：</p><ul><li><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>P</kbd> 打开命令面板，运行 <strong>Tasks: Configure Task</strong>；</li><li>选择「使用模板创建 tasks.json 文件」；</li><li>选择「Others 运行任意外部命令的示例」。</li></ul><p>这会在 <code>.vscode</code> 目录中生成一个 <code>tasks.json</code> 文件（上面生成的那个 <code>c_cpp_properties.json</code> 配置文件也在这个目录里），将其内容修改为（注意，我这里给出的示例依然是适用于单文件的）：</p><pre><code class="javascript">{    // See https://go.microsoft.com/fwlink/?LinkId=733558    // for the documentation about the tasks.json format    &quot;version&quot;: &quot;2.0.0&quot;,    &quot;tasks&quot;: [        {            &quot;label&quot;: &quot;compile&quot;,            &quot;type&quot;: &quot;shell&quot;,            &quot;command&quot;: &quot;gcc&quot;,            &quot;args&quot;: [                &quot;-g&quot;,                &quot;\&quot;${file}\&quot;&quot;,                &quot;-o&quot;,                &quot;\&quot;${fileDirname}\\build\\${fileBasenameNoExtension}\&quot;&quot;            ],            &quot;presentation&quot;: {                &quot;reveal&quot;: &quot;always&quot;,                &quot;panel&quot;: &quot;shared&quot;,                &quot;focus&quot;: false,                &quot;echo&quot;: true            },            &quot;group&quot;: {                &quot;kind&quot;: &quot;build&quot;,                &quot;isDefault&quot;: true            },            &quot;problemMatcher&quot;: {                &quot;owner&quot;: &quot;cpp&quot;,                &quot;fileLocation&quot;: &quot;absolute&quot;,                &quot;pattern&quot;: {                    &quot;regexp&quot;: &quot;^(.*):(\\d+):(\\d+):\\s+(error):\\s+(.*)$&quot;,                    &quot;file&quot;: 1,                    &quot;line&quot;: 2,                    &quot;column&quot;: 3,                    &quot;severity&quot;: 4,                    &quot;message&quot;: 5                }            }        }    ]}</code></pre><p>我们主要需要关注的就是 <code>command</code> 和 <code>args</code> 这两个配置项，相信大家都能看懂，我就不多解释了。如果你用的是 C++，将 <code>command</code> 中的 <code>gcc</code> 修改为 <code>g++</code> 即可。如果你想知道其他那些配置项是啥意思，也可以参考 VS Code 的官方文档：<a href="https://code.visualstudio.com/docs/editor/tasks" target="_blank" rel="noopener">Integrate with External Tools via Tasks</a>。</p><p>配置完成后，我们就可以通过命令面板运行 <strong>Tasks: Run Build Task</strong> 或者 <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>B</kbd> 快捷键运行刚才定义的 Task 执行构建（不过这只会执行编译命令，并不会运行编译后的程序）。</p><h2 id="0x05-配置调试器"><a href="#0x05-配置调试器" class="headerlink" title="0x05 配置调试器"></a>0x05 配置调试器</h2><p>配置好了一键编译运行，我们还得配置一下调试器 (Debugger)。虽然我以前写 PHP 和 JavaScript 时都是不用调试器、<code>var_dump</code> <code>console.log</code> 一把梭的选手，但是这在写 C 时可行不通，所以还是乖乖用调试器吧。</p><p>C/C++ 的调试器也有很多，下面以我们之前安装的 MinGW-w64 中配套的 GDB 为例进行配置：</p><ul><li>在 VS Code 侧边栏切换至「调试」面板；</li><li>点击面板上部的齿轮图标（配置或修复 <code>launch.json</code>）；</li><li>在弹出的「选择环境」面板中选择 <code>C++ (GDB/LLDB)</code>。</li></ul><p><img src="https://img.blessing.studio/images/2018/10/02/configue-launch-json.png" alt="configue-launch-json"></p><p>这会在当前工作区的 <code>.vscode</code> 目录中新建一个 <code>launch.json</code> 文件，修改文件内容如下：</p><pre><code class="javascript">{    // Use IntelliSense to learn about possible attributes.    // Hover to view descriptions of existing attributes.    // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387    &quot;version&quot;: &quot;0.2.0&quot;,    &quot;configurations&quot;: [        {            &quot;name&quot;: &quot;(gdb) Launch&quot;,            &quot;type&quot;: &quot;cppdbg&quot;,            &quot;request&quot;: &quot;launch&quot;,            &quot;program&quot;: &quot;${fileDirname}/build/${fileBasenameNoExtension}.exe&quot;,            &quot;args&quot;: [],            &quot;stopAtEntry&quot;: false,            &quot;cwd&quot;: &quot;${workspaceFolder}&quot;,            &quot;environment&quot;: [],            &quot;externalConsole&quot;: true,            &quot;MIMode&quot;: &quot;gdb&quot;,            // 这里填你 MinGW-w64 安装目录下的 gdb 路径            &quot;miDebuggerPath&quot;: &quot;C:\\Portable\\mingw64\\bin\\gdb.exe&quot;,            &quot;setupCommands&quot;: [                {                    &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,                    &quot;text&quot;: &quot;-enable-pretty-printing&quot;,                    &quot;ignoreFailures&quot;: true                }            ],            // 这里要与你在 tasks.json 中配置的 label 一致            &quot;preLaunchTask&quot;: &quot;compile&quot;,        }    ]}</code></pre><p>其中各配置项的作用可以参阅官方文档：<a href="https://github.com/Microsoft/vscode-cpptools/blob/master/launch.md" target="_blank" rel="noopener">Configuring launch.json for C/C++ debugging</a>.</p><p>配置正确后的调试效果图如下：</p><p><img src="https://img.blessing.studio/images/2018/10/02/vsc-debugger-demo.png" alt="vsc-debugger-demo"></p><h2 id="0x06-后记"><a href="#0x06-后记" class="headerlink" title="0x06 后记"></a>0x06 后记</h2><p>至此，我们已经完成了对 VS Code C/C++ 开发环境的配置。</p><p>虽然真正用 C/C++ 开发项目时还是用正儿八经的 IDE 比较好，但是如果只是用于 ACM 这类算法相关竞赛的刷题练习的话，用 VS Code 这类轻量级的代码编辑器还是非常舒适的。</p><p>如果想了解更多使用 VS Code 开发 C/C++ 的信息，这里有一些参考链接：</p><ul><li><a href="https://code.visualstudio.com/docs/languages/cpp" target="_blank" rel="noopener">C/C++ for Visual Studio Code (Preview)</a></li><li><a href="https://github.com/Microsoft/vscode-cpptools" target="_blank" rel="noopener">Microsoft/vscode-cpptools</a></li><li><a href="https://segmentfault.com/a/1190000014800106" target="_blank" rel="noopener">使用 Visual Studio Code 搭建 C/C++ 开发和调试环境</a></li><li><a href="https://www.jianshu.com/p/8933ebdac814" target="_blank" rel="noopener">使用 VSCode 搭建 C/C++ 开发环境</a></li></ul><p>以上。<img src="https://img.blessing.studio/images/2018/10/02/meme-i-am-so-vegetable.jpg" alt="meme-i-am-so-vegetable"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大学入学也快一个月了，总的来说，我过得很开心，不枉我花费一年的时间 &lt;a href=&quot;https://blessing.studio/check-in-2018-07/&quot;&gt;高考复读&lt;/a&gt;。具体哪里令人开心呢？我觉得最主要的是，比起初高中，大学的时间分配更为自由。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中学时代，学生的时间基本都被学校安排得死死的&lt;/strong&gt;：早上什么时间必须到校，然后开始早读、上午五节课下午三节课、晚读、晚自习，最后在规定的时间离校（住宿生还要在规定的时间就寝），可以自由分配的时间少得可怜，在某些管理严格的学校甚至连人身自由都要被限制。虽然学生们苦中作乐的摸鱼技巧也不容小觑，但考虑到升学的压力，如果在兴趣上分配的时间过多，很有可能就会像我去年一样落得个无法升学的尴尬境地。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而大学相对来说就没有那么多破规矩&lt;/strong&gt;：有课就上，没课的话时间就随你安排，回寝室睡觉也好出门嗨皮也罢，突出一个爱干嘛干嘛。在这些闲暇时间里，有人选择加入社团以及各种各样的学生组织，有人寻欢作乐讴歌青春，有人一头扎进自己的兴趣爱好中，也有人选择当个快乐摸鱼侠无事一身轻。&lt;/p&gt;
&lt;p&gt;而我就比较硬核了，我选择参加可能让我基本告别头发的 ACM 程序设计竞赛（不）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.blessing.studio/images/2018/10/02/cs-no-hair.jpg&quot; alt=&quot;cs-no-hair&quot;&gt;&lt;/p&gt;
&lt;p&gt;好啦言归正传，今天我们的主题是在 VS Code 编辑器中搭建适用于 ACM 练习的 C/C++ 开发环境。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="VS Code" scheme="https://blessing.studio/tag/VS-Code/"/>
    
      <category term="C/C++" scheme="https://blessing.studio/tag/C-C/"/>
    
      <category term="ACM" scheme="https://blessing.studio/tag/ACM/"/>
    
  </entry>
  
  <entry>
    <title>WSL 配置指北：打造 Windows 最强命令行</title>
    <link href="https://blessing.studio/wsl-guide/"/>
    <id>https://blessing.studio/wsl-guide/</id>
    <published>2018-09-08T07:07:41.000Z</published>
    <updated>2018-09-08T07:07:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>在两年前的八月，Microsoft 正式发布了 Windows 10 Anniversary Update 周年更新（它还有着 RS1，Version 1607，Build 14393 等一大堆别名）。其中最让包括我在内的众多开发者感到兴奋的特性之一，就是 WSL（Windows Subsystem for Linux，当时还叫 Bash on Ubuntu on Windows）的正式加入。</p><p><strong>在 Windows 上原生运行 Linux 可执行文件，牛逼疯了！</strong></p><p>然而 Bug10 也不是浪得虚名，原本只提供给 Insider 的 WSL 在正式发布后依然问题多多（不仅 zsh、tmux 等工具无法使用，网络相关的操作更是一概欠奉，还有各种各样 <a href="https://twitter.com/printempw/status/927862325280772096" target="_blank" rel="noopener">奇妙的 BUG</a>），基本没有可用性，我在尝鲜了一段时间后也不得不重回 Cygwin 的怀抱。不过好消息是，在之后的更新中，<a href="https://blogs.msdn.microsoft.com/commandline/2017/04/11/windows-10-creators-update-whats-new-in-bashwsl-windows-console/" target="_blank" rel="noopener">这些 BUG 都已被逐一消灭</a>。</p><p>经过了两年的发展，WSL 已经<a href="https://twitter.com/printempw/status/927898980385677312" target="_blank" rel="noopener">足够成熟</a>，我也是时候完成这篇<a href="https://twitter.com/printempw/status/928656863310200832" target="_blank" rel="noopener">一咕再咕</a>的博文了。</p><p>（开学在即，仓促成文，如有谬误，还请指正。）</p><p><img src="https://img.blessing.studio/images/2018/09/08/get-wsl.png" alt="get-wsl"></p><a id="more"></a><h2 id="1-我理想中的命令行界面"><a href="#1-我理想中的命令行界面" class="headerlink" title="1. 我理想中的命令行界面"></a>1. 我理想中的命令行界面</h2><p>既然<del>违反广告法</del>取了这么个标题，那我自然得先描述一下我的目标，也就是我理想中的命令行界面应该是什么样子的（如果你不清楚命令行的概念，可以看看我之前写的 <a href="https://blessing.studio/the-difference-between-cli-terminal-shell-tty/">这篇文章</a>）：</p><ul><li><strong>好看</strong>（配色、字体可以自由设定）；</li><li>支持 UTF-8 字符的输入与显示；</li><li>支持常见的 *NIX 命令行工具（cat、grep、awk 等）；</li><li>自动补全、语法高亮、历史记录；</li><li>完善的复制粘贴支持；</li><li>互操作性（共享文件系统、网络栈，可调用 Win32 程序）；</li><li>支持常用的脚本语言（PHP、Python、Node.js 等）；</li><li>包管理器，以及其他各种常用软件的支持；</li><li>快速呼出（快捷键、右键菜单入口）。</li></ul><p>然而遗憾的是，Windows 上的命令行一直以来都很微妙。</p><h2 id="2-难用的-Windows-命令行"><a href="#2-难用的-Windows-命令行" class="headerlink" title="2. 难用的 Windows 命令行"></a>2. 难用的 Windows 命令行</h2><p>停停停，那边的 PowerShell 爱好者 ，咱别动粗成吗？</p><p>首先我要对标题做出一些订正，Windows 原生命令行其实也可以不那么难用。虽然 cmd.exe 是公认的难用到反人类（毕竟是用来兼容 DOS 的老古董），但后来推出的 PowerShell 已经足够强大且现代化，能够称得上是一个成熟的命令行 Shell 了。<strong>如果你愿意学习的话，PowerShell 几乎可以满足你对命令行的所有期待。</strong>这一点可以参见：<a href="https://stackoverflow.com/a/573861" target="_blank" rel="noopener">Is PowerShell ready to replace my Cygwin shell on Windows?</a></p><p>但是，PowerShell 与 Bash 等类 Unix 系统上的 Shell 程序几乎是两个完全不同的世界。不仅语法不同，其平台上各类常用的命令行工具也基本不一致（比如类 Unix 系统中的 <code>grep</code> 对应 PowerShell 中的 <code>Select-String</code>，<code>uniq</code> 对应 <code>Select-Object -Unique</code> 等）。往深了说，他们的系统设计理念都是不一样的，比如很多人推崇的 <a href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6" target="_blank" rel="noopener">Unix 哲学</a>，在 Windows 上就基本不见踪影；而 COM 等概念也是 Windows 独一份。</p><p><img src="https://img.blessing.studio/images/2018/09/08/manga-system-admin-girl-sp-wsl.png" alt="manga-system-admin-girl-sp-wsl"></p><p><em>▲ 图片来源：<a href="https://system-admin-girl.com/comic/begins/sp-wsl/" target="_blank" rel="noopener">シス管系女子 BEGINS 特別編 まんがでわかる WSL</a></em></p><p>当然，我无意在此挑起操作系统间的圣战。Windows 和类 Unix 系统中的命令行哪个好用，见仁见智。不过对于包括我在内的很多用户都认为 Windows 命令行不怎么好用，仅此而已。</p><p>回到正题。</p><p><strong>虽然 Windows 的命令行一直遭人诟病，但是人家的图形界面牛逼啊。</strong>于是无数工程师前赴后继，试图在 Windows 上创造出不输给类 Unix 系统的命令行体验 —— 却绝大多数以失败告终。曾经努力过的人，或者回到可爱的 Linux 上，或者进入高贵冷艳的 macOS 的世界。其中有先辈留下了 Cygwin、GnuWin32 等工具集，让我们可以在 Windows 下使用类 Unix 系统中常见的命令行工具，成为了不少 Windows 用户的救赎。</p><p>然而，就当大家都觉得「也就这样了」的时候，Microsoft 出人意料地站了出来。</p><p>带着他新鲜出炉的 WSL。</p><h2 id="3-Windows-Subsystem-for-Linux，参上！"><a href="#3-Windows-Subsystem-for-Linux，参上！" class="headerlink" title="3. Windows Subsystem for Linux，参上！"></a>3. Windows Subsystem for Linux，参上！</h2><p>大家都把 WSL 吹得这么牛逼，那 WSL 究竟是个什么玩意儿呢？</p><p>简单来说，WSL 是一个 <strong><a href="https://zh.wikipedia.org/wiki/%E5%85%BC%E5%AE%B9%E5%B1%82" target="_blank" rel="noopener">兼容层</a></strong>，有点像反过来的 Wine。</p><hr><p>首先，我问个问题，为什么 Linux 上的程序无法在 Windows 上运行呢？</p><p>了解过一点操作系统原理的同学应该都知道，这是 Windows 与 Linux 的内核提供的接口不同（系统调用、API 等）导致的。举个栗子，我们想知道某目录下的内容，在 Linux 下我们会使用 <code>ls</code> 命令，而在 Windows 下我们会使用 <code>dir</code> 命令。</p><p>当我们在 Linux 上执行 <code>ls</code> 命令，<code>ls</code> 会调用 <code>getdents</code> 这个系统调用，Linux 内核收到请求，将目录的内容返回给应用程序；当我们在 Windows 上执行 <code>dir</code> 命令，<code>dir</code> 会调用 <code>NtQueryDirectoryFile</code> 这个 API，NT 内核收到请求，将目录的内容返回给应用程序。虽然系统不同，但基本上都是一个道理。</p><p>然而，当我们把 Linux 上的应用程序拿到 Windows 上运行时，应用程序和内核就双双懵逼了。比如 <code>ls</code> 会尝试调用 <code>getdents</code> 系统调用（理想化的情况下，暂不考虑可执行文件格式等问题），Windows 的 NT 内核一看，心说：「这他娘的什么东西，老子不认识啊，啥情况啊」，<code>ls</code> 也想：「尼玛，内核怎么不回话啊，咋回事儿啊」……两边语言不通，应用程序自然无法正确执行。</p><p>但是有了 WSL，情况就不一样了。</p><p>依然拿 <code>ls</code> 举例，当我们在 WSL 中运行 <code>ls</code> 命令时，<code>ls</code> 会调用 <code>getdents</code> 系统调用（这个系统调用接口是 WSL 提供的，Windows 本身并没有这个接口），WSL 收到这个请求，明白了应用程序是想要知道目录的内容，<strong>于是把 Linux 的系统调用转换为 NT API <code>NtQueryDirectoryFile</code></strong>。NT 内核收到 WSL 的请求，将目录的内容返回给 WSL，WSL 再把返回的内容包装好后返回给 <code>ls</code>。</p><p>也就是说，WSL 在 Linux 应用程序与 Windows NT 内核之间起到了<strong>翻译者</strong>的作用。很简单的道理，既然 NT 内核无法理解 Linux 应用程序的 POSIX 系统调用，那就弄个翻译来将 POSIX 系统调用实时转换为 NT 内核能理解的 API 调用，突出一个见人说人话、见鬼说鬼话。</p><p>只要实现了足够多的系统调用翻译，那么理论上 WSL 可以完全模拟成一个 Linux 内核。</p><hr><p>相信各位都听说过鼎鼎大名的 Cygwin。同样是能让 Linux 应用程序运行在 Windows 上，WSL 和 Cygwin 有什么不同呢？其实差别还是挺大的。</p><p>虽然 Cygwin 提供了完整的 POSIX 系统调用 API（以运行库  <code>Cygwin*.dll</code> 的形式提供），但其依然工作在 User Mode；而 WSL 中的 Linux 应用程序进程会被包裹在一个叫做 Pico Process 的东西里，这个东西里发出的所有系统调用请求都会被直接送往 Kernel Mode 中的 <code>lxcore.sys</code> 与 <code>lxss.sys</code> 处理。</p><p>同样是将 POSIX 系统调用转换为 Windows 中的 API，Cygwin 是转换成 Win32 API 的调用（因为它架设在 Win32 子系统上，很多内核操作受限于 Win32 的实现，比如 <code>fork</code>），而 WSL 则是转换为更底层的 NT API 调用（WSL 是与 Win32 平行的子系统，直接架设在 NT 内核上，可以通过 NT API 原生实现 <code>fork</code> 等系统调用）。</p><p><img src="https://img.blessing.studio/images/2018/09/08/wsl-architecture.png" alt="wsl-architecture"></p><p><em>▲ WSL 架构示意图。图片来源：<a href="https://blog.jessfraz.com/post/windows-for-linux-nerds/" target="_blank" rel="noopener">Windows for Linux Nerds</a></em></p><p>最重要的一点：如果使用 Cygwin，Linux 应用程序的源码必须 link 至 Cygwin 运行库（<code>Cygwin*.dll</code>），<strong>修改源码重新编译后才能在 Windows 下运行</strong>。这些重新编译后的 Linux 应用程序在调用 POSIX API 时不会直接去请求内核，而是会去调用 Cygwin 运行库，由运行库翻译成 Win32 API、执行调用后返回结果。这也就意味着，重新编译后的应用程序需要依赖 Cygwin 运行库才能正常运行（有时候你会碰到的「缺少 <code>Cygwin1.dll</code>」报错就是这个原因），而且这样编译出来的可执行程序是纯正的 Win32 PE 格式封装，只能在 Windows 上运行。</p><p>而在 WSL 下，我们可以直接运行未经任何修改的 ELF 格式 Linux 可执行程序。</p><p><img src="https://img.blessing.studio/images/2018/09/08/ls-exe-in-cygwin.png" alt="ls-exe-in-cygwin"></p><p><em>▲ Cygwin 目录下，被编译成 Win32 可执行程序的 Linux 应用程序们。</em></p><p>最后总结一波：</p><p>WSL 就像是一个翻译官，就算那些未经修改的 Linux 应用程序们操着一口纯正的 POSIX 系统调用语法，WSL 也能快速准确地将其翻译为 NT 内核能听懂的 API 调用；</p><p>而那些使用了 Cygwin 重新编译后的 Linux 应用程序，就像是改造人一样变成了 Win32 应用程序的形状，还被套了个翻译机。程序自己（源码中）说的是 POSIX，经过翻译机（Cygwin 运行库）之后就变成 Win32 API 调用了，这样 NT 内核也能听得懂。</p><p>但是每次添加新程序都要改造，多麻烦啊，还是 WSL 原生态更健康（笑）。</p><hr><p>以上只是我对 WSL 的粗浅解释，其具体实现原理可以参考官方博客上的 <a href="https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/" target="_blank" rel="noopener">这一系列文章</a>。</p><h2 id="4-安装-WSL，拥抱可爱的-Linux"><a href="#4-安装-WSL，拥抱可爱的-Linux" class="headerlink" title="4. 安装 WSL，拥抱可爱的 Linux"></a>4. 安装 WSL，拥抱可爱的 Linux</h2><p>好了不说废话，让我们开始安装 WSL。<strong>注意，WSL 仅支持 64 位系统，且本文中所描述的安装方法仅适用于 Windows 10 Fall Creators Update</strong>（秋季创意者更新，RS3，Version 1709，Build 16299）及以上版本。</p><p><strong>第一步</strong>，打开「控制面板」中的「程序与功能」，点击左侧边栏的「启用或关闭 Windows 功能」选项，在弹出的窗口中勾选「适用于 Linux 的 Windows 子系统」，然后点击确定（可能需要重启）。</p><p>如果你懒得用 GUI，也可以直接在 PowerShell 中以管理员权限执行命令：</p><pre><code class="powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code></pre><p><img src="https://img.blessing.studio/images/2018/09/08/enable-windows-optional-feature.png" alt="enable-windows-optional-feature"></p><p><strong>第二步</strong>，打开 Microsoft Store，搜索「WSL」。挑选一个你喜欢的 Linux 发行版，然后点击安装。（截至目前，商店中可用的发行版有 Ubuntu、openSUSE、SUSE Linux Enterprise Server、Debian 以及 Kali Linux。）</p><p><img src="https://img.blessing.studio/images/2018/09/08/microsoft-store-wsl.png" alt="microsoft-store-wsl"></p><p><strong>第三步</strong>，在开始菜单中找到你刚刚安装的发行版，打开它。等待几分钟的初始化过程，设定好用户名与密码后（不需要与 Windows 的相同，用过 Linux 的选手应该都懂的）就会自动进入 Linux 环境。</p><p>至此，你已经完成了 WSL 的安装。</p><p>你也可以同时安装多个发行版，它们的数据都是独立的，互不影响。</p><p><img src="https://img.blessing.studio/images/2018/09/08/initialize-wsl.png" alt="initialize-wsl"></p><h2 id="5-使用更专业的终端模拟器"><a href="#5-使用更专业的终端模拟器" class="headerlink" title="5. 使用更专业的终端模拟器"></a>5. 使用更专业的终端模拟器</h2><p>我猜你现在正在对上面那个窗口发呆。</p><p><strong>—— 这个新宋体他娘的是个什么情况？</strong></p><p>如果你正在使用中文 Windows 系统，而且之前并没有修改过 Win32 Console 的默认配置，那么你的 WSL 终端默认就会是这样的。新宋体，就是这么 Hardcore。惊不惊喜，意不意外？</p><p>好吧不开玩笑，Windows 这个控制台窗口就是很多人讨厌它的原因之一，难用又难看。丑这一点倒还有解决方法（经过一番设置后还算能看，我以前就写过一篇关于 <a href="https://blessing.studio/windows-change-cmd-font/">自定义 Windows 控制台字体</a> 的文章），难用却是实打实的。尽管 Win10 上的控制台已经改进了不少（可以看看 Microsoft 的官方博客：<a href="https://blogs.msdn.microsoft.com/commandline/" target="_blank" rel="noopener">Windows Command Line Tools For Developers</a>），但其依然是最难用的终端模拟器之一，或许没有之一。</p><p>因此，为了实现我们的目标，一个更强大的终端模拟器是必须的。</p><blockquote><p>终端模拟器是什么？为了这个回答这个问题，我专门写了一篇文章，<a href="https://blessing.studio/the-difference-between-cli-terminal-shell-tty/">去看看吧</a>。:P</p></blockquote><p>我个人比较推荐的终端模拟器有：</p><ul><li><p><strong><a href="https://github.com/goreliu/wsl-terminal" target="_blank" rel="noopener">wsl-terminal</a></strong></p><p>专门为 WSL 开发的终端模拟器，基于 mintty 与 wslbridge，稳定易用。</p></li><li><p><strong><a href="https://conemu.github.io/" target="_blank" rel="noopener">ConEmu</a></strong></p><p>Windows 上的老牌终端模拟器，功能极为强大，要啥有啥。</p></li><li><p><strong><a href="https://hyper.is/" target="_blank" rel="noopener">Hyper</a></strong></p><p>基于 Electron 的跨平台终端模拟器，好看和可扩展性是卖点，<a href="https://github.com/zeit/hyper/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc" target="_blank" rel="noopener">BUG 不少</a>。</p></li></ul><p>还有其他各种各样的终端模拟器，选个自己喜欢的就好。反正不管选哪个，都比默认的那玩意儿要好用。🌚</p><p>另外，设定终端模拟器的 Shell 入口时有个坑，需要注意一下（参见下文 6.4）。</p><p><img src="https://img.blessing.studio/images/2018/08/22/my-terminals.png" alt="my-terminals"></p><p><em>▲ 我正在使用的终端，wsl-terminal 与 Hyper。<del>好看是第一生产力。</del></em></p><h2 id="6-让我们更深入一些"><a href="#6-让我们更深入一些" class="headerlink" title="6. 让我们更深入一些"></a>6. 让我们更深入一些</h2><p>以下是 WSL 的一些优化技巧。</p><h3 id="6-1-使用软件源镜像"><a href="#6-1-使用软件源镜像" class="headerlink" title="6.1 使用软件源镜像"></a>6.1 使用软件源镜像</h3><p>由于众所周知的原因，各大发行版默认的软件源在中国大陆的访问速度都很屎。</p><p>我目前使用的是 <a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华大学的 Ubuntu 镜像源</a>。</p><h3 id="6-2-安装-zsh-与-oh-my-zsh"><a href="#6-2-安装-zsh-与-oh-my-zsh" class="headerlink" title="6.2 安装 zsh 与 oh-my-zsh"></a>6.2 安装 zsh 与 oh-my-zsh</h3><p>想要快乐地使用命令行，一个趁手的 Shell 是必不可少的。</p><p>我个人习惯使用 zsh，安装步骤不再赘述。<a href="https://gist.github.com/printempw/1ae3b8ae3091a6cfd65a22e1872af7ab" target="_blank" rel="noopener">我的自定义 oh-my-zsh 主题</a>：</p><pre><code class="shell"># ~/.oh-my-zsh/custom/themes/robbyrussell-ascii.zsh-theme# Modified from robbyrussell, the default theme of oh-my-zsh.# &gt; blog git:(source) x $local ret_status=&quot;%(?:%{$fg_bold[green]%}&gt;:%{$fg_bold[red]%}&gt;%s)&quot;PROMPT=&#39;${ret_status} %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)$ &#39;ZSH_THEME_GIT_PROMPT_PREFIX=&quot;%{$fg_bold[blue]%}git:(%{$fg[red]%}&quot;ZSH_THEME_GIT_PROMPT_SUFFIX=&quot;%{$reset_color%} &quot;ZSH_THEME_GIT_PROMPT_DIRTY=&quot;%{$fg[blue]%}) %{$fg[yellow]%}x%{$reset_color%}&quot;ZSH_THEME_GIT_PROMPT_CLEAN=&quot;%{$fg[blue]%})&quot;</code></pre><pre><code class="shell"># ~/.zshrcZSH_THEME=&quot;robbyrussell-ascii&quot;plugins=(git zsh-completions zsh-autosuggestions zsh-syntax-highlighting)</code></pre><h3 id="6-3-安装多个发行版"><a href="#6-3-安装多个发行版" class="headerlink" title="6.3 安装多个发行版"></a>6.3 安装多个发行版</h3><p>Windows 10 Fall Creators Update 之后，WSL 支持同时安装多个 Linux 发行版，直接在 Microsoft Store 中搜索想要的发行版并点击安装即可。这些发行版可以同时运行，并且数据互相独立。你可以使用 <code>wslconfig.exe</code> 来查询已安装的发行版，或者更改默认的发行版。</p><p><img src="https://img.blessing.studio/images/2018/09/08/multiple-wsl-distributions.png" alt="multiple-wsl-distributions"></p><p>删除发行版也很简单，直接卸载对应的商店应用即可（记得备份哦）。</p><h3 id="6-4-多种进入-WSL-的方式比较"><a href="#6-4-多种进入-WSL-的方式比较" class="headerlink" title="6.4 多种进入 WSL 的方式比较"></a>6.4 多种进入 WSL 的方式比较</h3><p>新版支持同时安装多个发行版，那自然不能像以前那样只提供一个 <code>bash.exe</code> 入口了。</p><p>秋季创意者更新之后的 Windows 提供了 <a href="https://blogs.msdn.microsoft.com/commandline/2017/11/28/a-guide-to-invoking-wsl/" target="_blank" rel="noopener">多种进入 WSL 环境的方式</a>：</p><ul><li><p><code>wsl.exe</code></p><p>打开<strong>默认</strong>发行版中的默认 Shell。</p></li><li><p><code>&lt;distroname&gt;.exe</code></p><p>打开<strong>指定</strong>发行版中的默认 Shell。</p></li><li><p><code>bash.exe</code> (DEPRECATED)</p><p>打开<strong>默认</strong>发行版中的 <strong>bash</strong> Shell。</p><p>如果你更改了默认 Shell 却总是打开 bash，就说明你使用了这个入口。</p></li></ul><p>你也可以通过这些入口直接在 WSL 中执行命令并返回结果：</p><ul><li><code>&lt;distroname&gt; -c [command]</code></li><li><code>bash -c [command]</code></li><li><code>wsl [command]</code>（不再需要指定 <code>-c</code>）</li></ul><p><img src="https://img.blessing.studio/images/2018/09/08/invoking-wsl-in-many-ways.png" alt="invoking-wsl-in-many-ways"></p><h3 id="6-5-与-Windows-的互操作性"><a href="#6-5-与-Windows-的互操作性" class="headerlink" title="6.5 与 Windows 的互操作性"></a>6.5 与 Windows 的互操作性</h3><p>WSL 与 Windows 之间的互操作性 (Interoperability) 很牛逼。怎么个牛逼法呢？</p><p>Windows 下的所有盘符都挂载在 WSL 中的 <code>/mnt</code> 目录下，可以直接操作。WSL 中的所有数据则存放于 <code>C:\Users\{你的用户名}\AppData\Local\Packages\{Linux发行版包名}\LocalState\rootfs</code> 目录中（不要在 Windows 中修改这些文件，这会造成文件权限错误）：</p><pre><code>$ ls /mntc  d  e$ mount -lrootfs on / type lxfs (rw,noatime)C: on /mnt/c type drvfs (rw,noatime,uid=1000,gid=1000)D: on /mnt/d type drvfs (rw,noatime,uid=1000,gid=1000)E: on /mnt/e type drvfs (rw,noatime,uid=1000,gid=1000)</code></pre><p>你可以在 Windows 命令行环境中直接调用 WSL 中的命令：</p><pre><code class="cmd">PS C:\temp&gt; wsl ls -altotal 0drwxrwxrwx 1 printempw printempw 4096 Sep  7 19:04 .drwxrwxrwx 1 printempw printempw 4096 Sep  7 18:38 ..-rwxrwxrwx 1 printempw printempw    4 Sep  7 19:04 foo.txt</code></pre><p>你也可以在 WSL 中调用 Windows 中的命令行程序：</p><pre><code class="shell">$ which ipconfig.exe/mnt/c/Windows/System32/ipconfig.exe$ ipconfig.exeWindows IP Configuration...</code></pre><p>你可以在 WSL 中直接启动 Windows 应用：</p><pre><code>$ notepad.exe &quot;C:\temp\foo.txt&quot;</code></pre><p>你还可以通过 pipes 与 Windows 程序通信：</p><pre><code># 复制内容至 Windows 剪贴板$ cat foo.txt | clip.exe</code></pre><p>你甚至可以把 Windows 命令和 WSL 命令混着用：</p><pre><code>PS&gt; ipconfig | wsl grep IPv4IPv4 Address. . . . . . . . . . . : 192.168.1.114$ ipconfig.exe | grep IPv4 | cut -d: -f2192.168.1.114$ ls -al | findstr.exe foo.txt-rwxrwxrwx 1 printempw printempw    4 Sep  7 19:04 foo.txt$ cmd.exe /c dir Volume in drive C is Windows Volume Serial Number is B263-**** Directory of C:\temp2018/09/07  19:04    &lt;DIR&gt;          .2018/09/07  19:04    &lt;DIR&gt;          ..2018/09/07  19:04                 4 foo.txt               1 File(s)              4 bytes               2 Dir(s)  194,422,341,632 bytes free</code></pre><p>同时，WSL 与 Windows 共享网络栈，也就是说你可以：</p><ul><li>在 WSL 中启动 web server，在 Windows 上使用浏览器访问；</li><li>在 Windows 下启动 MySQL/Redis 服务器，在 WSL 中连接；</li><li>诸如此类。</li></ul><p>如果你对 WSL 与 Windows 之间互操作的原理有兴趣，可以参考一下这些文章：</p><ul><li><a href="https://docs.microsoft.com/en-us/windows/wsl/interop" target="_blank" rel="noopener">WSL interoperability with Windows</a></li><li><a href="https://blogs.msdn.microsoft.com/wsl/2016/10/19/windows-and-ubuntu-interoperability/" target="_blank" rel="noopener">Windows and Ubuntu Interoperability</a></li></ul><h3 id="6-6-DrvFs-文件权限问题"><a href="#6-6-DrvFs-文件权限问题" class="headerlink" title="6.6 DrvFs 文件权限问题"></a>6.6 DrvFs 文件权限问题</h3><p>虽然 WSL 中可以直接访问 Windows 磁盘的内容，但如果你曾经这么做过，你应该对这样绿油油一片的 <code>ls</code> 不会感到陌生。为什么 NTFS 文件系统中的文件到 WSL 下权限就全部成 <code>0777</code> 了呢？</p><p><img src="https://img.blessing.studio/images/2018/09/08/ls-with-wrong-file-permission.png" alt="ls-with-wrong-file-permission"></p><p>这主要是 DrvFs 中 Linux 文件权限的实现导致的。</p><p>在 WSL 中，<a href="https://blogs.msdn.microsoft.com/wsl/2016/06/15/wsl-file-system-support/" target="_blank" rel="noopener">Microsoft 实现了两种文件系统</a>，用于支持不同的使用场景：</p><ul><li><p><strong>VolFs</strong></p><p>着力于在 Windows 文件系统上提供完整的 Linux 文件系统特性，通过各种手段实现了对 Inodes、Directory entries、File objects、File descriptors、Special file types 的支持。比如为了支持 Windows 上没有的 Inodes，VolFs 会把文件权限等信息保存在文件的 NTFS Extended Attributes 中。记得我上面警告过你不要在 Windows 中修改 WSL 里的文件吗？就是因为 Windows 中新建的文件缺少这个扩展参数，VolFs 无法正确获取该文件的 metadata，而且有些 Windows 上的编辑器会在保存时抹掉这些附加参数。</p><p>WSL 中的 <code>/</code> 使用的就是 VolFs 文件系统。</p></li><li><p><strong>DrvFs</strong></p><p>着力于提供与 Windows 文件系统的互操作性。与 VolFs 不同，为了提供最大的互操作性，DrvFs 不会在文件的 NTFS Extended Attributes 中储存附加信息，而是从 Windows 的文件权限（Access Control Lists，就是你右键文件 &gt; 属性 &gt; 安全选项卡中的那些权限配置）推断出该文件对应的的 Linux 文件权限。</p><p>所有 Windows 盘符挂载至 WSL 下的 <code>/mnt</code> 时都是使用的 DrvFs 文件系统。</p></li></ul><p>由于 DrvFs 的文件权限继承机制很微妙，最后导致的结果就是所有文件的权限都变成了 <code>0777</code>。而且由于早期的 DrvFs 不支持 metadata，所以你无法给这些文件 chown/chmod，只能对着绿油油的 <code>ls</code> 干瞪眼。不过好消息是，Windows Insider Build 17063 之后，<a href="https://blogs.msdn.microsoft.com/commandline/2018/01/12/chmod-chown-wsl-improvements/" target="_blank" rel="noopener">DrvFs 也像 VolFs 一样支持给文件写入 metadata 了</a>。</p><p>要启用 DrvFs 的 metadata 支持，你需要添加参数重新挂载磁盘：</p><pre><code># 修改成你自己的盘符$ sudo umount /mnt/e$ sudo mount -t drvfs E: /mnt/e -o metadata</code></pre><p>不过如果仅仅是执行了这个，虽然支持了文件权限的修改，但磁盘下的文件权限默认依然还是 <code>0777</code>，除非你给它们整个 <code>chmod</code> 一遍。如果你不想这么做，也可以指定其他的 mount 参数：</p><pre><code>$ sudo mount -t drvfs E: /mnt/e -o metadata,uid=1000,gid=1000,umask=22,fmask=111</code></pre><p>这样磁盘下的文件的默认权限就是 <code>0644</code>，<code>ls</code> 也不会再是绿油油一片啦。</p><p><img src="https://img.blessing.studio/images/2018/09/08/ls-with-fixed-file-permission.png" alt="ls-with-fixed-file-permission"></p><p>不过每次使用时都要重新挂载未免也太烦，我们可以通过另一个新特性 <a href="https://blogs.msdn.microsoft.com/commandline/2018/02/07/automatically-configuring-wsl/" target="_blank" rel="noopener">Automatically Configuring WSL</a> 实现自动挂载。在 WSL 中创建 <code>/etc/wsl.conf</code>，在其中填写如下内容：</p><pre><code class="ini">[automount]enabled = trueroot = /mnt/options = &quot;metadata,umask=22,fmask=111&quot;mountFsTab = true# 这个文件里还可以添加其他配置项，有兴趣的可以看看上面的链接</code></pre><p>重启终端，所有的盘符就会使用上面的配置自动挂载啦（可以使用 <code>mount -l</code> 查看）。</p><p>另外，如果你想要给不同的盘符设定不同的挂载参数（上面的方法对所有盘符都有效，如果你想在 WSL 中运行 Windows 下的应用程序，就得每次都 <code>chmod +x</code> 一下，所以我一般都会把 <code>C:</code> 排除掉），就需要手动修改 <code>/etc/fstab</code>。首先确保 <code>wsl.conf</code> 中的 <code>mountFsTab</code> 为 <code>true</code>，然后编辑 <code>/etc/fstab</code>，添加如下内容：</p><pre><code># 不在此列表中的盘符会使用 wsl.conf 中的参数挂载# 格式可以自己去查 fstab 的帮助文档E: /mnt/e drvfs rw,relatime,uid=1000,gid=1000,metadata,umask=22,fmask=111 0 0</code></pre><h3 id="6-7-其他关于-WSL-的折腾"><a href="#6-7-其他关于-WSL-的折腾" class="headerlink" title="6.7 其他关于 WSL 的折腾"></a>6.7 其他关于 WSL 的折腾</h3><p>虽然 Microsoft 开发 WSL 出来主要是着重于命令行环境的使用，但经过测试，WSL 是可以通过 X Server 执行 GUI 应用程序的，<a href="https://news.ycombinator.com/item?id=13603451" target="_blank" rel="noopener">甚至还可以在 WSL 里面用 Wine 执行 Windows 程序</a>……（🤔？）</p><p>也有人试过在 WSL 中运行完整的 DE，体验似乎还不错，有兴趣的同学可以去试试。</p><p>另外，你也可以通过某些神秘的方法用上 Microsoft Store 未提供的 Linux 发行版，比如 <a href="https://wiki.archlinux.org/index.php/Install_on_WSL_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener">Arch Linux</a>。</p><p>如果你对 WSL 的底层实现有兴趣，也可以去围观一下 WSL 的官方博客：</p><ul><li><a href="https://blogs.msdn.microsoft.com/wsl/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/wsl/</a></li><li><a href="https://blogs.msdn.microsoft.com/commandline/tag/wsl/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/commandline/tag/wsl/</a></li></ul><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>虽然 WSL 很不错，但是其比起真正的 Linux 系统还是有很多不足（Docker 等涉及未实现的内核特性的软件无法使用，Raw socket 相关的操作依然容易出错，I/O 性能相比之下较为孱弱等）。如果你日常开发中需要使用到那些 WSL 未提供的 Linux 特性，那么还是乖乖跑 VM 或者装 Linux 吧。</p><p><strong>对我来说，WSL 最大的意义就是，让我能够用我熟悉的 Linux 那一套去操作 Windows</strong>。</p><p>如果你和我的需求一样，那么比起 Cygwin、VM 等解决方案，WSL 有着完整的 Linux 环境、强大的互操作性、更低的资源占用。离不开 Windows，却又羡慕 Linux 下强大命令行工具的各位，相信你们会喜欢 WSL 的。</p><p>而且最近几年 Microsoft 在笼络开发者方面的努力大家有目共睹，这里就容我夸上一句：</p><p><strong>Microsoft，干得漂亮！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在两年前的八月，Microsoft 正式发布了 Windows 10 Anniversary Update 周年更新（它还有着 RS1，Version 1607，Build 14393 等一大堆别名）。其中最让包括我在内的众多开发者感到兴奋的特性之一，就是 WSL（Windows Subsystem for Linux，当时还叫 Bash on Ubuntu on Windows）的正式加入。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在 Windows 上原生运行 Linux 可执行文件，牛逼疯了！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;然而 Bug10 也不是浪得虚名，原本只提供给 Insider 的 WSL 在正式发布后依然问题多多（不仅 zsh、tmux 等工具无法使用，网络相关的操作更是一概欠奉，还有各种各样 &lt;a href=&quot;https://twitter.com/printempw/status/927862325280772096&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;奇妙的 BUG&lt;/a&gt;），基本没有可用性，我在尝鲜了一段时间后也不得不重回 Cygwin 的怀抱。不过好消息是，在之后的更新中，&lt;a href=&quot;https://blogs.msdn.microsoft.com/commandline/2017/04/11/windows-10-creators-update-whats-new-in-bashwsl-windows-console/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这些 BUG 都已被逐一消灭&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;经过了两年的发展，WSL 已经&lt;a href=&quot;https://twitter.com/printempw/status/927898980385677312&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;足够成熟&lt;/a&gt;，我也是时候完成这篇&lt;a href=&quot;https://twitter.com/printempw/status/928656863310200832&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一咕再咕&lt;/a&gt;的博文了。&lt;/p&gt;
&lt;p&gt;（开学在即，仓促成文，如有谬误，还请指正。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.blessing.studio/images/2018/09/08/get-wsl.png&quot; alt=&quot;get-wsl&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="Windows" scheme="https://blessing.studio/tag/Windows/"/>
    
      <category term="CLI" scheme="https://blessing.studio/tag/CLI/"/>
    
      <category term="WSL" scheme="https://blessing.studio/tag/WSL/"/>
    
  </entry>
  
  <entry>
    <title>添加 Notepad++ 至右键菜单的几种方法</title>
    <link href="https://blessing.studio/add-notepad-plus-plus-to-context-menu/"/>
    <id>https://blessing.studio/add-notepad-plus-plus-to-context-menu/</id>
    <published>2018-08-28T18:35:05.000Z</published>
    <updated>2018-08-28T18:35:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一名即将开学的计算机系 <a href="https://blessing.studio/check-in-2018-07/">准大学生</a>，笔记本电脑总归是要有一台的。于是上星期我入手了 <a href="https://twitter.com/printempw/status/1030043615983104000" target="_blank" rel="noopener">小米游戏本顶配版</a>（i7-8750H + 16G + GTX 1066），最近正在重新折腾开发环境，这篇文章要解决的问题也是在此过程中出现的。</p><p>至于为什么要买小米的本子，主要是因为它的「游戏本性能 + 商务本外观」这一点正戳中我好球区。不过这几天使用下来，只能说缺点确实不少，有购买意愿的朋友需谨慎。在 Twitter 上搜索 <code>小米游戏本 from:printempw</code> 就能看到我发的吐槽简评，如果之后有时间的话也打算专门写篇评测（咕咕咕）。</p><p>回到正题。因为以前家里的电脑是全家共用的所以没什么，不过最近有了自己的电脑，我的软件洁癖就上来了：<strong>有<a href="https://zh.wikipedia.org/wiki/%E7%B6%A0%E8%89%B2%E8%BB%9F%E9%AB%94" target="_blank" rel="noopener">绿色版</a>（便携软件，Portable Application）的绝不用安装版，国产软件一律扔沙盒运行。</strong></p><p>看起来有点偏执，不过我就属于那种想把自己设备中的一切纳入可控范围内的人。Windows 在这点上就很讨厌，尤其是注册表的设计，比类 Unix 系统难管理了不是一点半点。在手机上也是一样，不能解锁 bootloader 的 Android 机器我绝对不会购买，AppOps、Magisk、<a href="https://play.google.com/store/apps/details?id=moe.shizuku.redirectstorage" target="_blank" rel="noopener">存储重定向</a> 等工具更是必备。虽然我也没偏执到「每条指令运行都需要我的许可」那种程度，不过至少，我的设备必须听我的话，我说什么不能做那就是不能做，你他娘的不能给我自作主张（比如 Windows <a href="https://www.zhihu.com/question/271414438" target="_blank" rel="noopener">广受诟病的自动更新机制</a>、某些臭名昭著的国产软件扫描用户硬盘等）。为什么？<strong>因为是我在用电脑，不是电脑用我。</strong></p><p>好了言归正传（没错，本博客就是有在进入正题之前瞎扯一通的习惯）。</p><p><a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a> 是一款我很喜欢的文本编辑器，除了写代码和写文章外的一般文本编辑工作我都是使用它完成的，配置新电脑时自然不能少了它。我下载的是 Portable 便携版，不过也正因如此，原本在 Installer 中通过选项可以添加的 <em>Edit with Notepad++</em> 右键菜单项也没有了（此操作需要写注册表）。</p><p>因为这个右键菜单还蛮好用的，所以我打算把它找回来。</p><p><img src="https://img.blessing.studio/images/2018/08/29/npp-context-menu-demo.png" alt="npp-context-menu-demo"></p><a id="more"></a><h2 id="方法一：使用官方提供的-NppShell-dll"><a href="#方法一：使用官方提供的-NppShell-dll" class="headerlink" title="方法一：使用官方提供的 NppShell.dll"></a>方法一：使用官方提供的 NppShell.dll</h2><p>此方法来自 Notepad++ 的官方 Wiki（见底部参考链接）。</p><p>添加右键菜单项需要修改注册表，除了手动修改注册表，Notepad++ 官方还提供了一个 DLL 文件用于注册以及卸载右键菜单。如果你使用的是安装版，那么在程序目录下应该会有一个 <code>NppShell_06.dll</code> 文件（不同版本下文件名中的数字可能会不同）；如果没有或者是便携版，那么请在这里下载该文件：</p><p><a href="https://github.com/notepad-plus-plus/notepad-plus-plus/tree/master/PowerEditor/bin" target="_blank" rel="noopener">https://github.com/notepad-plus-plus/notepad-plus-plus/tree/master/PowerEditor/bin</a></p><p>上面的地址是 Notepad++ 官方 GitHub 仓库中提供的预编译 DLL，32 位系统的用户请下载 <code>NppShell.dll</code>，64 位系统的请下载 <code>NppShell64.dll</code>。不要吐槽为啥这文件四年没更新了，因为人家确实是四年没更新了，Wiki 原文中提供的链接还是八年前的呢（笑）。</p><p>下载后，打开一个具有管理员权限的 <code>cmd.exe</code> 或者 PowerShell，cd 到 Notepad++ 的安装目录（直接指定 DLL 的绝对路径是没用的，必须在程序目录下运行），并运行如下命令（文件名自行替换）：</p><pre><code class="powershell">regsvr32 /i NppShell64.dll</code></pre><p>运行后会弹出一个对话框，直接点 OK 就可以了。</p><p>如果没给管理员权限，会报错「模块 NppShell64.dll 已加载，但对 DllRegisterServer 的调用失败」。</p><p><img src="https://img.blessing.studio/images/2018/08/29/regsrv32-i-nppshell-dll.png" alt="regsrv32-i-nppshell-dll"></p><p>如果要删除右键菜单，请运行：</p><pre><code class="powershell">regsvr32 /u NppShell64.dll</code></pre><p>如果你不会运行这些命令也没事，将以下内容使用记事本保存为 <code>.bat</code> 文件，放到 Notepad++ 的安装目录下，右键「以管理员身份运行」即可（此脚本修改自：<a href="http://www.ok12.net/?post=31" target="_blank" rel="noopener">Notepad++ 添加右键打开菜单 - 成功志</a>）。</p><pre><code class="cmd">@Echo Offcd /d %~dp0title Notepad++ 右键菜单添加/删除工具SetLocal EnableDelayedExpansionecho 1. 添加 Notepad++ 右键菜单echo ------------------------echo 2. 删除 Notepad++ 右键菜单echo ------------------------Set /p u=请输入数字并按 Enter 确定：If &quot;%u%&quot;==&quot;1&quot; Goto regnppIf &quot;%u%&quot;==&quot;2&quot; Goto unregnpp:regnppregsvr32 /i NppShell64.dllexit:unregnppregsvr32 /u NppShell64.dllexit</code></pre><h2 id="方法二：手动修改注册表"><a href="#方法二：手动修改注册表" class="headerlink" title="方法二：手动修改注册表"></a>方法二：手动修改注册表</h2><p>如果你不想用上面的那个方法，也可以自己手动修改注册表。</p><p>修改注册表添加右键菜单项有两种方法，这里先介绍简单点的方法。</p><p>将以下内容保存为 <code>.reg</code> 文件，双击运行即可（其中可执行文件路径和菜单项名称请自行替换）：</p><pre><code>Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\*\shell\NotePad++]@=&quot;Edit with &amp;Notepad++&quot;&quot;Icon&quot;=&quot;C:\\Portable\\notepad-pp\\notepad++.exe&quot;[HKEY_CLASSES_ROOT\*\shell\NotePad++\Command]@=&quot;C:\\Portable\\notepad-pp\\notepad++.exe \&quot;%1\&quot;&quot;</code></pre><p>如果要删除右键菜单，也是一样的道理：</p><pre><code>Windows Registry Editor Version 5.00[-HKEY_CLASSES_ROOT\*\shell\NotePad++]</code></pre><h2 id="方法三：手动修改注册表-使用-Context-Menu-Handler"><a href="#方法三：手动修改注册表-使用-Context-Menu-Handler" class="headerlink" title="方法三：手动修改注册表 - 使用 Context Menu Handler"></a>方法三：手动修改注册表 - 使用 Context Menu Handler</h2><p>Windows 下添加项目至文件的右键菜单有两种方式，一种是上面提到的直接往注册表 <code>HKEY_CLASSES_ROOT\{file_type}\shell</code> 里面加东西，另外一种更牛逼一点，需要注册 Context Menu Handlers。</p><p>怎么个牛逼法呢？简单来说，Windows 会在显示右键菜单之前调用注册的 handler，handler 可以动态地修改右键菜单的内容，从而实现更加灵活的自定义，而不像上一种方法那样只能写死（比如说各种压缩软件在不同文件上的右键菜单项文本都是不同的）。有兴趣的同学可以去看看 <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/cc144169%28v=vs.85%29.aspx" target="_blank" rel="noopener">MSDN 文档</a>（反正我对 Win32 开发是没兴趣，不仅文档繁杂，Windows 的注册表也让我很讨厌，看着就烦）。</p><p>回到正题。开头提到的 NppShell.dll 也是使用 Context Menu Handler 实现的，我从 <a href="https://github.com/notepad-plus-plus/notepad-plus-plus/blob/master/PowerEditor/src/tools/NppShell/src/NppShell.cpp" target="_blank" rel="noopener">源码</a> 里把其添加的注册表项扒出来了，使用方法和上一节一样（如果你是 32 位的系统，请将下面的 <code>{B298D29A-A6ED-11DE-BA8C-A68E55D89593}</code> 替换为 <code>{00F3C2EC-A6EE-11DE-A03A-EF8F55D89593}</code>）：</p><pre><code>Windows Registry Editor Version 5.00[HKEY_CLASSES_ROOT\CLSID\{B298D29A-A6ED-11DE-BA8C-A68E55D89593}]@=&quot;ANotepad++64&quot;[HKEY_CLASSES_ROOT\CLSID\{B298D29A-A6ED-11DE-BA8C-A68E55D89593}\InprocServer32]@=&quot;C:\\Portable\\notepad-pp\\notepad++.exe&quot;&quot;ThreadingModel&quot;=&quot;Apartment&quot;[HKEY_CLASSES_ROOT\CLSID\{B298D29A-A6ED-11DE-BA8C-A68E55D89593}\Settings]&quot;Title&quot;=&quot;Edit with &amp;Notepad++&quot;&quot;Path&quot;=&quot;C:\\Portable\\notepad-pp\\notepad++.exe&quot;&quot;Custom&quot;=&quot;&quot;&quot;ShowIcon&quot;=dword:00000001&quot;Dynamic&quot;=dword:00000001&quot;Maxtext&quot;=dword:00000019[HKEY_CLASSES_ROOT\*\shellex\ContextMenuHandlers\ANotepad++64]@=&quot;{B298D29A-A6ED-11DE-BA8C-A68E55D89593}&quot;</code></pre><p>如果你要删除右键菜单，同理：</p><pre><code>Windows Registry Editor Version 5.00[-HKEY_CLASSES_ROOT\*\shellex\ContextMenuHandlers\Notepad++64][-HKEY_CLASSES_ROOT\CLSID\{B298D29A-A6ED-11DE-BA8C-A68E55D89593}]</code></pre><h2 id="方法四：使用「发送到」快捷方式"><a href="#方法四：使用「发送到」快捷方式" class="headerlink" title="方法四：使用「发送到」快捷方式"></a>方法四：使用「发送到」快捷方式</h2><p>看到这里，有些人可能会吐槽：你这都改注册表了，还绿色软件个毛线啊！</p><p>呃，好吧，无法反驳。🤔</p><p>对于那些不愿意修改注册表，又想通过右键菜单便捷打开 Notepad++ 的选手，这里有一个不错的方法：使用 Windows 自带的「发送到」功能。</p><p>首先在资源管理器的地址栏中输入 <code>shell:sendto</code> 并回车，你会被重定向至 <code>C:\Users\{username}\AppData\Roaming\Microsoft\Windows\SendTo</code> 目录。在此目录下建立一个到 <code>notepad++.exe</code> 的快捷方式，你就可以通过右键菜单中的「发送到」实现同样的功能。</p><p>虽然比直接添加右键菜单要多操作一步，不过我倒觉得这样更简单优雅。另外，这一技巧也同样适用于其他应用程序，大家可以记一下哦。;)</p><p><img src="https://img.blessing.studio/images/2018/08/29/npp-send-to-menu.png" alt="npp-send-to-menu"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我对 Win32 开发不熟，上面那些都是现学现卖的，如有口胡还请告知。</p><p>参考链接：</p><ul><li><a href="http://docs.notepad-plus-plus.org/index.php/Explorer_Context_Menu" target="_blank" rel="noopener">Adding Notepad++ to the context menu of the Windows file manager</a></li><li><a href="https://www.cnblogs.com/mq0036/p/3815728.html" target="_blank" rel="noopener">给 Notepad++ 加右键菜单带图标</a></li><li><a href="http://www.catmee.com/add-context-menu-for-notepad-plus-plus/" target="_blank" rel="noopener">为 Notepad++ 添加带图标的右键菜单</a></li><li><a href="https://github.com/notepad-plus-plus/notepad-plus-plus/blob/master/PowerEditor/src/tools/NppShell/src/NppShell.cpp" target="_blank" rel="noopener">notepad-plus-plus/PowerEditor/src/tools/NppShell/src/NppShell.cpp</a></li><li><a href="http://blog.darkthread.net/post-2017-06-05-open-notepad-with-contextmenu.aspx" target="_blank" rel="noopener">檔案總管右鍵選單開啟免安裝版 Notepad++</a></li></ul><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一名即将开学的计算机系 &lt;a href=&quot;https://blessing.studio/check-in-2018-07/&quot;&gt;准大学生&lt;/a&gt;，笔记本电脑总归是要有一台的。于是上星期我入手了 &lt;a href=&quot;https://twitter.com/printempw/status/1030043615983104000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;小米游戏本顶配版&lt;/a&gt;（i7-8750H + 16G + GTX 1066），最近正在重新折腾开发环境，这篇文章要解决的问题也是在此过程中出现的。&lt;/p&gt;
&lt;p&gt;至于为什么要买小米的本子，主要是因为它的「游戏本性能 + 商务本外观」这一点正戳中我好球区。不过这几天使用下来，只能说缺点确实不少，有购买意愿的朋友需谨慎。在 Twitter 上搜索 &lt;code&gt;小米游戏本 from:printempw&lt;/code&gt; 就能看到我发的吐槽简评，如果之后有时间的话也打算专门写篇评测（咕咕咕）。&lt;/p&gt;
&lt;p&gt;回到正题。因为以前家里的电脑是全家共用的所以没什么，不过最近有了自己的电脑，我的软件洁癖就上来了：&lt;strong&gt;有&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E7%B6%A0%E8%89%B2%E8%BB%9F%E9%AB%94&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;绿色版&lt;/a&gt;（便携软件，Portable Application）的绝不用安装版，国产软件一律扔沙盒运行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看起来有点偏执，不过我就属于那种想把自己设备中的一切纳入可控范围内的人。Windows 在这点上就很讨厌，尤其是注册表的设计，比类 Unix 系统难管理了不是一点半点。在手机上也是一样，不能解锁 bootloader 的 Android 机器我绝对不会购买，AppOps、Magisk、&lt;a href=&quot;https://play.google.com/store/apps/details?id=moe.shizuku.redirectstorage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;存储重定向&lt;/a&gt; 等工具更是必备。虽然我也没偏执到「每条指令运行都需要我的许可」那种程度，不过至少，我的设备必须听我的话，我说什么不能做那就是不能做，你他娘的不能给我自作主张（比如 Windows &lt;a href=&quot;https://www.zhihu.com/question/271414438&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;广受诟病的自动更新机制&lt;/a&gt;、某些臭名昭著的国产软件扫描用户硬盘等）。为什么？&lt;strong&gt;因为是我在用电脑，不是电脑用我。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;好了言归正传（没错，本博客就是有在进入正题之前瞎扯一通的习惯）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://notepad-plus-plus.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Notepad++&lt;/a&gt; 是一款我很喜欢的文本编辑器，除了写代码和写文章外的一般文本编辑工作我都是使用它完成的，配置新电脑时自然不能少了它。我下载的是 Portable 便携版，不过也正因如此，原本在 Installer 中通过选项可以添加的 &lt;em&gt;Edit with Notepad++&lt;/em&gt; 右键菜单项也没有了（此操作需要写注册表）。&lt;/p&gt;
&lt;p&gt;因为这个右键菜单还蛮好用的，所以我打算把它找回来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.blessing.studio/images/2018/08/29/npp-context-menu-demo.png&quot; alt=&quot;npp-context-menu-demo&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="记录" scheme="https://blessing.studio/tag/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Windows" scheme="https://blessing.studio/tag/Windows/"/>
    
  </entry>
  
  <entry>
    <title>博客迁移至 GitHub Pages</title>
    <link href="https://blessing.studio/migrate-to-github-pages/"/>
    <id>https://blessing.studio/migrate-to-github-pages/</id>
    <published>2018-08-23T18:16:56.000Z</published>
    <updated>2018-08-23T18:16:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>就在刚才，我把博客完全迁移到了 GitHub Pages 上。</p><p>为啥呢？简单来说，就是我懒得维护服务器了。</p><p>去年十月份，我为博客添加了 <a href="https://blessing.studio/deploy-hexo-blog-automatically-with-travis-ci/">Travis CI 自动构建流程</a>，发布新博文只需要把 Markdown 源码 push 至 GitHub 上的仓库，CI 会帮我自动完成后续的所有步骤，很适合我这种懒人。</p><p>在我的 CI 脚本中，博客构建完毕后会把构建结果 <a href="https://github.com/printempw/printempw.github.io/blob/source/.travis/deploy.sh#L19" target="_blank" rel="noopener">同时推送</a> 至 GitHub Pages 和我自己的服务器。由于我之前一直是在自有服务器上部署的动态博客程序（WordPress、Ghost），一直用下来也没什么不妥，所以当时我也只是把 GitHub Pages 当成一个备胎，博客域名依然是解析到自有服务器上的。</p><p>但是最近我想了想，把博客部署在自己的服务器上，有几点不好：</p><p>首先是服务可用率。我是个穷屌，只有一台 DigitalOcean $5 的机器，既没有负载均衡，也没有冗余服务器。如果这台机器宕掉了，那博客就只能跟着下线，谁也访问不了。而且事实上我的服务器就有好几次莫名其妙出现过 Kernel Panic，收到监控报警后只能灰溜溜地去登录控制台重启服务器。</p><p>另外就是，我想在这个世界上留下点什么东西。如果博客放在我自己的服务器上的话，假如我出了啥三长两短、服务器久了没人管理，那我的博客很有可能就烟消云散了，多难过啊。</p><p>不过当然啦，要是那么在意这个的话，我就去用 Medium 这类写作平台，而不是自建独立博客了。我觉得 GitHub Pages 这类托管服务算是一个不错的平衡点，既保留了独立博客的风格，又不用特别去担心服务器的问题，自己只用操心内容就够了，挺不错的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;就在刚才，我把博客完全迁移到了 GitHub Pages 上。&lt;/p&gt;
&lt;p&gt;为啥呢？简单来说，就是我懒得维护服务器了。&lt;/p&gt;
&lt;p&gt;去年十月份，我为博客添加了 &lt;a href=&quot;https://blessing.studio/deploy-hexo-blog-autom
      
    
    </summary>
    
      <category term="日常" scheme="https://blessing.studio/categories/diary/"/>
    
    
      <category term="博客" scheme="https://blessing.studio/tag/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>命令行界面 (CLI)、终端 (Terminal)、Shell、TTY，傻傻分不清楚？</title>
    <link href="https://blessing.studio/the-difference-between-cli-terminal-shell-tty/"/>
    <id>https://blessing.studio/the-difference-between-cli-terminal-shell-tty/</id>
    <published>2018-08-22T14:30:13.000Z</published>
    <updated>2018-08-22T14:30:13.000Z</updated>
    
    <content type="html"><![CDATA[<p>诸君，好久不见。</p><p>为什么突然想写这样一篇文章呢？其实是因为在最近计划发布的一篇关于 WSL (Windows Subsystem for Linux) 的博文中，我打算对终端模拟器、Shell 的选择与配置进行一些说明。不过对于刚接触 Linux 或者刚接触命令行界面的同学，可能会有些难以理解它们之间的区别（事实上我当初也是这样）。</p><p>虽然这个话题已是老生常谈，搜索一下应该也能找到大把的相关文章。不过难得提到了这方面，就趁此机会把我的理解写下来，一来看看我是不是真正理解了，二来看看我能不能把它们之间的区别讲得更加简明易懂。</p><h2 id="0-太长不看-TL-DR"><a href="#0-太长不看-TL-DR" class="headerlink" title="0. 太长不看 TL;DR"></a>0. 太长不看 TL;DR</h2><ul><li><strong>命令行界面</strong> (CLI) = 使用文本命令进行交互的用户界面</li><li><strong>终端</strong> (Terminal) = <strong>TTY</strong> = 文本输入/输出环境</li><li><strong>控制台</strong> (Console) = 一种特殊的终端</li><li><strong>Shell</strong> = 命令行解释器，执行用户输入的命令并返回结果</li></ul><h2 id="1-什么是命令行界面？"><a href="#1-什么是命令行界面？" class="headerlink" title="1. 什么是命令行界面？"></a>1. 什么是命令行界面？</h2><p>命令行界面，通俗来讲，就是你看过的那种满屏幕都是字符的界面。</p><a id="more"></a><blockquote><p>命令行界面（英语：Command-line Interface，缩写：CLI）是在图形用户界面得到普及之前使用最为广泛的用户界面，它通常不支持鼠标，用户通过键盘输入指令，计算机接收到指令后，予以执行。</p><p>—— 摘自 <a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" target="_blank" rel="noopener">Wikipedia</a></p></blockquote><p>相信大家对于影视作品中出现的那种，某黑客/程序员/安全专家坐在电脑前猛敲键盘、屏幕上放眼望去全是滚动的字符的场景不会感到陌生。这种靠一行行命令的输入输出进行交互的用户界面，就叫做命令行界面。</p><p><img src="https://img.blessing.studio/images/2018/08/24/the_matrix_screenshot.jpg" alt="the_matrix_screenshot"></p><p><em>▲ 电影「黑客帝国」剧照</em></p><p>在图形用户界面 (GUI) 已经完全普及的今天，普通用户在日常使用电脑的过程中几乎不用手动输入任何命令，大部分操作都是点点鼠标就能完成，而熟练使用命令行操作似乎已经成为高逼格的代名词。</p><p>但事实上，现在依然有着很多的软件开发者、系统管理员，或者是高级用户在使用命令行界面操作计算机。其中很大一个原因，就是效率：在熟记命令的前提下，使用命令行界面往往要比使用图形用户界面来得快。</p><p>举个栗子，我要把当前目录下的（包括嵌套的子目录）所有 <code>*.tpl</code> 文件的后缀名修改为 <code>*.blade.php</code>，如果不使用命令行，该怎么做？手动修改肯定不至于，但也得去网上找找相关软件，得要注意下载来源是否靠谱（像我这样有点洁癖的选手还得去找绿色版），下载后还要手动指定文件路径、重命名模板……</p><p>而使用命令行的话（这里以 Ubuntu 上的 Bash 为例），只需运行这么一句：</p><pre><code class="shell">rename &#39;s/\.tpl$/\.blade.php/&#39; ./**/*.tpl</code></pre><p>命令行操作的高效率等优点，也是现在许多图形化的计算机系统依然没有放弃提供命令行操作方式的原因。就连 Windows 都有自带 <code>cmd.exe</code> 和 PowerShell 等命令行程序（事实上你在搜索「批量重命名」时，可以看到很多方案都是通过「Windows 命令提示符」实现的）。</p><h2 id="2-终端-——-人与机器交互的接口"><a href="#2-终端-——-人与机器交互的接口" class="headerlink" title="2. 终端 —— 人与机器交互的接口"></a>2. 终端 —— 人与机器交互的接口</h2><p>终端 (Terminal)，其词汇本身的意义为「终点站；末端；（电路）的端子，线接头」。而在计算机领域，终端则是一种用来让用户输入数据至计算机，以及显示其计算结果的机器。</p><p>也就是说，终端只是一种用于与计算机进行交互的输入输出设备，其本身并不提供运算处理功能。</p><p>想要充分理解终端，我们得回溯历史，去看看终端的起源。</p><h3 id="2-1-历史上的终端"><a href="#2-1-历史上的终端" class="headerlink" title="2.1 历史上的终端"></a>2.1 历史上的终端</h3><p>在大型机 (Mainframe) 和小型机 (Minicomputer) 的时代里，计算机曾经非常昂贵且巨大，不像现在这样人手一台。这些笨重的计算机通常被安置在单独的房间内，而操作计算机的人们坐在另外的房间里，通过某些设备与计算机进行交互。这种设备就叫做 <strong>终端</strong> (Terminal)，也叫终端机。</p><p><img src="https://img.blessing.studio/images/2018/08/22/ASR-33_2.jpg" alt="ASR-33"></p><p><em>▲ ASR-33 电传打字机（图片来源：<a href="https://www.flickr.com/photos/8399025@N07/2283401196/" target="_blank" rel="noopener">Flickr - Marcin Wichary</a>，CC-BY-2.0）</em></p><p>早期的终端一般是一种叫做 <strong>电传打字机</strong> (Teletype) 的设备。为啥呢？因为 Unix 的创始人 Ken Thompson 和 Dennis Ritchie 想让 Unix 成为一个多用户系统。多用户系统就意味着要给每个用户配置一个终端，每个用户都要有一个显示器、一个键盘。但当时所有的计算机设备都非常昂贵（包括显示器），而且键盘和主机是集成在一起的，根本没有独立的键盘。</p><p>后来他们机智地找到了一样东西，那就是 <a href="https://en.wikipedia.org/wiki/Teletype_Model_33" target="_blank" rel="noopener">ASR-33 电传打字机</a>。虽然电传打字机原本的用途是在电报线路上收发电报，但是它既有可以发送信号的键盘，又能把接收到的信号打印在纸带上，完全可以作为人机交互设备使用。</p><p>而且最重要的是，价格低廉。:P</p><p>于是，他们把很多台 ASR-33 连接到计算机上，让每个用户都可以在终端登录并操作主机。就这样，他们创造了计算机历史上第一个真正的多用户操作系统 Unix，而电传打字机就成为了第一个 Unix 终端。</p><blockquote><p>想知道用电传打字机做终端是一种怎样的体验？这里有一个 <a href="https://www.youtube.com/watch?v=MikoF6KZjm0" target="_blank" rel="noopener">很炫酷的演示视频</a>。</p></blockquote><h3 id="2-2-控制台-Console-是什么？"><a href="#2-2-控制台-Console-是什么？" class="headerlink" title="2.2. 控制台 (Console) 是什么？"></a>2.2. 控制台 (Console) 是什么？</h3><p>上面我们说过，在历史上，终端是连接到计算机上的一种带输入输出功能的外设。但是有一个终端与众不同，它与计算机主机是一体的，是计算机的一个组成部分。这个特殊的终端就叫做 <strong>控制台</strong> (Console)。</p><p>顾名思义，控制台是用于管理主机的，只能给系统管理员使用，有着比普通终端更大的权限。一台计算机上一般只有一个控制台，但是可以连接很多个终端。</p><p><img src="https://img.blessing.studio/images/2018/08/22/console_and_terminal.jpg" alt="console_and_terminal"></p><p><em>▲ 左边的是 Console，右边的是 Terminal（图片来源：<a href="https://zhuanlan.zhihu.com/p/21895357" target="_blank" rel="noopener">带你逛西雅图活电脑博物馆</a>）</em></p><p>放在现在我们可能难以理解为什么会有控制台和终端的区分，不过就像上一节所说的，当时都是很多个用户通过终端去访问一台计算机，而专门管理那些大块头机器的系统管理员另有其人。普通用户用的就是普通的终端，而系统管理员用的终端比较牛逼，所以就被叫做控制台啦（笑）。</p><p>不过随着个人计算机的普及，控制台 (Console) 与终端 (Terminal) 的概念已经逐渐模糊。在现代，我们的键盘与显示器既可以认为是控制台，也可以认为是普通的终端。当你在管理系统时，它们是控制台；当你在做一般的工作时（浏览网页、编辑文档等），它们就是终端。我们自己既是一般用户，也是系统管理员。</p><p>因此，现在 Console 与 Terminal 基本被看作是同义词。</p><h3 id="2-3-字符终端与图形终端"><a href="#2-3-字符终端与图形终端" class="headerlink" title="2.3 字符终端与图形终端"></a>2.3 字符终端与图形终端</h3><p>终端也有不同的种类。</p><p><strong>字符终端</strong> (Character Terminal) 也叫文本终端 (Text Terminal)，是只能接收和显示文本信息的终端。早期的终端全部是字符终端。字符终端也分为 <strong>哑终端</strong> (Dumb Terminal) 和所谓的 <strong>智能终端</strong> (Intelligent Terminal)，因为后者可以理解转义序列、定位光标和显示位置，比较聪明，而哑终端不行。</p><p><img src="https://img.blessing.studio/images/2018/08/22/DEC_VT100_terminal.jpg" alt="DEC_VT100_terminal"></p><p><em>▲ DEC VT100 终端（图片来源：<a href="https://www.flickr.com/photos/54568729@N00/9636183501" target="_blank" rel="noopener">Flickr - Jason Scott</a>，CC-BY-2.0）</em></p><p>DEC 公司在 1978 年制造的 <a href="https://en.wikipedia.org/wiki/VT100" target="_blank" rel="noopener">VT100</a>，由于其设计良好并且是第一批支持 ANSI 转义序列与光标控制的智能终端，获得了空前的成功。VT100 不仅是史上最流行的字符终端，更是成为了字符终端事实上的标准。</p><p>随着技术的进步，图形终端 (Graphical Terminal) 也开始出现在公众的视野中。图形终端不但可以接收和显示文本信息，也可以显示图形与图像。著名的图形终端有 <a href="https://en.wikipedia.org/wiki/Tektronix_4010" target="_blank" rel="noopener">Tektronix 4010</a> 系列。</p><p>不过现在专门的图形终端已经极为少见，他们基本上已经被全功能显示器所取代。</p><h3 id="2-3-终端模拟器-Terminal-Emulator"><a href="#2-3-终端模拟器-Terminal-Emulator" class="headerlink" title="2.3. 终端模拟器 (Terminal Emulator)"></a>2.3. 终端模拟器 (Terminal Emulator)</h3><p>随着计算机的进化，我们已经见不到专门的终端硬件了，取而代之的则是键盘与显示器。</p><p>但是没有了终端，我们要怎么与那些传统的、不兼容图形接口的命令行程序（比如说 GNU 工具集里的大部分命令）交互呢？这些程序并不能直接读取我们的键盘输入，也没办法把计算结果显示在我们的显示器上……（图形界面的原理我这里就不多说了，它们编程的时候图形接口还在娘胎里呢！）</p><p>这时候我们就需要一个程序来模拟传统终端的行为，即 <strong>终端模拟器</strong> (Terminal Emulator)。</p><blockquote><p>严格来讲，Terminal Emulator 的译名应该是「终端仿真器」。</p></blockquote><p>对于那些命令行 (CLI) 程序，终端模拟器会「假装」成一个传统终端设备；而对于现代的图形接口，终端模拟器会「假装」成一个 GUI 程序。一个终端模拟器的标准工作流程是这样的：</p><ol><li>捕获你的键盘输入；</li><li>将输入发送给命令行程序（程序会认为这是从一个真正的终端设备输入的）；</li><li>拿到命令行程序的输出结果（STDOUT 以及 STDERR）；</li><li>调用图形接口（比如 X11），将输出结果渲染至显示器。</li></ol><p>终端模拟器有很多，这里就举几个经典的例子：</p><ul><li>GNU/Linux：gnome-terminal、Konsole；</li><li>macOS：Terminal.app、iTerm2；</li><li>Windows：<a href="https://zh.wikipedia.org/wiki/Win32%E6%8E%A7%E5%88%B6%E5%8F%B0" target="_blank" rel="noopener">Win32 控制台</a>、ConEmu 等。</li></ul><p><img src="https://img.blessing.studio/images/2018/08/22/my-terminals.png" alt="my-terminals"></p><p><em>▲ 我正在使用的终端模拟器：<a href="https://hyper.is/" target="_blank" rel="noopener">Hyper</a> 与 <a href="https://github.com/goreliu/wsl-terminal" target="_blank" rel="noopener">wsl-terminal</a></em></p><p>在专门的终端硬件已经基本上仅存于计算机博物馆的现代，人们通常图省事儿，直接称呼终端模拟器为「终端」。</p><h3 id="2-4-终端窗口-Terminal-Window-与虚拟控制台-Virtual-Console"><a href="#2-4-终端窗口-Terminal-Window-与虚拟控制台-Virtual-Console" class="headerlink" title="2.4 终端窗口 (Terminal Window) 与虚拟控制台 (Virtual Console)"></a>2.4 终端窗口 (Terminal Window) 与虚拟控制台 (Virtual Console)</h3><p>大部分终端模拟器都是在图形用户界面 (GUI) 中运行的，但是也有例外。</p><p>比如在 GNU/Linux 操作系统中，按下 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F1,F2…F6</kbd> 等组合键可以切换出好几个黑不溜秋的全屏终端界面，而按下 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F7</kbd> 才是切换回图形界面。不过不要被它们唬着了，虽然它们并不运行在图形界面中，但其实它们也是终端模拟器的一种。</p><p><img src="https://img.blessing.studio/images/2018/08/22/KNOPPIX_booting.png" alt="KNOPPIX_booting"></p><p><em>▲ 一个正在显示系统启动信息的虚拟控制台（图片来源：<a href="https://commons.wikimedia.org/wiki/File:KNOPPIX_booting.png" target="_blank" rel="noopener">hacktolive.org</a>，GPLv2）</em></p><p>这些全屏的终端界面与那些运行在 GUI 下的终端模拟器的唯一区别就是它们是 <strong>由操作系统内核直接提供的</strong>。这些由内核直接提供的终端界面被叫做 <a href="https://en.wikipedia.org/wiki/Virtual_console" target="_blank" rel="noopener">虚拟控制台</a> (Virtual Console)，而上面提到的那些运行在图形界面上的终端模拟器则被叫做 <strong>终端窗口</strong> (Terminal Window)。除此之外并没有什么差别。</p><p>当然了，因为终端窗口是跑在图形界面上的，所有如果图形界面宕掉了那它们也就跟着完蛋了。这时候你至少还可以切换到 Virtual Console 去救火，因为它们由内核直接提供，只要系统本身不出问题一般都可用（笑）。</p><h2 id="3-那么-TTY-又是什么？"><a href="#3-那么-TTY-又是什么？" class="headerlink" title="3. 那么 TTY 又是什么？"></a>3. 那么 TTY 又是什么？</h2><p>简单来说，tty 就是终端的统称。</p><p>为什么呢？看了上面的 2.1 节的同学应该知道，最早的 Unix 终端是 ASR-33 电传打字机。而电传打字机 (Teletype / Teletypewriter) 的英文缩写就是 tty，即 tty 这个名称的来源。</p><p>由于 Unix 被设计为一个多用户操作系统，所以人们会在计算机上连接多个终端（在当时，这些终端全都是电传打字机）。Unix 系统为了支持这些电传打字机，就设计了名为 tty 的子系统（没错，因为当时的终端全都是 tty，所以这个系统也被命名为了 tty，就是这么简单粗暴），将具体的硬件设备抽象为操作系统内部位于 <code>/dev/tty*</code> 的设备文件。</p><blockquote><p>为什么要把电传打字机这个硬件设备抽象成「tty 设备」文件呢？有兴趣的同学可以去了解一下 Unix 操作系统中 <em>Everything is a file</em> 的概念。</p></blockquote><p><img src="https://img.blessing.studio/images/2018/08/22/tty_device_files.png" alt="tty_device_files"></p><p><em>▲ 还记得上面我们说过的特殊的终端，也就是通过 <kbd>Ctrl</kbd> + <kbd>Alt</kbd> + <kbd>F1-6</kbd> 呼出的那些虚拟控制台 (Virtual Console) 吗？其对应的就是上图中的 <code>tty1</code> 到 <code>tty6</code>。</em></p><p>随着计算机的发展，终端设备已经不再限制于电传打字机，但是 tty 这个名称还是就这么留了下来。久而久之，它们的概念就混淆在了一起。所以在现代，tty 设备就是终端设备，终端设备就是 tty 设备，无需区分。</p><blockquote><p>由于早期计算机上的 <a href="https://en.wikipedia.org/wiki/Serial_port" target="_blank" rel="noopener">串行端口 (Serial Port)</a> 最大的用途就是连接终端设备，所以当时的 Unix 会把串口上的设备也同样抽象为 tty 设备（位于 <code>/dev/ttyS*</code>）。因此，现在人们也经常将串口设备称呼为 tty 设备。</p></blockquote><p>在 tty 子系统中后来还衍生出了 pty、ptmx、pts 等概念，这里就不详细展开了。有兴趣的同学可以参考一下这篇文章：<a href="https://segmentfault.com/a/1190000009082089" target="_blank" rel="noopener">Linux TTY/PTS 概述</a>。</p><h2 id="4-Shell-——-提供用户界面的程序"><a href="#4-Shell-——-提供用户界面的程序" class="headerlink" title="4. Shell —— 提供用户界面的程序"></a>4. Shell —— 提供用户界面的程序</h2><p>大家都知道，操作系统有一个叫做 <strong>内核</strong> (Kernel) 的东西，它管理着整台计算机的硬件，是现代操作系统中最基本的部分。但是，内核处于系统的底层，是不能让普通用户随意操作的，不然一个不小心系统就崩溃啦！</p><p>但我们总还是要让用户操作系统的，怎么办呢？这就需要一个专门的程序，它接受用户输入的命令，然后帮我们与内核沟通，最后让内核完成我们的任务。这个提供用户界面的程序被叫做 <strong>Shell</strong> (壳层)。</p><blockquote><p>其实 Shell 只是提供了一个用户操作系统的入口，我们一般是通过 Shell 去调用其他各种各样的应用程序，最后来达成我们的目的。比如说我们想要知道一个文件的内容，我们会在 Shell 中输入命令 <code>cat foo.txt</code>，然后 Shell 会帮我们运行 <code>cat</code> 这个程序，<code>cat</code> 再去调用内核提供的 <code>open</code> 等系统调用来获取文件的内容。虽然并不是 Shell 直接去与内核交互，但广义上可以认为是 Shell 提供了与内核交互的用户界面。</p></blockquote><p>至于为什么叫做 Shell，看下图就知道啦。是不是很像一层壳呢？</p><p><img src="https://img.blessing.studio/images/2018/08/23/computer_system.png" alt="computer_system"></p><p>Shell 通常可以分为两种：<strong>命令行 Shell</strong> 与 <strong>图形 Shell</strong>。顾名思义，前者提供一个命令行界面 (CLI)，后者提供一个图形用户界面 (GUI)。Windows 下的 <code>explorer.exe</code> 就是一个典型的图形 Shell（没错，它确实是，因为它接受来自你的指令，并且会帮你与内核交互完成你的指令）。</p><p>常见或历史上知名的命令行 Shell 有：</p><ul><li>适用于 Unix 及类 Unix 系统：<ul><li><strong>sh</strong> (Bourne shell)，最经典的 Unix shell；</li><li><strong>bash</strong> (Bourne-Again shell)，目前绝大多数 Linux 发行版的默认 shell；</li><li><strong>zsh</strong> (Z shell)，我个人最喜欢的 shell；</li><li><strong>fish</strong> (Friendly interactive shell)，专注于易用性与友好用户体验的 shell；</li></ul></li><li>Windows 下的 <strong>cmd.exe</strong> (命令提示符) 与 <strong>PowerShell</strong>。</li></ul><p>还有其他各种五花八门的 Shell 程序，这里就不一一列举了，有兴趣的自己去搜一搜吧。:P</p><h2 id="5-Shell-与终端的分工"><a href="#5-Shell-与终端的分工" class="headerlink" title="5. Shell 与终端的分工"></a>5. Shell 与终端的分工</h2><p>现在我们知道，终端干的活儿是从用户这里接收输入（键盘、鼠标等输入设备），扔给 Shell，然后把 Shell 返回的结果展示给用户（比如通过显示器）。而 Shell 干的活儿是从终端那里拿到用户输入的命令，解析后交给操作系统内核去执行，并把执行结果返回给终端。</p><p>不过 Shell 与终端的分工有一些容易混淆的地方，这里以例子进行说明：</p><ul><li>终端将用户的键盘输入转换为控制序列（除了字符以外的按键，比如 <code>左方向键</code> → <code>^[[D</code>），Shell 则解析并执行收到的控制序列（比如 <code>^[[D</code> → <code>将光标向左移动</code>）；</li><li>不过也有例外，比如终端在接收到 <kbd>Ctrl</kbd> + <kbd>C</kbd> 组合键时，不会把这个按键转发给当前的程序，而是会发送一个 <code>SIGINT</code> 信号（默认情况下，这会导致进程终止）。其他类似的特殊组合键有 <kbd>Ctrl-Z</kbd> 与 <kbd>Ctrl-\</kbd> 等，可以通过 <code>stty -a</code> 命令查看当前终端的设置。</li></ul><p><img src="https://img.blessing.studio/images/2018/08/22/shell_control_sequences.png" alt="shell_control_sequences"></p><ul><li>Shell 发出类似「把前景色改为红色（控制序列为 <code>\033[31m</code>）」「显示 <code>foo</code>」等指令；</li><li>终端接收这些指令，并且照着 Shell 说的做，于是你就看到了终端上输出了一行红色的 <code>foo</code>。</li></ul><p><img src="https://img.blessing.studio/images/2018/08/22/terminal_control_sequences.png" alt="terminal_control_sequences"></p><ul><li>除非被重定向，否则 Shell 永远不会知道它所执行命令的输出结果。我们可以在终端窗口中上下翻页查看过去的输出内容，这完全是终端提供的 feature，与 Shell 没有半毛钱关系；</li><li>命令提示符 (Prompt) 是一个完全的 Shell 概念，与终端无关；</li><li>行编辑、输入历史与自动补全等功能是由 Shell 提供的（比如 fish 这个 Shell 就有着很好用的历史命令与命令自动补全功能）。不过终端也能自己实现这些功能，比如说 XShell 这个终端模拟器就可以在本地写完一行命令，然后整条发送给远程服务器中的 Shell（在连接状况不佳时很有用，不然打个字都要卡半天）；</li><li>终端中的复制粘贴功能（<kbd>Shift</kbd> + <kbd>Insert</kbd> 或者鼠标右键等）基本上都是由终端提供的。举个例子，Windows 默认的终端对于复制粘贴的支持很屎，而换一个终端（例如 <code>ConEmu</code>）后就可以很好地支持复制粘贴。不过 Shell 以及其他命令行程序也可以提供自己的复制粘贴机制（例如 vim）。</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>计算机史这玩意，有趣是挺有趣的，就是查起资料来太费脑子。</p><p>为了不误人子弟，在这篇博文写作的过程中我也查阅了各种各样的文档和史料，力求内容的准确性。不过能力所限，如果文章中仍有出现谬误，欢迎在下方评论区批评指正。</p><h2 id="7-参考链接"><a href="#7-参考链接" class="headerlink" title="7. 参考链接"></a>7. 参考链接</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%95%8C%E9%9D%A2" target="_blank" rel="noopener">命令行界面 - Wikipedia</a></li><li><a href="https://unix.stackexchange.com/questions/4126/what-is-the-exact-difference-between-a-terminal-a-shell-a-tty-and-a-con" target="_blank" rel="noopener">What is the exact difference between a ‘terminal’, a ‘shell’, a ‘tty’ and a ‘console’?</a></li><li><a href="https://askubuntu.com/questions/14284/why-is-a-virtual-terminal-virtual-and-what-why-where-is-the-real-terminal" target="_blank" rel="noopener">Why is a virtual terminal “virtual”, and what/why/where is the “real” terminal?</a></li><li><a href="https://www.zhihu.com/question/21711307/answer/118788917" target="_blank" rel="noopener">终端，Shell，“tty” 和控制台（console）有什么区别？ - 知乎</a></li><li><a href="https://www.linuxdashen.com/%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%88%E7%AB%AF%E5%90%97%EF%BC%9F" target="_blank" rel="noopener">你真的知道什么是终端吗？ - Linux 大神博客</a></li><li><a href="https://zh.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF" target="_blank" rel="noopener">终端 - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Terminal_emulator" target="_blank" rel="noopener">Terminal emulator - Wikipedia</a></li><li><a href="https://linux.die.net/man/4/console" target="_blank" rel="noopener">console(4): console terminal/virtual consoles - Linux man page</a></li><li><a href="https://segmentfault.com/a/1190000009082089" target="_blank" rel="noopener">Linux TTY/PTS 概述 - SegmentFault</a></li><li><a href="http://www.wowotech.net/tty_framework/tty_concept.html" target="_blank" rel="noopener">Linux TTY framework(1)_基本概念</a></li><li><a href="https://en.wikipedia.org/wiki/Shell_%28computing%29" target="_blank" rel="noopener">Shell (computing) - Wikipedia</a></li><li><a href="http://cn.linux.vbird.org/linux_basic/0320bash.php" target="_blank" rel="noopener">学习 bash shell - 鸟哥的 Linux 私房菜</a></li><li><a href="http://manpages.ubuntu.com/manpages/cosmic/zh_CN/man4/console_codes.4.html" target="_blank" rel="noopener">Ubuntu Manpage: 控制终端代码 - Linux 控制终端转义和控制序列</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;诸君，好久不见。&lt;/p&gt;
&lt;p&gt;为什么突然想写这样一篇文章呢？其实是因为在最近计划发布的一篇关于 WSL (Windows Subsystem for Linux) 的博文中，我打算对终端模拟器、Shell 的选择与配置进行一些说明。不过对于刚接触 Linux 或者刚接触命令行界面的同学，可能会有些难以理解它们之间的区别（事实上我当初也是这样）。&lt;/p&gt;
&lt;p&gt;虽然这个话题已是老生常谈，搜索一下应该也能找到大把的相关文章。不过难得提到了这方面，就趁此机会把我的理解写下来，一来看看我是不是真正理解了，二来看看我能不能把它们之间的区别讲得更加简明易懂。&lt;/p&gt;
&lt;h2 id=&quot;0-太长不看-TL-DR&quot;&gt;&lt;a href=&quot;#0-太长不看-TL-DR&quot; class=&quot;headerlink&quot; title=&quot;0. 太长不看 TL;DR&quot;&gt;&lt;/a&gt;0. 太长不看 TL;DR&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;命令行界面&lt;/strong&gt; (CLI) = 使用文本命令进行交互的用户界面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;终端&lt;/strong&gt; (Terminal) = &lt;strong&gt;TTY&lt;/strong&gt; = 文本输入/输出环境&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制台&lt;/strong&gt; (Console) = 一种特殊的终端&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Shell&lt;/strong&gt; = 命令行解释器，执行用户输入的命令并返回结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-什么是命令行界面？&quot;&gt;&lt;a href=&quot;#1-什么是命令行界面？&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是命令行界面？&quot;&gt;&lt;/a&gt;1. 什么是命令行界面？&lt;/h2&gt;&lt;p&gt;命令行界面，通俗来讲，就是你看过的那种满屏幕都是字符的界面。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="Shell" scheme="https://blessing.studio/tag/Shell/"/>
    
      <category term="CLI" scheme="https://blessing.studio/tag/CLI/"/>
    
      <category term="科普" scheme="https://blessing.studio/tag/%E7%A7%91%E6%99%AE/"/>
    
  </entry>
  
  <entry>
    <title>近况报告：我的高复生活</title>
    <link href="https://blessing.studio/check-in-2018-07/"/>
    <id>https://blessing.studio/check-in-2018-07/</id>
    <published>2018-07-21T11:50:00.000Z</published>
    <updated>2018-11-03T17:37:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>好久不见。</p><p>当你正在阅读这篇文章时，你应该很难想象，一位半年多没有写过博客的老鸽是以怎样复杂的心情打出这些文字的。由于我实在是太久没有正经写过文章了，对文字的感觉也未免生疏，所以这篇近况报告可能会写得像流水账一样又臭又长。你就把本文想象成是一位老年人博主重拾博客更新前的康复训练，以温暖的目光看下去吧。</p><h2 id="我为什么这么久没写博客了？"><a href="#我为什么这么久没写博客了？" class="headerlink" title="我为什么这么久没写博客了？"></a>我为什么这么久没写博客了？</h2><p>为什么？因为忙啊，不然还能是为什么。（笑）</p><p>不过不得不承认，我这一年更新博客的频率确实是低到史无前例：2018 年到现在，我只发布过 2 篇博文，这个数据是 2017 年的十分之一。为什么呢？有看过我前几篇博文的朋友应该都知道，我在去年的高考中没有取得理想的成绩，在一番权衡后，我选择了高考复读这一条道路。</p><p>高考复读，也就是再读一年高三，再经历一次高考。</p><a id="more"></a><p>后来我去了一所位于杭州的高复专门学校，这也就意味着除了少有的假期外我将不再有碰到电脑的机会，博客更新更是无从谈起。忙里偷闲写几篇水文自然是可以的，可惜我好死不死就有那么点完美主义。</p><p>我写起博客来算是比较花时间的那种，一篇博文发布之前要一般要花上几天打草稿、润色、排版，如果是技术文章还需要添加参考链接、翻源码考证，最后还要根据在博客上的最终渲染效果进行微调……诸如此类，力求最后的效果能让我自己满意。这样的追求不可避免地造成博客更新频率低下（这点我并不是很在意），而更关键的是在没有合适环境的情况下（比如说我在杭州的那一段时间，手头没有电脑，没有 Hexo 需要的那一套环境，我也没法在其他人都在打游戏的网吧里慢悠悠地打字……），我很难写出一篇满意的博文。</p><p>结果就是，虽然我在高考复读期间在手机上写了不少草稿（这里推荐一下<a href="https://play.google.com/store/apps/details?id=com.drakeet.purewriter" target="_blank" rel="noopener">「纯纯写作」</a>这个 Android 应用，特别好用），但是这些草稿没有一篇能够最终变成一篇博文，很遗憾。</p><p>既然高复生活是如此的不便，那我为什么还是选择了这条道路呢？</p><h2 id="我为什么选择高考复读？"><a href="#我为什么选择高考复读？" class="headerlink" title="我为什么选择高考复读？"></a>我为什么选择高考复读？</h2><p>我猜现在正在阅读这篇文章的大部分人都是不了解浙江新高考这一套的，所以为了让各位看官不至于懵逼，我这里先给出点背景设定：</p><ul><li>浙江是高考改革的第一批试点省份，而且新高考正好从我们那一届开始施行；</li><li>新高考不再有 <em>文科</em> 和 <em>理科</em> 的区别，分数线都是统一的；</li><li>新高考采用了「七选三」的模式，考生需要从 <em>政史地物化生</em> 以及 <em>技术</em> 这七门科目中选择三门作为 <strong>选考科目</strong>（计入高考总分），其他的科目不计入高考总分（但是也有要求）；</li><li>除语数英外的选考科目均采用根据名次给分的「赋分制」，而不是考出来的实际分数；</li><li>针对选考科目的统一考试（成绩计入高考总分，下面简称 <strong>选考</strong>）、针对其他科目的考试（下面简称 <strong>学考</strong>）以及外语科目的考试 <strong>最多可以考两次</strong>；</li><li>外语以及选考的考试成绩 <strong>保留两年</strong>，取最高的分数作为最终分数（你可以想象成是「把传统高考的除了语数英外的其他科目都抽出来在六月份之前考掉，而且可以考两次」，这在一定程度上缓解了传统高考「一考定终生」的问题）；</li><li>在志愿填报方面，实行「专业平行志愿」。不同于传统的「先选学校，再从学校里选专业，还要选择是否服从调剂」，新高考的志愿填报是以「一个院校中的一个专业」为单位的，而且 <strong>至多可以填 80 个志愿</strong>；</li><li>实行分段录取，所有考生按照总分位次划分为一段、二段、三段，一段考生最先填报志愿，等一段的都录取结束后，二段考生再开始填志愿、录取（捡上一段剩下的），以此类推；</li><li>取消录取批次，通俗来讲，就是一本线上的考生也可以直接报考传统的二本、三本院校了。</li></ul><p>设定很多，看起来很晕，是不是？</p><p>没错，我们也是这么想的。</p><p>作为新高考第一届的小白鼠，政策变动这么大，要说心里不慌肯定是假的。而且这个新政策里不完善、甚至比传统高考更差劲的地方也有很多（比如说高一刚进来要同时学十门科目，说是减负其实是增负，如果想要走三位一体或者自主招生的话学考也必须拿到高分，选考物理的学生大量减少导致物理赋高分的难度陡增，等等等等），如果真要吐槽的话都可以另外写一篇长文了，所以这里就按下不表。</p><p>估计大家光看上面那些文字并没有什么实感，那我这里就回忆一下我当时的经历，让大家感同身受一下。</p><h3 id="我当时的情况"><a href="#我当时的情况" class="headerlink" title="我当时的情况"></a>我当时的情况</h3><p>我在原来的高中时的经历我就不多描述了，概括起来就是一句话：</p><p><del>「或许是因为摸鱼过度，不慎追尾了……」</del></p><p>啊，不对。</p><p>「因为摸鱼过度，最后高考总分只有 538 分。」</p><p>这个分数具体意味着什么呢？我稍微分析一下：</p><ul><li>2017 年的浙江高考一段线是 577 分，总分 750；</li><li>538 分也就是被划分到二段，一段考生填完志愿、录取完毕后才轮到我们填志愿；</li><li>一本肯定是别想了，<strong>早被一段考生填光了</strong>；</li><li>二本的好学校也是别想了。记得我上面说过的「取消录取批次」吗？好一点的二本院校以及专业都已经被那些一段线低空飞过的人填掉了，<strong>二段考生根本抢不过</strong>；</li><li>2017 年投档分数普遍偏高，而且又是新高考第一年，往年的录取数据全都派不上用场，大家都是摸着石头过河，导致大量一段考生「滑档」（未能被志愿中的学校录取导致退档，详情可以了解一下去年上过微博热搜榜的「浙江滑档大学」）；</li><li>结果就是大量高分选手跑来和我们这些菜鸡一起填二段的志愿，我怎么抢得过他们？</li><li>剩下给我的只有普通的二本、三本，还有专科。</li></ul><p>就是这么个绝望的情况。</p><p>当然，这一切都是我咎由自取，怪不了别人。如果我分数高一点，那就屁事没有了。</p><p>不过说实话，我并不后悔。当时我是这么想的，现在我也是这么想的。</p><p>高中三年我过得非常开心，如今回想起来全是美好的回忆。白天在学校和同学聊天打屁嘻嘻哈哈，上课摸鱼玩手机开小差，一天到晚和老师斗智斗勇，下课吃饭了跑得比谁都快，回家了就上网冲浪和傻屌群友一起吹水，晚上写代码写博客熬夜看动画片，白天靠同桌望风在自习课上爆睡，快到考试了就大家一起临时抱佛脚……</p><p>我失去了不少，但我也得到了很多。</p><p>我所得到的，是今后的人生中可能都无法再遇见的。</p><p>我自认为度过了丰富多彩的高中生活，我很满意。</p><p>这就够了。</p><p><img src="https://img.blessing.studio/images/2018/07/21/IMG_20170605_150610_L.jpg" alt="我的母校，摄于 2017 毕业前"></p><h3 id="高考复读的好处"><a href="#高考复读的好处" class="headerlink" title="高考复读的好处"></a>高考复读的好处</h3><p>感觉有点感伤的气氛，所以把话题拉回来。</p><p>虽说我对于我的高中生活并没有什么后悔，但是我对于我的高考成绩还是感到相当不甘心的。我一个小升初、初升高全部靠着实打实的成绩考上名校的选手，难道他妈的最后还落得个读二本大学的下场？</p><p>我不甘心。</p><p>所以我选择再挑战一次高考。很简单的道理，是不是？</p><p>当然我也不是脑子一热就做出高复的决定的，事实上新高考的政策对于复读考生确实非常有利。如果你忘记了我上面提到的那一大坨高考改革的内容，那我这里就再帮你复习一下：</p><ul><li>选考科目以及外语科目可以考两次，<strong>成绩两年内有效</strong>；</li><li>每科目最多只能保留两个成绩，<strong>取最高的分数作为最终分数</strong>。</li></ul><p>察觉到了吗？</p><p>在我高中三年中，我的选考科目的两次考试分别是在 <em>2016 年 10 月</em>，以及 <em>2017 年 4 月</em> 进行的。那么我在这两次考试中取得的分数，分别可以保留至 <em>2018 年 10 月</em> 以及 <em>2019 年 4 月</em>。而我如果高复一年，也就是在 <em>2018 年 6 月</em> 计算高考总分的话，那么我在高中时的成绩是 <strong>全部有效</strong> 的。</p><p>也就是说，就算我高复这一年考得再他妈怎么屌差，也有之前的分数给我兜底。</p><p>这样一来，传统高考下「万一再考一次结果比去年考得还差怎么办？」的顾虑也将不复存在。虽然语文、数学两门科目依然还是像之前一样只能考一次，但是光是<strong>「其他科目都有去年分数保底」</strong>这一点，对于高复选手来说就已经是非常大的福利了。</p><p>而且，相比于去年大家填志愿都是摸着石头过河的情况（录取模式大改，往年的录取数据基本上没有任何参考价值），如果我高复一年再填志愿的话，有了 2017 年的录取数据填志愿也方便不少。</p><p>如此看来，选择高考复读，除了一年的时间外，似乎并没有什么损失。</p><p>所以我当下拍板（我在这方面似乎都很果断），直接放弃填志愿，选中了杭州的一所高复专门学校，七月份去咨询，八月份就去上课，一气呵成，是复读选手中的豪杰（不）。</p><p><img src="https://img.blessing.studio/images/2018/07/21/IMG_20170812_103824_FILTERED_L.jpg" alt="前往杭州"></p><h2 id="我的高复生活"><a href="#我的高复生活" class="headerlink" title="我的高复生活"></a>我的高复生活</h2><p>其实关于高复生活的文章应该在我还在高复的时候写才对，毕竟人总是会情不自禁地美化过去的记忆。比如说现在我坐在家里写这篇文章，回想我的高复生活时，竟然一时间找不到什么让人想要破口大骂的地方，真是奇妙。</p><h3 id="关于杭州"><a href="#关于杭州" class="headerlink" title="关于杭州"></a>关于杭州</h3><p>在我原来所在的城市里也有一所专门的高复学校，但是我还是选择了孤身一人前往杭州。为啥呢？兴许是我不放心小城市里高复学校的办学质量，也有可能单纯只是因为我想出来见见世面。</p><p>结果确实是好的，杭州的繁华超出了我这个四线城市居民的想象。</p><p>首先让我感到惊讶的是 O2O 与移动支付的普及。</p><p>虽然现在在四线城市也基本可以做到不带现金出门，不过要论完成度，比起大城市果然还是要逊色一筹。走在杭州的路上，随处可见各大 O2O 平台的骑手穿着五颜六色的冲锋衣来回穿梭，不管在哪里拿起手机附近都有打车平台的司机在准备接客，街边一排排的共享单车交个押金就能骑走，令人眼花缭乱的公交线路也有人维护实时公交数据，乘公交坐地铁也只需要扫个码或者 NFC，周末窝在寝室、方圆几公里的午餐随叫随到……</p><p>这些都是我在四线城市未曾体验过的。</p><p>其次是空气质量。</p><p>虽然我早有准备，不过对于一个在四线城市每天看着蓝天白云长大的选手，杭州的空气质量确实经常令我惊讶（虽然相比起来杭州已经算好的了）。</p><p>其他好像也没什么令我特别印象深刻的东西。</p><p>真要说的话，就是「举目四望全是高楼大厦，挺无聊的」这一点吧。</p><p><img src="https://img.blessing.studio/images/2018/07/21/IMG_20170824_105840_L.jpg" alt="杭州的天空"></p><h3 id="关于校规"><a href="#关于校规" class="headerlink" title="关于校规"></a>关于校规</h3><p>毕竟是高复学校，校规还是蛮严格的，除单休日外不准出校门、不准带手机这种都是基本操作。不过除了这些以外也并没有其他特别傻逼的规定，不用穿校服，发型也不像我原来的高中那样不允许留长，总体来说好像也蛮宽松的（迫真前后矛盾）。而且上有政策，下有对策：不许带手机，那就私藏；不许出校门，那就找借口溜出去。（笑）</p><h3 id="人际关系"><a href="#人际关系" class="headerlink" title="人际关系"></a>人际关系</h3><p>一言以蔽之：现充。</p><p>……</p><p>……</p><p>……</p><p><img src="https://img.blessing.studio/images/2018/07/21/-501d1e8255079ef0.jpg" alt="表情图"></p><p>好吧不开玩笑了。</p><p>不过我本来也不是那种特别不擅长交流的人，和同学打好关系对我来说并不算困难，和高中三年一样，高复这一年我和班上的同学、同寝的几位老哥关系都很好。唯一让我耿耿于怀的，就是刚入冬时我穿了件毛呢大衣去教室（当时正好梳着背头），被人叫做「X 总」结果外号彻底定型这件事。（笑）</p><h3 id="和原学校对比"><a href="#和原学校对比" class="headerlink" title="和原学校对比"></a>和原学校对比</h3><p>毕竟是高复专门学校，比起我原来就读的重点高中，环境、基础设施等方面自然都是无法同台竞技的。不过好也好在这是高复专门学校，大家来到这里都有着明确的目标，而且也只会在这里待上一年，所以像是食堂特别难吃啊、小卖部特别贵啊、学校特别小、教室寝室特别破烂之类的缺点似乎也变得不是那么难以接受……</p><p>才怪嘞！</p><p>为了逃离学校食堂那有够难吃的饭菜，我买了不少代餐的东西，像是肉松饼小蛋糕、速食乌冬速食粥之类的，都够我写一篇「宿舍代餐小食推荐」了。而且不清楚是高复期间吃得不好，还是学习压力太大（虽然我感觉应该不是这个原因，我天天摸鱼哪来的压力），我这一年整整瘦了二十多斤……</p><p>算是减肥大成功？🤔</p><h3 id="生活规律"><a href="#生活规律" class="headerlink" title="生活规律"></a>生活规律</h3><p>三点一线。</p><p>教室，食堂，寝室。</p><p>除了单休日外基本没去过其他地方，连我自己都难以置信。</p><h3 id="关于学习"><a href="#关于学习" class="headerlink" title="关于学习"></a>关于学习</h3><p>我从来不是一个热衷于应付应试教育的人，现在也是如此。</p><p>但是有了明确的目标，就算不愿意我也还是会努力的。</p><p>我在决定去高复时为自己定下的目标就是「考上一所差不多一点的一本院校」。</p><p>为啥呢？说句有点自大的话，我并不看重大学的专业课水平。相比起来，我更看重大学的牌子是否响当、地理区位、周边交通是否便利、图书馆寝室食堂等基础设施是否完善，诸如此类。也就是说，我选择大学时更看重的是这所大学是否能为我提供一个 <strong>良好的自学环境</strong>。</p><p>当然，我并不是说大学里专业课没什么用。就拿计算机专业举例，很多大学的计算机专业全国排名前几，很牛逼，但是他们牛逼的那一方面可能并不是我以后需要的。比如说某某大学搞算法很牛逼，某某大学搞人工智能很牛逼，但是说不定我以后出去就是个天天写 CRUD 的底层 PHP 码农呢？又或者我可能是个天天和用户打交道、按着设计稿撸界面的前端呢？</p><p>所以，我并不是说这些大学的牛逼专业课没有用，只是我以后可能不走这个方向而已。而微机原理、数据结构与算法这些底层的知识，各大院校的 CS 专业可能都不会差到哪里去。</p><p>那么我比起专业课实力更看重大学整体的环境，是不是也不那么难理解了呢？</p><p>拉回正题。</p><p>如果要用一句话概括我这一年的高复生活的话，那就是「敬业与摸鱼并存」。经常看我 Twitter 的朋友应该都知道，我在高复这一年基本上就没交过手机，所以从我发的推文基本上就能推测出我是在摸鱼还是在敬业。</p><p>比如说这样的就是在敬业：</p><p><img src="https://img.blessing.studio/images/2018/11/04/tweets-about-study-snapshot.png" alt="敬业截图"></p><p><strong>其他时间都是在摸鱼。</strong>（确实是这样）（笑）</p><p>嘛，玩笑先放在一边。总的来说，高复这一年里我在学习和娱乐两者上的时间分配还是比较均衡的，没有让自己学成个书呆子或者让自己压力太大做出什么不对劲的事，成绩也有在稳步提升、没有重蹈覆辙。</p><p>当然，也是因为这一切全都已经过去了我才能说得这么轻松。就像我上面说的，人总是会情不自禁地美化过去的记忆。不论当初有多么辛苦多么难受，现在回头来看，似乎也并没有什么大不了，可是当初的痛苦却又是实打实的。</p><p>不过总是回首过去也没什么意思，只要结果好那就一切都好。</p><p>我是这么想的。</p><h2 id="所以说我今年考得怎么样？"><a href="#所以说我今年考得怎么样？" class="headerlink" title="所以说我今年考得怎么样？"></a>所以说我今年考得怎么样？</h2><p>三言两语聊完了我的高三和高四，那么现在的我又怎么样呢？</p><p>正如各位所猜测的，我在今年的高考中确实是取得了一个还不错的成绩，不然我也不会有余裕在这里慢悠悠地和你们讲述我过去的事情啦。</p><p>今年浙江的一段线不出预料地再次上涨，由去年的 577 分涨到了今年的 588 分，引来考生一片哀号。不过好在我这次语文数学考得比较给力，再加上英语 140+ 的高分弥补了其他科目的瘸腿，最后还是取得了总分 610+ 的成绩，成功被【数据删除】录取，可喜可贺。</p><p>另外这里不得不表扬一下新高考的 <strong>专业平行志愿</strong> 填报制度，比起传统的志愿填报不知道高到哪里去了。可以直接填写院校 + 专业，而且不用担心被调剂到自己不喜欢的专业去，对于我这种专业意向明确的学生太有利了。总共 80 个志愿，我这次报了十来个全是计算机系，爽死。</p><h2 id="今后打算怎么办？"><a href="#今后打算怎么办？" class="headerlink" title="今后打算怎么办？"></a>今后打算怎么办？</h2><p>总之先打算重新开始更新博客，把手头的一些草稿以及想要写的东西都写好、发出来。之前因为录取结果一直没出来，心里没底，所以没什么更新博客的积极性。现在录取结果出来了，心里的大石头也算落地了，是时候回归我敬业博主的本质了。（嗯？）</p><p>至于更长远的计划嘛，走一步算一步吧。</p><p>精彩的大学生活才刚刚开始呢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好久不见。&lt;/p&gt;
&lt;p&gt;当你正在阅读这篇文章时，你应该很难想象，一位半年多没有写过博客的老鸽是以怎样复杂的心情打出这些文字的。由于我实在是太久没有正经写过文章了，对文字的感觉也未免生疏，所以这篇近况报告可能会写得像流水账一样又臭又长。你就把本文想象成是一位老年人博主重拾博客更新前的康复训练，以温暖的目光看下去吧。&lt;/p&gt;
&lt;h2 id=&quot;我为什么这么久没写博客了？&quot;&gt;&lt;a href=&quot;#我为什么这么久没写博客了？&quot; class=&quot;headerlink&quot; title=&quot;我为什么这么久没写博客了？&quot;&gt;&lt;/a&gt;我为什么这么久没写博客了？&lt;/h2&gt;&lt;p&gt;为什么？因为忙啊，不然还能是为什么。（笑）&lt;/p&gt;
&lt;p&gt;不过不得不承认，我这一年更新博客的频率确实是低到史无前例：2018 年到现在，我只发布过 2 篇博文，这个数据是 2017 年的十分之一。为什么呢？有看过我前几篇博文的朋友应该都知道，我在去年的高考中没有取得理想的成绩，在一番权衡后，我选择了高考复读这一条道路。&lt;/p&gt;
&lt;p&gt;高考复读，也就是再读一年高三，再经历一次高考。&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="https://blessing.studio/categories/diary/"/>
    
    
      <category term="水" scheme="https://blessing.studio/tag/%E6%B0%B4/"/>
    
      <category term="近况报告" scheme="https://blessing.studio/tag/%E8%BF%91%E5%86%B5%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>如何将现有 git 仓库中的子目录分离为独立仓库并保留其提交历史</title>
    <link href="https://blessing.studio/splitting-a-subfolder-out-into-a-new-git-repository/"/>
    <id>https://blessing.studio/splitting-a-subfolder-out-into-a-new-git-repository/</id>
    <published>2018-02-20T11:23:47.000Z</published>
    <updated>2018-02-20T11:23:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>这几天想要把一个 git 仓库中<strong>已经存在</strong>的一个子文件夹独立成一个新的 git 仓库，并且保留之前关于此文件夹的所有提交历史。不过我对 git 并没有这么精通，只好上网搜索之。可能是因为我关键词抓得不准，搜了好一会儿才找到可行的方案，所以写篇博文记录一下，希望能帮到后来人。</p><p>另外，在 git 里这种掌控历史的感觉真棒（笑）</p><h2 id="0x01-需求分析"><a href="#0x01-需求分析" class="headerlink" title="0x01 需求分析"></a>0x01 需求分析</h2><p>我为什么会有如本文标题所述这样的需求呢？这是因为我之前把所有为 <a href="https://github.com/printempw/blessing-skin-server" target="_blank" rel="noopener">Blessing Skin</a> 这个程序编写的插件源码都放在一个 <a href="https://github.com/printempw/blessing-skin-plugins" target="_blank" rel="noopener">git repo</a> 中了，每个子文件夹中都是一个独立的插件（因为嫌麻烦所以一股脑给塞进一个仓库里了），并且对每个子文件夹中的代码的修改最后都是在这个统一仓库中提交的。该仓库差不多长这样：</p><pre><code class="text">$ tree├── .git├── avatar-api├── config-generator├── register-email-validation│   ├── bootstrap.php│   ├── package.json│   └── src├── report-texture└── yggdrasil-api  &lt;---【我想把这个独立为一个新 repo】    ├── bootstrap.php    ├── package.json    ├── routes.php    └── src</code></pre><p>而我现在后悔了，想把其中的某个子目录抽离出来，把它变成一个新的 git 仓库，并且保留我之前所有在「原仓库」中关于这个子目录的「所有提交历史」。</p><p>其实这种需求还是挺常见的，举个栗子：</p><a id="more"></a><blockquote><p>你原本在一个项目的 git 仓库中维护了一个通用的组件库，本来以为这只是个小玩意，谁曾想随着项目的开发这个库变得越来越大，代码变得越来越复杂，不再合适与主项目代码放在同一个 repo 里了。</p><p>这时你想把这个库抽离出来变成一个单独的 git repo 然后在原 repo 中使用 submodule 之类的方法引用之的时候，却发现之前的 repo 中已经有太多关于这个库的提交记录了，而你又不想让这个新 repo 直接一个 Initial Commit 唐突地就变成现在这个样子……</p></blockquote><p>这就是这篇文章所希望解决的需求：</p><p><strong>将现有 git repo 中的子目录独立为新 repo，并保留其相关的提交历史。</strong></p><h2 id="0x02-文章描述约定"><a href="#0x02-文章描述约定" class="headerlink" title="0x02 文章描述约定"></a>0x02 文章描述约定</h2><p>为了方便描述后续操作，这里稍微约定一下文章中各占位符的含义。</p><ul><li>原来的仓库 👉 <code>&lt;big-repo&gt;</code></li><li>想要分离出来的子文件夹名称 👉 <code>&lt;name-of-folder&gt;</code></li><li>该子文件夹形成的新仓库 👉 <code>&lt;new-repo&gt;</code></li></ul><p>也就是说：我们有一个叫做 <code>big-repo</code> 的仓库，里面有不少子文件夹，我们想要把其中一个文件夹抽离出来，将其变成一个新的仓库 <code>new-repo</code>，并且保留之前在 <code>big-repo</code> 中所有关于这个子文件夹的所有 commit 记录。</p><p>差不多就是这样。(・_ゝ・)</p><h2 id="0x03-最简单的方法，使用-git-subtree"><a href="#0x03-最简单的方法，使用-git-subtree" class="headerlink" title="0x03 最简单的方法，使用 git subtree"></a>0x03 最简单的方法，使用 git subtree</h2><p>看来上述需求还是比较普遍的，自从 1.8 版本之后 git 就添加了 subtree 子命令，使用这个新命令我们可以很简单高效地解决这个问题。</p><p>首先，进入 <code>big-repo</code> 所在的目录，运行：</p><pre><code class="bash">git subtree split -P &lt;name-of-folder&gt; -b &lt;name-of-new-branch&gt;</code></pre><p>运行后，git 会遍历原仓库中所有的历史提交，挑选出与指定路径相关的 commit 并存入名为 <code>name-of-new-branch</code> 的临时分支中。另外需要注意的是，<strong>如果你在使用 Windows</strong>，且该文件夹深度 &gt; 1，你必须使用斜杠 <code>/</code> 作为目录分隔符而不是默认的反斜杠 <code>\</code>。</p><p>然后，我们创建一个新的 git 仓库：</p><pre><code class="bash">mkdir &lt;new-repo&gt;git init</code></pre><p>接着把原仓库中的临时分支拉到新仓库中：</p><pre><code class="bash">git pull &lt;/path/to/big-repo&gt; &lt;name-of-new-branch&gt;</code></pre><p>好了，完成。现在看看你的新仓库，是不是已经包含了原子文件夹中的所有文件和你之前在原仓库中的所有提交历史呢？</p><h2 id="0x04-麻烦点的方法，使用-git-filter-branch"><a href="#0x04-麻烦点的方法，使用-git-filter-branch" class="headerlink" title="0x04 麻烦点的方法，使用 git filter-branch"></a>0x04 麻烦点的方法，使用 git filter-branch</h2><p>除了使用新添加的 <code>subtree</code> 命令，你也可以使用 git 传统的所谓核弹级大杀器命令 —— <code>filter-branch</code> 解决上述问题。</p><p>首先，clone 一份原仓库并删掉原来的 remote：</p><pre><code class="bash">git clone &lt;big-repo&gt; &lt;new-repo&gt;cd &lt;new-repo&gt;git remote rm origin</code></pre><p>然后运行如下命令（这是重点）：</p><pre><code class="bash">git filter-branch --tag-name-filter cat --prune-empty --subdirectory-filter &lt;name-of-folder&gt; -- --all</code></pre><p>这条命令同样会过滤所有历史提交，只保留所有对指定子目录有影响的提交，并将该子目录设为该仓库的根目录。这里说明各下个参数的作用：</p><ul><li><code>--tag-name-filter</code> 该参数控制我们要如何处理旧的 tag，cat 即表示原样输出；</li><li><code>--prune-empty</code> 删除空的（对子目录没有影响的）提交；</li><li><code>--subdirectory-filter</code> 指定子目录路径；</li><li><code>-- --all</code> 该参数必须跟在 <code>--</code> 后面，表示对所有分支进行操作。如果你只想保存当前分支，也可以不添加此参数。</li></ul><p>该命令执行完毕后就可以看到新仓库中已经变成子目录的内容了，且保留了关于该子目录所有的提交历史。不过只是这样的话新仓库中的 <code>.git</code> 目录里还是保存有不少无用的 object，我们需要将其清除掉以减小新仓库的体积（如果你用上面 <code>subtree</code> 的方法的话是不需要执行这一步的）。</p><pre><code class="bash">git reset --hardgit for-each-ref --format=&quot;%(refname)&quot; refs/original/ | xargs -n 1 git update-ref -dgit reflog expire --expire=now --allgit gc --aggressive --prune=now</code></pre><p>这样，虽然麻烦点，我们也得到了和使用 0x03 方法后一样的新仓库。</p><h2 id="0x05-清理原仓库"><a href="#0x05-清理原仓库" class="headerlink" title="0x05 清理原仓库"></a>0x05 清理原仓库</h2><p>既然所指定的子文件夹已经被分离为一个单独的 git repo 了，我们就可以放心地在原仓库中删除它了：</p><pre><code class="bash">git rm -rf &lt;name-of-folder&gt;# 提交一下说明对应操作git commit -m &#39;Remove some fxxking shit&#39;# 删除刚才创建的临时分支# 后一种方法不需要执行这一步git branch -D &lt;name-of-new-branch&gt;</code></pre><p>不过这种方法还是会在提交历史中保留所有关于这个子目录的内容，如果你想要把这个子目录从原 repo 中<strong>不留一丝痕迹地完全移除</strong>，那你需要 BFG Repo Cleaner 这样的工具或者使用 <code>filter-branch</code> 等命令。</p><p>关于这个的具体操作我这里就不提了，网上一搜一大把。不过需要注意的是，这种做法并不值得提倡，请在你完全清楚自己在做什么的前提下使用此方法改写提交历史。</p><h2 id="0x06-关联原仓库与新仓库"><a href="#0x06-关联原仓库与新仓库" class="headerlink" title="0x06 关联原仓库与新仓库"></a>0x06 关联原仓库与新仓库</h2><p>这一步是可选的。</p><p>一般来说，在我们把原目录中的子文件夹分离成独立的 git 仓库后，总会希望再通过某种方法在原仓库中引用新仓库的代码。</p><p>这里我们可以通过 <code>subtree</code> 或者 <code>submodule</code> 两种命令来实现，不过他们两个各有优点和缺点，所以请根据你自己的实际情况选择（不过现在一般都推荐使用 subtree，submodule 用起来实在是太他妈的蛋疼了）。</p><p>当然，你也可以分离之后直接使用 npm、composer 之类的包管理器将新仓库作为一个依赖库引入进来，这也是完全没有问题的。</p><h2 id="0x07-参考链接"><a href="#0x07-参考链接" class="headerlink" title="0x07 参考链接"></a>0x07 参考链接</h2><ul><li><a href="https://stackoverflow.com/questions/359424/detach-move-subdirectory-into-separate-git-repository" target="_blank" rel="noopener">Detach (move) subdirectory into separate Git repository</a></li><li><a href="https://stackoverflow.com/questions/17413493/create-a-submodule-repository-from-a-folder-and-keep-its-git-commit-history" target="_blank" rel="noopener">Create a submodule repository from a folder and keep its git commit history</a></li><li><a href="http://graycarl.me/blog/make-a-directory-into-git-submodule" target="_blank" rel="noopener">如何把 GIT 仓库的子目录独立为子模块</a></li></ul><p>啊，另外，上次说好的 WSL 博文可能要鸽了抱歉咕咕咕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这几天想要把一个 git 仓库中&lt;strong&gt;已经存在&lt;/strong&gt;的一个子文件夹独立成一个新的 git 仓库，并且保留之前关于此文件夹的所有提交历史。不过我对 git 并没有这么精通，只好上网搜索之。可能是因为我关键词抓得不准，搜了好一会儿才找到可行的方案，所以写篇博文记录一下，希望能帮到后来人。&lt;/p&gt;
&lt;p&gt;另外，在 git 里这种掌控历史的感觉真棒（笑）&lt;/p&gt;
&lt;h2 id=&quot;0x01-需求分析&quot;&gt;&lt;a href=&quot;#0x01-需求分析&quot; class=&quot;headerlink&quot; title=&quot;0x01 需求分析&quot;&gt;&lt;/a&gt;0x01 需求分析&lt;/h2&gt;&lt;p&gt;我为什么会有如本文标题所述这样的需求呢？这是因为我之前把所有为 &lt;a href=&quot;https://github.com/printempw/blessing-skin-server&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Blessing Skin&lt;/a&gt; 这个程序编写的插件源码都放在一个 &lt;a href=&quot;https://github.com/printempw/blessing-skin-plugins&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git repo&lt;/a&gt; 中了，每个子文件夹中都是一个独立的插件（因为嫌麻烦所以一股脑给塞进一个仓库里了），并且对每个子文件夹中的代码的修改最后都是在这个统一仓库中提交的。该仓库差不多长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;text&quot;&gt;$ tree
├── .git
├── avatar-api
├── config-generator
├── register-email-validation
│   ├── bootstrap.php
│   ├── package.json
│   └── src
├── report-texture
└── yggdrasil-api  &amp;lt;---【我想把这个独立为一个新 repo】
    ├── bootstrap.php
    ├── package.json
    ├── routes.php
    └── src
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而我现在后悔了，想把其中的某个子目录抽离出来，把它变成一个新的 git 仓库，并且保留我之前所有在「原仓库」中关于这个子目录的「所有提交历史」。&lt;/p&gt;
&lt;p&gt;其实这种需求还是挺常见的，举个栗子：&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="记录" scheme="https://blessing.studio/tag/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Git" scheme="https://blessing.studio/tag/Git/"/>
    
  </entry>
  
  <entry>
    <title>Windows Update 出现错误 0x800703ed 可能的解决方法</title>
    <link href="https://blessing.studio/fix-windows-update-error-0x800703ed/"/>
    <id>https://blessing.studio/fix-windows-update-error-0x800703ed/</id>
    <published>2018-02-13T03:31:38.000Z</published>
    <updated>2018-02-13T03:31:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>HAIDOMO，这里是年终总结拖了两个月还没写完，上一篇博文发布于去年十月份的某鸽系博主 DESU。其实 2018 年的第一篇博文<del>原定</del>应该是 2017 年的年度总结的，但是由于各种各样的原因，那篇文章到现在还没写完咕咕咕。</p><p>最近几天正好遇到了如标题所述的「Windows Update 自动更新时出现错误 <code>0x800703ed</code>」的状况，在网上搜索许久，最后历经千辛万苦才终于定位到了问题的根源。特此记录，希望能帮到后来人。</p><h2 id="0x01-问题描述"><a href="#0x01-问题描述" class="headerlink" title="0x01 问题描述"></a>0x01 问题描述</h2><p>虽然我现在已经没多少追 Windows Insider Perview 的热情了，不过最近巨硬推出的那个 Fluent Design 看起来还是挺赞的，就打算在 Windows Update 中升级到最新的 Insider Preview。虽然速度屌慢，但是还是成功地检查到了 Build 17093 的更新并且进入了「正在准备更新」这一阶段。谁曾想等进度跑到 100% 却出现了如下错误：</p><p><img src="https://img.blessing.studio/images/2018/02/13/DV0b0p7VAAAn_zT.jpg" alt="error 0x800703ed screenshot"></p><p>这可太他妈的操蛋了。 <a id="more"></a></p><h2 id="0x02-尝试定位问题"><a href="#0x02-尝试定位问题" class="headerlink" title="0x02 尝试定位问题"></a>0x02 尝试定位问题</h2><p>我最开始有想过是网络问题，也尝试给系统挂上全局代理、在路由器强制让所有流量走代理，结果都是 <code>0x800703ed</code> ，因此基本可以排除是网络问题。</p><p>随后我在 Google 上搜索 <code>Windows Update 0x800703ed</code>，浏览了 Microsoft 中文社区中很多类似的帖子，其中官方人员的回复千篇一律，大部分都是这样的：</p><ul><li>镜像文件出错，建议重新下载</li><li>检查 Windows Update 服务是否正常运行</li><li>禁用所有其他非系统服务再检查更新</li><li>建议移除各种杀毒软件</li><li>升级修复各种驱动程序</li><li>系统文件损坏，插入安装光盘修复</li><li>下载各种 Repair 工具……</li></ul><p>我几乎尝试了他们提到的所有方法，最后都以失败告终。</p><p>其他中文社区上也有一些搜索结果，但是毫无帮助，因为他们只会让你：</p><ul><li>重装系统</li></ul><p>对于这种建议，我也想友善地回复一句：<strong>RSNDM</strong>.</p><p>中文内容是指望不上了，之后我又在巨硬的洋文支持社区以及其他站点上搜索了老半天，最后终于找到个可能的问题原因：</p><blockquote><p>安装了 Windows &amp; Linux 双系统。</p></blockquote><p>……。</p><p><img src="https://img.blessing.studio/images/2018/11/04/sticker_288532_sorena.png" alt="sticker_288532_sorena"></p><h2 id="0x03-解决问题"><a href="#0x03-解决问题" class="headerlink" title="0x03 解决问题"></a>0x03 解决问题</h2><p>按照那几个网站上的说法（详见页脚的参考链接），如果你在机器上安装了 Windows、Linux 双系统启动，并且使用了其他引导程序（例如 grub），在使用 Windows Update 执行更新操作时就会出现  <code>0x800703ed</code> 错误。</p><p><strong>而且我正好如他所述，在机器上安装了 Deepin Linux 与 Windows 的双系统，并且交给 Linux 所在分区上的 grub2 来引导双系统启动。</strong></p><p>到这里基本就可以破案了。之后我把引导程序由 grub2 切换回巨硬的 NT 6.x，重启之后 Windows Update 就一切正常了，并且成功更新至 Build 17093。</p><p><img src="https://img.blessing.studio/images/2018/11/04/windows-update-error-fixed.png" alt="windows-update-error-fixed"></p><p>具体切换引导程序的操作我这里就不说了，这种东西网上一搜一大把，注意区分 Legacy BIOS + MBR 环境和 UEFI + GPT 环境就好了。</p><p>其实昨天我在切换引导程序时还出了点小插曲：像是不小心把硬盘和 PE U盘 的 MBR <strong>一起弄坏</strong>导致差点进不去任何系统啦、修复 BCD 时总是出现莫名奇妙的问题啦、懵了半小时最后才发现是硬盘活动分区忘记改回来了之类的，要不是昨天手头正好还有个 Deepin 的 LiveCD 我现在早就凉凉了<del>（谁让我不会写 grub2 配置，看到 grub rescue 命令行就只有懵逼的份儿呢）</del>。</p><h2 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h2><p>至于为什么使用非 Windows 引导程序就会导致更新时出现 <code>0x800703ed</code> 错误，我也只能说不知道啦，鬼知道巨硬是怎么想的。或许是巨硬的系统更新流程里需要使用它自己的引导程序做些神秘的事情吧。</p><p><strong>Windows Update 更新完成后是可以切换回 grub2 引导的，完全 OJBK。</strong></p><p>不过需要注意的是，本文提到的解决方法虽然对包括我在内的许多用户都有效，但是到读者你的机器上可能就不行了，毕竟巨硬的报错从来只是给个自己编的错误代码而从来不给具体信息。正如我在标题上写的<strong>「可能的解决方法」</strong>一样，如果「切换引导程序」这个方法对于同样遇到此错误的你不起作用或者对你的设备造成了什么损伤的话，请不要顺着网线过来打我，蟹蟹。</p><p>另外预告一下，最近除了年终总结，我应该会再写一篇关于 WSL（<em>Windows Subsystem for Linux</em>）的文章，敬请期待咕咕咕。</p><p><strong>参考链接：</strong></p><ul><li><a href="https://answers.microsoft.com/en-us/windows/forum/windows_10-update/windows-10-update-error-0x800703ed-dual-boot-with/c55815b7-2931-4cd2-a40b-08843f7072b2" target="_blank" rel="noopener">Windows 10 Update Error 0x800703ed - Dual Boot with Linux</a></li><li><a href="https://www.downtowndougbrown.com/2017/05/windows-10-upgrade-fails-with-error-0x800703ed/" target="_blank" rel="noopener">Windows 10 upgrade fails with error 0x800703ed</a></li><li><a href="https://superuser.com/questions/1256254/cannot-install-windows-10-creator-update-something-went-wrong-error-code-0x80" target="_blank" rel="noopener">Cannot install Windows 10 Creator update: “something went wrong” error code 0x800703ed</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HAIDOMO，这里是年终总结拖了两个月还没写完，上一篇博文发布于去年十月份的某鸽系博主 DESU。其实 2018 年的第一篇博文&lt;del&gt;原定&lt;/del&gt;应该是 2017 年的年度总结的，但是由于各种各样的原因，那篇文章到现在还没写完咕咕咕。&lt;/p&gt;
&lt;p&gt;最近几天正好遇到了如标题所述的「Windows Update 自动更新时出现错误 &lt;code&gt;0x800703ed&lt;/code&gt;」的状况，在网上搜索许久，最后历经千辛万苦才终于定位到了问题的根源。特此记录，希望能帮到后来人。&lt;/p&gt;
&lt;h2 id=&quot;0x01-问题描述&quot;&gt;&lt;a href=&quot;#0x01-问题描述&quot; class=&quot;headerlink&quot; title=&quot;0x01 问题描述&quot;&gt;&lt;/a&gt;0x01 问题描述&lt;/h2&gt;&lt;p&gt;虽然我现在已经没多少追 Windows Insider Perview 的热情了，不过最近巨硬推出的那个 Fluent Design 看起来还是挺赞的，就打算在 Windows Update 中升级到最新的 Insider Preview。虽然速度屌慢，但是还是成功地检查到了 Build 17093 的更新并且进入了「正在准备更新」这一阶段。谁曾想等进度跑到 100% 却出现了如下错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.blessing.studio/images/2018/02/13/DV0b0p7VAAAn_zT.jpg&quot; alt=&quot;error 0x800703ed screenshot&quot;&gt;&lt;/p&gt;
&lt;p&gt;这可太他妈的操蛋了。
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="记录" scheme="https://blessing.studio/tag/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Windows" scheme="https://blessing.studio/tag/Windows/"/>
    
  </entry>
  
  <entry>
    <title>使用 Travis CI 自动部署 Hexo 博客</title>
    <link href="https://blessing.studio/deploy-hexo-blog-automatically-with-travis-ci/"/>
    <id>https://blessing.studio/deploy-hexo-blog-automatically-with-travis-ci/</id>
    <published>2017-10-04T02:50:41.000Z</published>
    <updated>2017-10-04T02:50:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前（六月份高考完后）我把博客引擎由 Ghost <a href="https://blessing.studio/migrated-to-hexo/">换成了静态博客生成器 Hexo</a>，并且只使用了自带的 Git Deployment 来手动部署生成好的静态博客文件到服务器上。虽然不像动态博客程序那样可以随时随地更新博客，但是想到马上就要上大学了，之后手头都会有电脑，所以更新博客也不算那么麻烦。</p><p>但是实在是人算不如天算，浙江这一届新高考改革是结结实实地把我坑了一把。二段线以上一段线未满这样中途半端的分数让人在填志愿时着实是犯难 —— 这次浙江几乎普遍出现「一段考生抢以往的二本中好学校，二段考生抢三本学校」这样神秘的情况。思来想去最后把心一横，决定去再读一年高四。后来全省高考录取情况出来后，也证实了我当时复读的决定也不是不合理的（譬如当时上了新浪微博热门话题的「浙江滑档大学」等）。</p><p>关于复读的话题就先放一放吧，毕竟现在的时间确实是有些紧，可能得等到寒假时才能好好地写一篇近况报告以及关于高四生活的事情了，非常遗憾。</p><p>回到正题，因为我输得透彻滚去读高四了，所以自然不可能每次都有配置完好的操作环境让我手动发博文 + 部署（虽然我也不见得有时间写什么博文）。在这样的前提条件下，一个 Hexo 博客的自动部署（持续集成）系统就显得非常有必要了。</p><h2 id="0x01-需求分析"><a href="#0x01-需求分析" class="headerlink" title="0x01 需求分析"></a>0x01 需求分析</h2><p>首先我们需要了解的是，我们到底希望实现一个怎样的系统？以下是我的设想：</p><ol><li>更新博客文章内容后 commit 到 GitHub repo（也可以直接在 GitHub 网页上 commit）；</li><li>Travis CI 自动编译生成出新的静态博客文件；</li><li>自动部署至 GitHub Pages 和我自己的服务器。</li></ol><a id="more"></a><p>虽然互联网上关于自动部署 Hexo 博客的文章已经有很多了，但是我这里还是有些需求是和他们不一样的：</p><ol><li>我所使用的 Seventeen 主题源码存放在 <a href="https://gitee.com/" target="_blank" rel="noopener">Gitee</a> （就是原来的 Git@OSC）上的私有仓库中（毕竟这主题只是我移植到 Hexo 上来的，主题版权依然属于<a href="https://qaq.cat/" target="_blank" rel="noopener">原作者</a>）；</li><li>需要同时部署至 GitHub Pages 和我自己的 VPS 上。</li></ol><p>折腾期间也是踩到了一些坑，也在这里记录一下。</p><h2 id="0x02-配置-GitHub-仓库"><a href="#0x02-配置-GitHub-仓库" class="headerlink" title="0x02 配置 GitHub 仓库"></a>0x02 配置 GitHub 仓库</h2><p>说实话我之前都没用过 GitHub Pages，也没打算直接用它来存放我的博客（<a href="https://blessing.studio/">blessing.studio</a> 依然部署在我的 VPS 上）。不过想想之后我也没有搞运维的时间了，多来几个博客的存档备份也是好的（反正也是免费的，笑）。</p><p>怎样启用 GitHub Pages 我就不多说了，智力正常的人应该都能完成这些操作。因为域名是以用户名开头的 User Pages 默认只能显示 master 分支里的内容（我也懒得去弄 Custom domain 啥的），所以我用了不同的分支来存放不同的内容：</p><ul><li><strong>master</strong> 存放 Hexo 生成好的静态文件，所有 commit 信息格式均为 <code>Site updated: %Y-%m-%d %H:%M:%S</code>；</li><li><strong>source</strong> 存放 scaffolds（脚手架）、source（文章 Markdown 源码）、_config.yml（Hexo 配置）等文件，commit 信息前都加上对应的 emoji（确实蛮好玩的，参见 <a href="https://gitmoji.carloscuesta.me/" target="_blank" rel="noopener">gitmoji</a>），并设置为 repo 的默认分支。</li></ul><p>分支操作大概像这样：</p><pre><code class="shell">git initgit remote add origin git@github.com:printempw/printempw.github.io.git# 新建 source 分支git checkout --orphan sourcegit add .git commit -m &quot;:tada: Initial commit&quot;git push origin source:source</code></pre><p>最后这个 repo 的画风是这样的：</p><p><img src="https://img.blessing.studio/images/2017/10/04/snipaste_20171004_201448.png" alt="snipaste_20171004_201448.png"></p><p><img src="https://img.blessing.studio/images/2017/10/04/snipaste_20171004_201526.png" alt="snipaste_20171004_201526.png"></p><p>我是觉得挺不错的，你说呢？</p><h2 id="0x03-配置-Travis-CI"><a href="#0x03-配置-Travis-CI" class="headerlink" title="0x03 配置 Travis CI"></a>0x03 配置 Travis CI</h2><p>怎么登录 Travis CI 并关联 GitHub 项目我也一样不多说，只要智力正常以下略。</p><p>下面主要讲一下如何编写 <code>.travis.yml</code> 配置文件。</p><h3 id="0x31-配置部署秘钥"><a href="#0x31-配置部署秘钥" class="headerlink" title="0x31 配置部署秘钥"></a>0x31 配置部署秘钥</h3><p>我博客的部署过程中需要用到 ssh 密钥认证的地方大概有这几处：</p><ul><li>从 Gitee 私有仓库 clone 主题；</li><li>将编译好的文件 push 到 GitHub Pages 和 VPS。</li></ul><p>一般网上的文章只有一个自动 push 到 GitHub Pages 的需求，所以直接申请一个 GitHub 的 Personal access tokens，配合 Travis 的环境变量配置就可以拿到 push 权限了。不过我这里情况复杂一些，所以不如直接搞个部署秘钥来得方便（而且那个 token 是可以操作所有 repo 的，更不安全）。</p><p>首先，新生成一个 ssh 密钥对（不要嫌麻烦直接把你机器上的秘钥拿去用了，太危险）：</p><pre><code class="shell"># 随便生成在哪都行，文件名也随意$ ssh-keygen -f travis.key</code></pre><p>然后把生成的公钥文件（e.g. <code>travis.key.pub</code>）分别添加到 GitHub Deploy Keys（在哪你自己找呀）、Gitee 部署秘钥、VPS 上的 <code>~/.ssh/authorized_keys</code> 中，这样 Travis CI 的机器就可以直接访问这些服务器了。</p><p>那我们要怎么在 Travis CI 自动部署过程中使用这个私钥呢？直接放在 repo 里提交上去肯定是不行的；而且那么长一串的私钥，总不能设置成环境变量吧（摊手）。</p><p>不过好在 Travis CI 提供了文件加密工具，这样我们就可以直接把加密后的私钥提交到 git repo 中，然后在 Travis CI 自动部署过程中解密出原秘钥并使用了（网上还有其他神秘的加密方法，但是没几个有 openssl aes-256-cbc 加密这样靠谱）。</p><p>首先，我们需要安装 Travis 的命令行工具：</p><pre><code class="shell"># 是的，你没看错，Travis 的命令行工具是用 Ruby 写的# 所以，想要用它你还得去安装 Ruby 环境……去吧，我的朋友$ sudo gem install travis</code></pre><p>然后通过命令行登录 Travis 并加密文件：</p><pre><code class="shell"># 交互式操作，使用 GitHub 账号密码登录# 如果是私有项目要加个 --pro 参数$ travis login --auto# 加密完成后会在当前目录下生成一个 travis.key.enc 文件# 还会在你的 .travis.yml 文件里自动加上用于解密的 shell 语句# 还 tmd 会自动格式化你的 .travis.yml 文件，去他妈的$ travis encrypt-file travis.key -add</code></pre><p>需要注意的是，这些文件加密步骤<strong>不能</strong>在 Windows 系统下完成，不然在自动部署时会出现神秘的错误（wrong final block length）。这个问题已经被很多人<a href="https://github.com/travis-ci/travis-ci/issues/4746" target="_blank" rel="noopener">报告过了</a>（实际上我也踩上去了），并且<a href="https://docs.travis-ci.com/user/encrypting-files/" target="_blank" rel="noopener">官方文档</a>里也加上了这样一段话：</p><p><img src="https://img.blessing.studio/images/2017/10/04/snipaste_20171004_204633.png" alt="Caveat"></p><p>总之就是「辣鸡 Windows 太菜了不行，给我用 WSL 或者类 Unix 系统吧哈哈哈」的意思（迫真）经过我的测试，Windows10 下的 babun、Git Bash 均告失败，WSL（Windows Subsystem for Linux）和我 VPS 上的 Ubuntu 14.04 所生成的加密文件均可通过自动部署，屁事儿没有。</p><p>以上步骤完成后你会得到一个 <code>travis.key.enc</code>，然后你把这玩意放到 repo 的哪里去都成，随你喜欢，只要能访问得到就可以（比如说我放到了 <code>.travis</code> 目录里）。然后在 <code>.travis.yml</code> 可以使用如下命令解密出原本的 ssh 私钥：</p><pre><code># 环境变量 $encrypted_1fc90f464345_key 中的那一串字符是随机的，每个人都不一样，自己机灵点儿改成你自己的。这个环境变量名也可以在 Travis CI 的项目后台环境变量设置中查看openssl aes-256-cbc -K $encrypted_1fc90f464345_key -iv $encrypted_1fc90f464345_iv -in .travis/travis.key.enc -out ~/.ssh/id_rsa -d</code></pre><p>搞定了密钥认证后，我们还需要修改一下机器的 SSH 配置。为啥呢？</p><p><img src="https://i.loli.net/2017/10/04/59d4dac7a6381.png" alt="snipaste_20171004_205715.png"></p><p>相信大家对于上面的提示并不陌生 —— 每次我们使用 ssh 尝试连接到一个我们之前没有连接过的服务器时都会出现这样的提示。但是在 Travis CI 的自动部署过程中是不接受任何命令行输入的（好像可以，但是很麻烦），所以我们必须想办法把这个确认过程给干掉，否则自动部署就会被卡在这里直到超时了。</p><p>网上搜一搜就能知道管这玩意的是 <code>./ssh/config</code> 里的 <code>StrictHostKeyChecking</code> 配置项，所以我们可以在项目里写一个自己的 ssh 配置文件，然后在自动部署过程中替换掉 Travis CI 机器的 ssh 配置：</p><pre><code># 文件 [.travis/ssh_config]Host github.com    User git    StrictHostKeyChecking no    IdentityFile ~/.ssh/id_rsa    IdentitiesOnly yesHost gitee.com    User git    StrictHostKeyChecking no    IdentityFile ~/.ssh/id_rsa    IdentitiesOnly yesHost prinzeugen.net    User git    StrictHostKeyChecking no    IdentityFile ~/.ssh/id_rsa    IdentitiesOnly yes# 文件 [.travis.yml]mv -fv .travis/ssh-config ~/.ssh/config</code></pre><p>也有另外一种方法是通过在 <code>.travis.yml</code> 中添加 <code>ssh_known_hosts</code> 来实现的（具体可以看 Travis CI 的 <a href="https://docs.travis-ci.com/user/ssh-known-hosts/" target="_blank" rel="noopener">官方文档</a>），不过上面的方法灵活性更高（是的，我是写到这里才发现还有这种方法……上面的我也懒得删了，就放在那吧，括弧笑）。</p><pre><code class="yml">addons:  ssh_known_hosts:  - github.com  - gitee.com  - prinzeugen.net</code></pre><p>这样一来，就没有什么能阻挡我们的自动部署过程啦 <img src="https://img.blessing.studio/images/2017/10/04/QQ20171004210320.jpg" alt="表情"></p><h3 id="0x32-编写-travis-yml"><a href="#0x32-编写-travis-yml" class="headerlink" title="0x32 编写 .travis.yml"></a>0x32 编写 .travis.yml</h3><p>我就直接贴我自己的配置了（放在 <a href="https://gist.github.com/printempw/42e8781ed3adadbcc6ecac01904a32f6" target="_blank" rel="noopener">Gist</a> 上，加载不出来的自己想办法），诸位看着修改：</p><script src="https://work.prinzeugen.net/gist/printempw/42e8781ed3adadbcc6ecac01904a32f6.js"></script><p>大部分语句都加了注释，我也就不再多说明了。</p><p>如果不出意外，每次 push 新 commit 到 source 分支后，Travis CI 就会自动帮你构建最新的静态博客，并部署至 Github Pages 和你自己的 VPS 上了。</p><p><img src="https://img.blessing.studio/images/2017/10/04/snipaste_20171004_212745.png" alt="Travis CI Build Status"></p><h2 id="0x04-后记"><a href="#0x04-后记" class="headerlink" title="0x04 后记"></a>0x04 后记</h2><p>打开博客一看，上一篇博文已经是两个月之前的事情了。复读开学之后这段时间确实是挺忙的，每天晚上回寝室后屌累屌困，最多也就记记账，看看邮件，看看 RSS，闲的话刷刷 Twitter，确实是没有什么时间像这样坐下来写一篇文章了。</p><p>估计以后博文更新频率也会越来越低吧，唉。</p><h3 id="0x41-参考链接"><a href="#0x41-参考链接" class="headerlink" title="0x41 参考链接"></a>0x41 参考链接</h3><ul><li><a href="https://changkun.us/archives/2017/06/232/" target="_blank" rel="noopener">Hexo + GitHub + Travis CI + VPS 自动部署</a></li><li><a href="http://www.itfanr.cc/2017/08/09/using-travis-ci-automatic-deploy-hexo-blogs/" target="_blank" rel="noopener">使用 Travis CI 自动部署 Hexo 博客</a></li><li><a href="https://segmentfault.com/a/1190000009054888" target="_blank" rel="noopener">使用 Travis 自动部署 Hexo 到 Github 与 自己的服务器</a></li><li><a href="https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/" target="_blank" rel="noopener">用 Travis CI 自動部署網站到 GitHub</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前（六月份高考完后）我把博客引擎由 Ghost &lt;a href=&quot;https://blessing.studio/migrated-to-hexo/&quot;&gt;换成了静态博客生成器 Hexo&lt;/a&gt;，并且只使用了自带的 Git Deployment 来手动部署生成好的静态博客文件到服务器上。虽然不像动态博客程序那样可以随时随地更新博客，但是想到马上就要上大学了，之后手头都会有电脑，所以更新博客也不算那么麻烦。&lt;/p&gt;
&lt;p&gt;但是实在是人算不如天算，浙江这一届新高考改革是结结实实地把我坑了一把。二段线以上一段线未满这样中途半端的分数让人在填志愿时着实是犯难 —— 这次浙江几乎普遍出现「一段考生抢以往的二本中好学校，二段考生抢三本学校」这样神秘的情况。思来想去最后把心一横，决定去再读一年高四。后来全省高考录取情况出来后，也证实了我当时复读的决定也不是不合理的（譬如当时上了新浪微博热门话题的「浙江滑档大学」等）。&lt;/p&gt;
&lt;p&gt;关于复读的话题就先放一放吧，毕竟现在的时间确实是有些紧，可能得等到寒假时才能好好地写一篇近况报告以及关于高四生活的事情了，非常遗憾。&lt;/p&gt;
&lt;p&gt;回到正题，因为我输得透彻滚去读高四了，所以自然不可能每次都有配置完好的操作环境让我手动发博文 + 部署（虽然我也不见得有时间写什么博文）。在这样的前提条件下，一个 Hexo 博客的自动部署（持续集成）系统就显得非常有必要了。&lt;/p&gt;
&lt;h2 id=&quot;0x01-需求分析&quot;&gt;&lt;a href=&quot;#0x01-需求分析&quot; class=&quot;headerlink&quot; title=&quot;0x01 需求分析&quot;&gt;&lt;/a&gt;0x01 需求分析&lt;/h2&gt;&lt;p&gt;首先我们需要了解的是，我们到底希望实现一个怎样的系统？以下是我的设想：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;更新博客文章内容后 commit 到 GitHub repo（也可以直接在 GitHub 网页上 commit）；&lt;/li&gt;
&lt;li&gt;Travis CI 自动编译生成出新的静态博客文件；&lt;/li&gt;
&lt;li&gt;自动部署至 GitHub Pages 和我自己的服务器。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="博客" scheme="https://blessing.studio/tag/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Hexo" scheme="https://blessing.studio/tag/Hexo/"/>
    
      <category term="持续集成" scheme="https://blessing.studio/tag/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>又是一种 Minecraft 外置登录解决方案：自行实现 Yggdrasil API</title>
    <link href="https://blessing.studio/minecraft-yggdrasil-api-third-party-implementation/"/>
    <id>https://blessing.studio/minecraft-yggdrasil-api-third-party-implementation/</id>
    <published>2017-08-08T15:28:32.000Z</published>
    <updated>2018-02-21T17:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近给 Blessing Skin 写了个插件，利用皮肤站本身的账号系统实现了 Yggdrasil API（就是 Mojang 的登录 API），然后配合 <a href="https://github.com/to2mbn/authlib-injector/" target="_blank" rel="noopener">authlib-injector</a> 这个项目将启动器（基于 Java 编写的支持正版登录的启动器都行）、Minecraft 游戏、Minecraft 服务端中的 Mojang Yggdrasil API 地址给替换成了自己实现的第三方 Yggdrasil API 地址（字节码替换），从而实现了与正版登录功能几乎完全相同的账户鉴权系统。</p><p>通俗地讲，就是我把 Mojang 的正版登录 API 给【劫持】成自己的啦，所以可以像登录正版那样直接用皮肤站的邮箱和密码登录游戏（还支持 Mojang 都不支持的多用户选择哦）。这种外置登录系统的实现应该可以说是比市面上的软件都要完善（毕竟可以直接利用 Minecraft 本身自带的鉴权模块），因此写一篇博文介绍一下这些实现之间的不同之处，顺带记录一下实现 Yggdrasil API 时踩到的坑，算是抛砖引玉了。</p><div class="alert alert-warning"><p><strong>注意</strong>：本文不适合小白及问题解决能力弱的人群阅读。</p></div><p><del>感觉我明明好久没玩 MC 了，要玩也都是玩正版服务器，但是却一直在搞这些盗版服用的东西，我真是舍己为人造福大众普惠众生啊（不</del></p><h2 id="一、服务器内置登录插件"><a href="#一、服务器内置登录插件" class="headerlink" title="一、服务器内置登录插件"></a>一、服务器内置登录插件</h2><p>相信维护过 Minecraft 服务器（当然，我这边说的是运行在离线模式下的服务器）的腐竹们或多或少都听说过 Authme、CrazyLogin 等登录插件的鼎鼎大名吧。由于这些服务器运作在离线模式（<code>online-mode=false</code>，即俗称的盗版模式）下，缺少 Mojang 官方账户认证系统的支持，所以必须使用这类插件来进行玩家认证（否则随便谁都可以冒名顶替别人了，换一个登录角色名就行）。</p><p>这类插件的工作原理就是在服务端维护一个数据表，表中每一条记录中存储了角色的「角色名」、「登录密码」、「注册时间」、「登录 IP 地址」等等信息，当玩家初次进入服务器时需要通过这些插件进行注册操作（e.g. <code>/register</code> 命令）并在表中插入一条记录，注册完毕后进入服务器则需要输入密码（e.g. <code>/login &lt;password&gt;</code> 命令）来认证。</p><p>其实这样的解决方案也没什么不好，而且现在 Authme 等登录插件在众多的服务器中都还是主流。但是，如果你的服务器已经发展到比较大型了，或许你就比较希望有这样一个东西：</p><a id="more"></a><ul><li>可以直接在启动器中进行登录鉴权操作，点击「开始游戏」就可以直接进入服务器，不用在游戏里再一遍遍输入 <code>/login</code> 等指令；</li><li>有一个网页版的用户管理，可以直接对玩家进行操作（e.g. 封禁、修改积分）；</li><li>玩家们可以直接在一个直观的网页上注册账号，并且可以直接用这个账号 &amp; 密码登录游戏；</li><li>希望这个账号系统还能对接论坛、皮肤站等乱七八糟的东西，玩家注册了一个账号之后，可以在任何地方使用；</li><li>希望服务器有一个自己的网页、自定义启动器、用户管理系统、卫星地图之类的东西来装逼；</li><li>etc.</li></ul><p>并不是所有腐竹都满足于 Authme + Discuz 这样的组合的（而且这类游戏内登录系统也有不少安全漏洞），毕竟在这个 Minecraft 多人联机服务器发展接近饱和的时候，如果想要你的服务器能够吸引新玩家，那么除了服务器本身建设之外的地方也是要好好考虑的。</p><h2 id="二、外置登录系统"><a href="#二、外置登录系统" class="headerlink" title="二、外置登录系统"></a>二、外置登录系统</h2><p>正是这样的需求催生了不少 Minecraft 的「外置登录插件」、「网页登录」等等软件（而且人气都挺高的），我随手在 MCBBS 上一搜就有很多类似的产品，用啥语言写的都有：<em>MadAuth、WebLogin、BeeLogin、WebRegister、冰棂登陆系统……</em></p><p>这些软件的原理就是将原本的登录鉴权这一步骤从游戏里抽出来了，将其放到启动器 or 网页上去，而服务端插件的功能就只剩下「查询数据库中用户的登录状态，决定是否放行」：</p><p><img src="https://img.blessing.studio/images/2017/08/04/Minecraft.png" alt="原理图"></p><p><em>▲随手画的示意流程图，这里推荐一下  <a href="https://www.processon.com/" target="_blank" rel="noopener">ProcessOn</a> 这个在线作图网站，很好用 ;)</em></p><p>似乎也挺好的，不是吗？那我今天要说的「自行实现 Yggdrasil API」方法，和这些现成的方式有什么不一样呢？</p><h2 id="三、自行实现-Yggdrasil-API"><a href="#三、自行实现-Yggdrasil-API" class="headerlink" title="三、自行实现 Yggdrasil API"></a>三、自行实现 Yggdrasil API</h2><p>继续看下去之前，首先你要知道 Mojang 正版的 Minecraft 是怎样登录的。Mojang 专门定义了一个用于鉴权的 API，Mojang 旗下的游戏（Minecraft、Scrolls 等）都是用的这一套 API 来正版验证的 —— 这一套 API 的名字就叫做 Yggdrasil（即北欧神话里的世界树，<del>这名字可真几把炫酷</del>）。</p><p>正版登录的好处就不用我说了吧？再也不用担心假人压测、自带外置登录（启动器里账号密码登录）、自带皮肤加载（不需要安装 CSL、USM 等皮肤补丁了）、Tab 栏显示头像……可以说，Minecraft 自带的 Yggdrasil API 鉴权系统比上面的那些什么登录插件啊什么外置登录的功能强多了，所以正版服务器（<code>online_mode=true</code>）也不用担心那些破事，因为官方的这一套鉴权系统以及很完善了。</p><p>那么问题来了，盗版用户要怎样才能把 Mojang 为正版开发的 Yggdrasil API 系统拿来用呢？</p><h3 id="3-1-基本原理"><a href="#3-1-基本原理" class="headerlink" title="3.1 基本原理"></a>3.1 基本原理</h3><p>这里必须感谢 <a href="https://github.com/to2mbn/authlib-injector/" target="_blank" rel="noopener">to2mbn/authlib-injector</a> 这个项目，正是因为这个项目，我接下来描述的方法才成为可能。是的，方法很简单，Minecraft 虽然把 Mojang 官方的 Yggdrasil API 地址（<code>https://authserver.mojang.com</code>）给写死在源码里了，但是既然 Minecraft 是基于 JVM 的应用程序，我们就可以通过字节码替换的方法将官方的 API 地址替换成我们自己实现的 API 地址。</p><p>以下内容援引自 authlib-agent（即 authlib-injector 前身）的 wiki：</p><blockquote><p>authlib-agent 是一个高可靠性, 高适用性, 用于 Minecraft 的, 游戏外登录及皮肤解决方案. 支持 Minecraft1.7+, Craftbukkit, Spigot, Bungeecord 等. 通过对正版登录 API 的重定向, 实现了一个功能和正版几乎一样的游戏外登录系统.</p></blockquote><p>不过既然要把官方 API 地址替换成我们自己的，我们就得自己实现一个和官方 API 其他地方都一样的 API，也就是，<strong>仿造出一个第三方 Yggdrasil API 出来</strong>。</p><h3 id="3-2-解决方案"><a href="#3-2-解决方案" class="headerlink" title="3.2 解决方案"></a>3.2 解决方案</h3><p>可以说这个系统中，就是「开发完整实现了 Yggdrasil API 的后端」这一步最难了。为啥捏？这个服务端不止要实现用户的认证、皮肤获取，你还得实现用户的注册、登录、角色管理、皮肤上传、皮肤库等等七七八八的功能吧？你还得给这些功能套上一个好看的界面吧，不然你让你的玩家怎么使用？你还得来个后台管理页面吧，不然管理员怎么进行用户管理、封禁等操作？</p><p>authlib-injector 官方也提供了一个 Java 编写的后端 <a href="https://github.com/to2mbn/yggdrasil-mock" target="_blank" rel="noopener">yggdrasil-mock</a>，虽然完整实现了 Yggdrasil API，但是它并没有提供直观的管理网页，只提供了一套 RESTful API，所以距离实装要求还是差得比较远的。</p><p>要重头开发一套这样的系统是非常非常够呛的，不过幸运的是，我之前一直在持续开发的 Minecraft 皮肤站 <a href="https://github.com/printempw/blessing-skin-server" target="_blank" rel="noopener">Blessing Skin Server</a>，这个项目的 v3 版本<strong>正好</strong>就满足的这些要求 —— 友好的用户界面、完善的用户系统、强大的后台管理、附带皮肤上传管理展示功能，再加上我之前开发的<a href="https://blessing.studio/laravel-plugin-system-1/">插件系统</a>（开发这玩意真是个正确的决定，一劳永逸啊） ，这让我可以很方便地开发一个插件出来，直接基于现成的皮肤站用户系统实现 Yggdrasil API。</p><p><img src="https://i.loli.net/2017/08/04/59846283822ac.png" alt="API"></p><h3 id="3-3-如何使用"><a href="#3-3-如何使用" class="headerlink" title="3.3 如何使用"></a>3.3 如何使用</h3><p>讲了那么多，那么到底该怎么使用呢？</p><p>请参阅：<a href="https://github.com/printempw/yggdrasil-api/wiki" target="_blank" rel="noopener">printempw/yggdrasil-api wiki</a>。</p><p>以上步骤完成后你将得到什么？</p><ul><li>一个完善的账号系统（配合数据对接插件还能与 Discuz 等论坛账号互通），包括友好的注册、登录网页界面以及强大的管理员面板，在管理后台中封禁用户后，该用户也将无法登录游戏；</li><li>一个皮肤管理系统，自带皮肤库功能，在皮肤站中应用的皮肤，玩家无需安装任何皮肤 Mod，进入游戏即可看到自己设置的皮肤（支持双层皮肤、支持 Alex 模型，由于游戏本身限制不支持高清皮肤）；</li><li>单账户多角色功能，玩家可以像登录正版那样用「邮箱」和「密码」登录游戏，而且如果你在皮肤站中添加了多个角色的话，还可以在启动页面选择要用哪个角色进入游戏（Yggdrasil API 实现了这个功能，但是 Mojang 的正版登录服务器并未实现该功能），HMCL 等启动器都实现了本功能；</li></ul><p>这还不够多吗？</p><p>而且你还可以自己修改 HMCL 等开源启动器的源码，在启动时自动注入 <code>-javaagent</code> 参数，更加方便，还能得到一个服务器专用启动器，逼格更高了（笑）</p><h3 id="3-4-实现效果"><a href="#3-4-实现效果" class="headerlink" title="3.4 实现效果"></a>3.4 实现效果</h3><p>皮肤站的用户管理系统、皮肤系统、后台界面之类的我就不截图了，有兴趣可以去 MCBBS 的 <a href="http://www.mcbbs.net/forum.php?mod=viewthread&amp;tid=552877" target="_blank" rel="noopener">发布帖</a> 上感受一下。</p><p><img src="https://img.blessing.studio/images/2017/08/04/imageac07f.png" alt="网页管理"></p><p><em>▲在皮肤站「角色管理」中可添加多个角色</em></p><p><img src="https://img.blessing.studio/images/2017/08/04/image.png" alt="多角色选择"></p><p><em>▲使用皮肤站的邮箱与密码登录后，配合 HMCL 实现多角色选择</em></p><p><img src="https://i.loli.net/2017/08/04/5984671f87c40.png" alt="游戏"></p><p>▲游戏内的显示效果</p><h2 id="四、Yggdrasil-API-踩坑记录"><a href="#四、Yggdrasil-API-踩坑记录" class="headerlink" title="四、Yggdrasil API 踩坑记录"></a>四、Yggdrasil API 踩坑记录</h2><p>下面记录一些自己实现 Yggdrasil API 时踩到的坑，毕竟 wiki.vg 里并不会提到这些在自己实现 API 时需要注意的东西（提到的大部分都是使用 API 时应该要注意的），所以我也只能摸着石头过河，踩了不少坑，这里记录一下，希望能帮到后来人。</p><p>基础的 API 定义之类的我就不说了，下面主要讲一些 <a href="http://wiki.vg/Authentication" target="_blank" rel="noopener">文档</a> 里没怎么提到的东西。</p><blockquote><p><strong>2018-02-22 加注：</strong></p><p>最近 @yushijinhun 写了一篇 <a href="https://github.com/to2mbn/authlib-injector/wiki/Yggdrasil%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8A%80%E6%9C%AF%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">Yggdrasil 服务端技术规范</a>，大部分 API 相关的内容其中都有提及，大家去看那个就好了。</p></blockquote><h3 id="4-1-登录与鉴权"><a href="#4-1-登录与鉴权" class="headerlink" title="4.1 登录与鉴权"></a>4.1 登录与鉴权</h3><p>用过正版 Minecraft 的登录系统的同学应该都知道，一般只有在初次登录游戏或者太久没有开过游戏的情况下，启动器才会要求你输入账号密码，其他情况下都是可以直接点击登录并启动游戏的。</p><p>但这并不是因为启动器记下了你的密码，相反，启动器保存的是 Mojang 认证服务器返回的 AccessToken。如果你曾经观察过启动器启动游戏时所用的启动参数，你就能发现其实 Minecraft 游戏本体其实只拿到了角色名、角色 Profile 对应的 UUID 以及上面提到的 AccessToken 而已。可以说，只要拿到这个 AccessToken 就可以进行几乎所有的操作了。</p><pre><code class="text">--username 621sama--uuid d3af753b7cda4666adc2ff9bba85e0eb--accessToken cc1e7c7d-00ab-4f37-bbe1-983e18f1755d</code></pre><h4 id="4-1-1-获取-AccessToken"><a href="#4-1-1-获取-AccessToken" class="headerlink" title="4.1.1 获取 AccessToken"></a>4.1.1 获取 AccessToken</h4><p>用正确的 <code>username</code> 和 <code>password</code> 请求 <code>/authenticate</code> API 即可拿到 AccessToken，该令牌的有效期由服务端来决定（一般用 Redis 实现）。如果你请求 API 的时候没有带上 <code>clientToken</code>，那服务端就会帮你生成一个，你要记得把这个返回值记下来，因为 clientToken 和 accessToken 是对应关系，有些 API 是要求同时提供 AccessToken 和签发该令牌的 clientToken 的。</p><p>另外需要注意的是，这个 <code>/authenticate</code> API 中请求体中的 <code>username</code> 字段，<strong>填的是邮箱</strong>。</p><p>是的，你没听错，email，在 username 字段里填的是用户的 email。惊不惊喜，意不意外？这个狗屎一样的字段命名估计和历史遗留问题也有关系，因为早期 Minecraft 账号（也就是 Profile 里的那个 <code>legacy</code> 字段）是直接用<strong>「角色名」</strong>和「密码」登录的，但是新版 Mojang 账号（Yggdrasil API）认证是用的<strong>「电子邮箱账号」</strong>，Yggdrasil API 为了兼容旧账号的登录，所以搞了这么一个坑爹的东西，真是说不出话。</p><p>总之，如果想要自己实现 Yggdrasil API，是要注意一下这个神秘的 <code>username</code> 字段的。</p><h4 id="4-1-2-刷新-AccessToken"><a href="#4-1-2-刷新-AccessToken" class="headerlink" title="4.1.2 刷新 AccessToken"></a>4.1.2 刷新 AccessToken</h4><p>在登录成功拿到 <code>accessToken</code> 后，启动器应该把这个令牌存起来，然后在每次玩家登录游戏之前请求一次 <code>/refresh</code> API，提供 accessToken 和签发该令牌时用的 clientToken（这也是我为什么上面叫你要把这个存起来的原因），就可以拿到新签发的 accessToken 了（刷新令牌有效期）。只要令牌有效期没过，启动器就不会再次请求 <code>/authenticate</code> API。</p><p>所以，虽然文档上没说，但是其实 <code>/refresh</code> 返回的结果应该是要和 <code>/authenticate</code> 的返回结果大致相同的，包括 accessToken、clientToken、availableProfiles、selectedProfile、user 等字段（具体下面再说）。</p><h3 id="4-2-API-中的-Token"><a href="#4-2-API-中的-Token" class="headerlink" title="4.2 API 中的 Token"></a>4.2 API 中的 Token</h3><p>Yggdrasil API 的定义中主要有两个 Token，<code>clientToken</code> 与 <code>accessToken</code>，两者为对应关系。一般来说，启动器不会频繁变动 ClientToken（通常情况下，是永远不会变的），而 AccessToken 应该在每次登录游戏时通过 <code>/refresh</code> 重新签发一个。</p><h4 id="4-2-1-Token-的生命周期"><a href="#4-2-1-Token-的生命周期" class="headerlink" title="4.2.1 Token 的生命周期"></a>4.2.1 Token 的生命周期</h4><p>需要注意的是，AccessToken 是有生命周期的，大致如下：</p><pre><code class="text">|---- 1. 有效 ----|---- 2. 暂时失效 ----| 3. 无效|------------------------------------------------------&gt; Time</code></pre><p>AccessToken 刚签发时处于「有效」状态，经过一段时间后（服务端自行设置）变成「暂时失效」状态。在这种状态下的 AccessToken 是无法进入任何开启了正版验证的服务器的（也就是 <code>/join</code> API 不认），但是该令牌还是能拿来请求 <code>/refresh</code> API，这会签发一个全新的处于「有效」状态的 AccessToken 并返回给客户端。</p><p>但是如果处于「暂时失效」状态的 AccessToken 再放置一段时间后就会完全失效（一般的实现就是从 Redis 令牌桶中删掉该令牌），处于「无效」状态的 AccessToken 是无法进行任何操作的，只能让用户重新输入密码并请求 <code>/authenticate</code> API 以获取一个新的 AccessToken。</p><h4 id="4-2-2-Token-的格式"><a href="#4-2-2-Token-的格式" class="headerlink" title="4.2.2 Token 的格式"></a>4.2.2 Token 的格式</h4><p>Yggdrasil API 中的 <code>clientToken</code>、<code>accessToken</code>、<code>id</code> 等字段的格式都是一大串 16 进制数字和 <code>-</code> 连字符组成的字符串，让人看起来很懵。其实这样的字符串格式就是 <strong>通用唯一识别码</strong>（<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81" target="_blank" rel="noopener">Universally Unique Identifier</a>）标准，也就是我们经常听到的 UUID 了。标准形式的 UUID 包含 32 位 16 进制数字，并且由连字符分割成形式为 8-4-4-4-12 的字符串，就像这样：</p><pre><code># 至于如何生成 UUID，各个语言一般都有对应的库，搜一下就有了550e8400-e29b-41d4-a716-446655440000</code></pre><p>虽然文档中没说，但是 API 请求以及响应的 <code>clientToken</code> 、<code>accessToken</code> 以及玩家 Profile 中的 <code>id</code> 字段格式都是<strong>【不带连字符的 UUID】</strong>。下面拿 wiki.vg 中的 <code>/authenticate</code> 请求中的实例响应讲解一下：</p><pre><code class="json">{  // 不带连字符的 UUID 格式  &quot;accessToken&quot;: &quot;869a97cb2bc841be84bfd668c299a718&quot;,  // 无符号 UUID，与 accessToken 对应  &quot;clientToken&quot;: &quot;c0b2bac2eb434af5ae8ae7f824cee02f&quot;,  &quot;availableProfiles&quot;: [    {      // 无符号 UUID，下同      &quot;id&quot;: &quot;d3af753b7cda4666adc2ff9bba85e0eb&quot;,      &quot;name&quot;: &quot;621sama&quot;    }  ],  &quot;selectedProfile&quot;: {    &quot;id&quot;: &quot;d3af753b7cda4666adc2ff9bba85e0eb&quot;,    &quot;name&quot;: &quot;621sama&quot;  },  &quot;user&quot;: {    &quot;id&quot;: &quot;d3af753b7cda4666adc2ff9bba85e0eb&quot;,    &quot;properties&quot;: []  }}</code></pre><p>至于后端存储时用怎样的格式就随意了，不过在 API 返回结果中是一定要按照上面的格式来的。</p><h3 id="4-4-多角色选择功能"><a href="#4-4-多角色选择功能" class="headerlink" title="4.4 多角色选择功能"></a>4.4 多角色选择功能</h3><p>虽然 Mojang 官方迄今为止仍未支持同一个<strong>账号</strong>（Mojang 账号，用邮箱登录的那个）下添加多个<strong>角色</strong>（角色名，就是游戏里显示的那个），但是 Yggdrasil API 本身是可以实现这个<strong>「单账号多角色」</strong>功能的，并且官方启动器、HMCL 等著名的第三方启动器都支持<strong>登录后选择角色进入游戏</strong>（具体效果参见上方截图）。</p><p>如果你仔细阅读过 wiki.vg 里的 API 文档的话就会发现，<code>/authenticate</code> 里面有好几个包含了 Profile 的字段，分别是 <code>availableProfiles</code>、<code>selectedProfile</code> 和 <code>user</code>。下面我稍微说一下这几个字段的功能。</p><p>首先，<code>availableProfiles</code> 中存放的是这个<strong>账号</strong>下所有可用<strong>角色</strong>的 Profile，格式为 JSON 数组：</p><pre><code class="json">&quot;availableProfiles&quot;: [  {    &quot;id&quot;: &quot;不带连字符的 UUID&quot;,    &quot;name&quot;: &quot;角色名&quot;  },  {    &quot;id&quot;: &quot;d3af753b7cda4666adc2ff9bba85e0eb&quot;,    &quot;name&quot;: &quot;621sama&quot;  }]</code></pre><p>需要注意的是，每个<strong>角色 Profile</strong> 都应该有一个唯一的 <code>id</code>（格式为不带连字符的 UUID），而不是每个账号一个。而且，虽然官方文档上没有写，其实 <code>/refresh</code> API 返回的结果应该和 <code>/authenticate</code> 一样带上 <code>availableProfiles</code> 这个属性（因为只有第一次密码登录才会请求 <code>/authenticate</code>，之后进游戏就只会请求 <code>/refresh</code> 了）。</p><p>而 <code>selectedProfile</code> 字段内容为<strong>被选中</strong>的角色 Profile。如果这个字段存在，启动器就会<strong>直接</strong>用这个角色进入游戏。只有在 <code>selectedProfile</code> 字段不存在时，启动器才会弹出「选择角色」对话框，并根据用户的输入选择不同的角色进入游戏。如果你想要搞支持<strong>单账户多角色</strong>的 API 的话，可以不用管这个字段（不过当该账号名下只有一个角色的话记得指定 <code>selectedProfile</code> ，这样启动器就可以直接用这个角色进游戏了）。</p><p>至于 <code>user</code> 字段是只有在请求时带上了 <code>requestUser</code> 属性时才会回复的，其中包括被选中角色的 UUID、语言偏好、Twitch 的 AccessToken 等等，一般来说，自己实现 Yggdrasil API 时可以忽略这玩意（而且这个属性对单账户多角色的支持并不好）。</p><h3 id="4-5-加载皮肤与披风"><a href="#4-5-加载皮肤与披风" class="headerlink" title="4.5 加载皮肤与披风"></a>4.5 加载皮肤与披风</h3><p>这里稍微提一下 Minecraft 使用 Yggdrasil API 时加载皮肤的原理。</p><p>首先你要知道，Minecraft 游戏启动时从启动器那边（i.e. 从命令行）拿到的 API 相关属性只有「AccessToken」、「选中角色的 UUID」以及「选中角色的角色名」这三样东西。获取 Profile 以及加载皮肤是 Minecraft 游戏该做的工作，具体流程如下。</p><h4 id="4-5-1-获取完整-Profile"><a href="#4-5-1-获取完整-Profile" class="headerlink" title="4.5.1 获取完整 Profile"></a>4.5.1 获取完整 Profile</h4><p>首先 Minecraft 会请求 API <code>/profiles/minecraft/{uuid}</code> 获取角色的完整 Profile，差不多长这样：</p><pre><code class="json">{  &quot;id&quot;: &quot;d3af753b7cda4666adc2ff9bba85e0eb&quot;,  &quot;name&quot;: &quot;621sama&quot;,  &quot;properties&quot;: [    {      &quot;name&quot;: &quot;textures&quot;,      &quot;value&quot;: &quot;eyJ0aW1lc3RhbXAiOjE1MDIyMDA5OTAwMjgsInByb2ZpbGVJZCI6ImQzYWY3NTNiLTdjZGEtNDY2Ni1hZGMyLWZmOWJiYTg1ZTBlYiIsInByb2ZpbGVOYW1lIjoiNjIxc2FtYSIsImlzUHVibGljIjp0cnVlLCJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly9za2luLmRldi90ZXh0dXJlcy84MzRjYmQ4NDhmMGEyOTAwOGJmNWIxZDU5ZDAyZWNiMWNmMjVkZmQyMWZjODhiZTFjMTgzYzkyNjFmNWZkZDY5In0sIkNBUEUiOnsidXJsIjoiaHR0cDovL3NraW4uZGV2L3RleHR1cmVzLzI5MTE0MzhlODI4MmQ0MGU2ZDY0ZmJlZmQwNzZlZWYwYTkwMWNiOTBkM2RlYWU0MDU3ZmVjNjBjNjZlYjkzZDIifX0sInNpZ25hdHVyZVJlcXVpcmVkIjp0cnVlfQ==&quot;,      &quot;signature&quot;: &quot;Zvox4YClUMHIAMe1tRLV/JmMaGF0pZhkmrigFpo7jOme8f559gZVyBQoTXeZsXn7Hwq5TE0b9m09MzuAGoT7dQ7kxkHA60xvVQXMQlbWP5O+EA8fzOM0hgINe8Qv7hSBG89osr+wWE7pTJ1CIKD6CBoK1a/U9UiCyQuDlO2gnfnXebBDIXJCBMKiowTu1LubZ9EQn7WkgrFD/M7TY+2dr8DOdoq15Pv0EZ2kLO1Gu9y6vOPq+5nAhce/TN/sWGAvfCJJkSYqALBSFh7QkExTJXPM7QHgP++rn96m6/nDe/ND6NwEovwdVqD5KiPnTvzRLkr92QEdZniT6hH2DUrToA==&quot;    }  ]}</code></pre><p>好吧好吧，看到这么多字符先别懵，<code>value</code> 和 <code>signature</code> 字段的内容都是 BASE64 编码过的，解码后 <code>value</code> 字段就是个普通的 JSON 而已。至于 JSON 里是什么内容，就自己去看 wiki 吧。</p><h4 id="4-5-2-数字签名"><a href="#4-5-2-数字签名" class="headerlink" title="4.5.2 数字签名"></a>4.5.2 数字签名</h4><p>需要注意的是上述 Profile 中的 <code>signature</code> 字段。顾名思义，这个字段就是 <code>value</code> 字段的数字签名。虽然官方 API 只有在指定 <code>unsigned=false</code> 时才会返回带签名的 Profile，但是目前（截至本文发布） authlib-injector 在服务端未返回数字签名时会出现<a href="https://github.com/printempw/blessing-skin-server/issues/81" target="_blank" rel="noopener">神秘的错误</a>，所以还是默认返回 <code>signature</code> 字段来得好。</p><p>至于数字签名如何生成，其实就是用的 OpenSSL 内置的签名算法。各个平台都有 OpenSSL 库的实现，我这里贴一下 PHP 的示例代码：</p><pre><code class="php">$privateKeyPath = __DIR__.&#39;/key.pem&#39;;// Load private keyif (! file_exists($privateKeyPath)) {  throw new IllegalArgumentException(&#39;RSA 私钥不存在&#39;);}$privateKeyContent = file_get_contents($privateKeyPath);$key = openssl_pkey_get_private($privateKeyContent);if (! $key) {  throw new IllegalArgumentException(&#39;无效的 RSA 私钥&#39;);}openssl_sign($data, $sign, $key);openssl_free_key($key);return base64_encode($sign);</code></pre><p>其他语言大同小异，我就不多赘述了。</p><h4 id="4-5-3-加载材质"><a href="#4-5-3-加载材质" class="headerlink" title="4.5.3 加载材质"></a>4.5.3 加载材质</h4><p>拿到角色 Profile，并且验证了数字签名后（签名不对的话不会加载的），Minecraft 游戏就会根据 Profile 中指定的皮肤、披风图片 URL 加载材质。需要注意的是，Minecraft 自带的 authlib 是只会加载 Mojang 官方域名下的材质的（白名单之外的材质地址是不会被加载的），这也是为什么需要 CustomSkinLoader 等皮肤 Mod 的原因。不过 <a href="https://github.com/to2mbn/authlib-injector/blob/master/configure.sh" target="_blank" rel="noopener">authlib-injector</a> 自带了对 authlib 的 hack，在配置文件（或者远程配置加载）中直接指定材质加载白名单即可。</p><p>如果一切正常，游戏内就会显示你的自定义皮肤了。</p><h3 id="4-5-加入服务器"><a href="#4-5-加入服务器" class="headerlink" title="4.5 加入服务器"></a>4.5 加入服务器</h3><p>在 Minecraft 中加入一个服务器时，客户端会向 <code>/join</code> API 发出一个请求，请求体中包含了 AccessToken、当前角色的 UUID 以及服务器的唯一标识符 <code>serverId</code>（这玩意如何生成不用我们操心，Minecraft 游戏里会搞好的，你只管存这个就行了）。</p><p>在后端实现上，一般来说就是在 Redis 这类内存数据库中放一个键值对，具体数据结构你自己想。</p><p>向 Yggdrasil API 发送完 <code>join</code> 请求后，Minecraft 客户端会向要加入的那个游戏服务器发送一个请求（这部分我们不用操心），服务器收到加入请求后，会向 Yggdrasil API 发送一个 <code>hasJoined</code> 请求（Query String 中包含角色名、IP 以及服务器唯一标识符），如果该用户已经加入了服务器（也就是判断数据库中有没有之前 <code>join</code> 时添加的记录），那就返回角色的完整 Profile，同时服务器允许用户进入。</p><p>这也就是为什么客户端和服务端同样需要使用 authlib-injector hack 的原因，因为我们要确保两者请求的都是同一个 API，这样才能起到一个维护登录状态的功能。</p><h3 id="4-6-经常用到的-API"><a href="#4-6-经常用到的-API" class="headerlink" title="4.6 经常用到的 API"></a>4.6 经常用到的 API</h3><p>虽然 Yggdrasil 规范中定义了很多 API，但是其实日常游戏中用到的没几个，这里列举一些频繁使用的 API，也方便诸君知道哪里该认真开发哪里可以小小偷懒一下：</p><pre><code># 初次登录时，用账号密码拿到 AccessTokenPOST /authserver/authenticate# 之后的登录都是直接用这个 API 签发新的令牌POST /authserver/refresh# 加入服务器POST /sessionserver/session/minecraft/join# 验证是否加入了服务器GET  /sessionserver/session/minecraft/hasJoined# 获取玩家完整 ProfileGET  /api/profiles/minecraft/{uuid}</code></pre><p>其他 API 感觉都是几万年用不到一次的，很神秘。</p><h2 id="五、后记"><a href="#五、后记" class="headerlink" title="五、后记"></a>五、后记</h2><p>上周折腾了好几天这玩意，写篇博文记录一下，既能理清自己的思路，还有可能帮到后来人<del>（花时间研究了东西，却没人知道，多亏啊）</del>，何乐而不为呢 :P</p><h3 id="5-1-参考链接"><a href="#5-1-参考链接" class="headerlink" title="5.1 参考链接"></a>5.1 参考链接</h3><ul><li><a href="http://wiki.vg/Authentication" target="_blank" rel="noopener">http://wiki.vg/Authentication</a></li><li><a href="http://wiki.vg/Protocol_Encryption#Authentication" target="_blank" rel="noopener">http://wiki.vg/Protocol_Encryption#Authentication</a></li><li><a href="http://wiki.vg/Mojang_API" target="_blank" rel="noopener">http://wiki.vg/Mojang_API</a></li><li><a href="https://github.com/to2mbn/authlib-injector/" target="_blank" rel="noopener">https://github.com/to2mbn/authlib-injector/</a></li><li><a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/通用唯一识别码</a></li><li><a href="http://xbgtalk.biz/2015/11/03/php-rsa-encode-decode-sign/" target="_blank" rel="noopener">php-rsa - 加密解密和签名</a></li><li><a href="blessing-skin-plugins/yggdrasil-api">blessing-skin-plugins/yggdrasil-api</a></li></ul><h3 id="5-2-文章更新日志"><a href="#5-2-文章更新日志" class="headerlink" title="5.2 文章更新日志"></a>5.2 文章更新日志</h3><p>具体的修改可以查看这篇博客在 GitHub 上源码的 <a href="https://github.com/printempw/printempw.github.io/commits/source/source/_posts/minecraft-yggdrasil-api-third-party-implementation.md" target="_blank" rel="noopener">历史提交记录</a>。</p><p><strong>2018-02-22：</strong></p><ul><li>基于最新的 authlib-injector 修改文章</li><li>将具体部署步骤移动至 <a href="https://github.com/printempw/yggdrasil-api" target="_blank" rel="noopener">printempw/yggdrasil-api</a> 页面</li><li>同时也更新了 MCBBS 上的 <a href="http://www.mcbbs.net/thread-718219-1-1.html" target="_blank" rel="noopener">相关帖子</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近给 Blessing Skin 写了个插件，利用皮肤站本身的账号系统实现了 Yggdrasil API（就是 Mojang 的登录 API），然后配合 &lt;a href=&quot;https://github.com/to2mbn/authlib-injector/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;authlib-injector&lt;/a&gt; 这个项目将启动器（基于 Java 编写的支持正版登录的启动器都行）、Minecraft 游戏、Minecraft 服务端中的 Mojang Yggdrasil API 地址给替换成了自己实现的第三方 Yggdrasil API 地址（字节码替换），从而实现了与正版登录功能几乎完全相同的账户鉴权系统。&lt;/p&gt;
&lt;p&gt;通俗地讲，就是我把 Mojang 的正版登录 API 给【劫持】成自己的啦，所以可以像登录正版那样直接用皮肤站的邮箱和密码登录游戏（还支持 Mojang 都不支持的多用户选择哦）。这种外置登录系统的实现应该可以说是比市面上的软件都要完善（毕竟可以直接利用 Minecraft 本身自带的鉴权模块），因此写一篇博文介绍一下这些实现之间的不同之处，顺带记录一下实现 Yggdrasil API 时踩到的坑，算是抛砖引玉了。&lt;/p&gt;
&lt;div class=&quot;alert alert-warning&quot;&gt;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：本文不适合小白及问题解决能力弱的人群阅读。&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;del&gt;感觉我明明好久没玩 MC 了，要玩也都是玩正版服务器，但是却一直在搞这些盗版服用的东西，我真是舍己为人造福大众普惠众生啊（不&lt;/del&gt;&lt;/p&gt;
&lt;h2 id=&quot;一、服务器内置登录插件&quot;&gt;&lt;a href=&quot;#一、服务器内置登录插件&quot; class=&quot;headerlink&quot; title=&quot;一、服务器内置登录插件&quot;&gt;&lt;/a&gt;一、服务器内置登录插件&lt;/h2&gt;&lt;p&gt;相信维护过 Minecraft 服务器（当然，我这边说的是运行在离线模式下的服务器）的腐竹们或多或少都听说过 Authme、CrazyLogin 等登录插件的鼎鼎大名吧。由于这些服务器运作在离线模式（&lt;code&gt;online-mode=false&lt;/code&gt;，即俗称的盗版模式）下，缺少 Mojang 官方账户认证系统的支持，所以必须使用这类插件来进行玩家认证（否则随便谁都可以冒名顶替别人了，换一个登录角色名就行）。&lt;/p&gt;
&lt;p&gt;这类插件的工作原理就是在服务端维护一个数据表，表中每一条记录中存储了角色的「角色名」、「登录密码」、「注册时间」、「登录 IP 地址」等等信息，当玩家初次进入服务器时需要通过这些插件进行注册操作（e.g. &lt;code&gt;/register&lt;/code&gt; 命令）并在表中插入一条记录，注册完毕后进入服务器则需要输入密码（e.g. &lt;code&gt;/login &amp;lt;password&amp;gt;&lt;/code&gt; 命令）来认证。&lt;/p&gt;
&lt;p&gt;其实这样的解决方案也没什么不好，而且现在 Authme 等登录插件在众多的服务器中都还是主流。但是，如果你的服务器已经发展到比较大型了，或许你就比较希望有这样一个东西：&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="PHP" scheme="https://blessing.studio/tag/PHP/"/>
    
      <category term="Minecraft" scheme="https://blessing.studio/tag/Minecraft/"/>
    
      <category term="ACGN" scheme="https://blessing.studio/tag/ACGN/"/>
    
      <category term="教程" scheme="https://blessing.studio/tag/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Laravel 动态添加 Artisan 命令的最佳实践</title>
    <link href="https://blessing.studio/best-practice-of-adding-artisan-commands-dynamically/"/>
    <id>https://blessing.studio/best-practice-of-adding-artisan-commands-dynamically/</id>
    <published>2017-07-30T10:45:50.000Z</published>
    <updated>2017-07-30T10:45:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然 Laravel 官方文档提供的添加 Artisan Command 的方法是直接修改 <code>app/Console/Kernel.php</code> 文件并在 <code>$commands</code> 属性中注册要添加的 Artisan 命名的类名（Laravel 服务容器会自动解析），但是，如果我们出现需要「动态（运行时）添加 Artisan 命令」的需求的话，就会很容易吃瘪。因为，Laravel 的文档（当然，我说的是官网上的）几乎没有提到任何关于这方面的内容。</p><p>这也是我为什么总是吐槽 Laravel 文档有些地方很烂的原因 —— 很多时候你为了实现一个文档里没提到的功能，需要去翻半天 Laravel 的框架源码才能找到解决方法（我博客的 <a href="https://blessing.studio/tag/Laravel/">Laravel 标签</a> 下已经有不少这样的踩坑文了）。虽然 Laravel 框架的源码很优雅，看着也不会难受，但是在一堆文件中跳来跳去寻找逻辑浪费脑细胞的行为还是能省则省吧 :(</p><p>这次要实现的功能是在运行时动态加载自定义的 Artisan Command（更详细一些的需求就是在皮肤站的一个插件中注册 Artisan 命令，Laravel 插件系统的实现可以参考我之前的 <a href="https://blessing.studio/laravel-plugin-system-1/">另一篇文章</a>）。</p><h2 id="TL-DR-太长不看"><a href="#TL-DR-太长不看" class="headerlink" title="TL;DR 太长不看"></a>TL;DR 太长不看</h2><p>总之先上干货，毕竟不是所有人都喜欢听我废话一大堆后才拿到解决方案的。</p><p>Laravel 5.3 及以上：</p><pre><code class="php">Artisan::starting(function ($artisan) {    // 传入类名字符串即可，会被服务容器自动解析    $artisan-&gt;resolve(&#39;Example\FooCommand&#39;);    // 批量添加    $artisan-&gt;resolveCommands([        &#39;Example\FuckCommand&#39;,        &#39;Example\ShitCommand&#39;    ]);    // 参数必须为 Symfony\Component\Console\Command\Command 的实例    // 继承自 Illuminate\Console\Command 的类实例也可以    $artisan-&gt;add($command);});</code></pre><p>Laravel 5.2：</p><pre><code class="php">Event::listen(&#39;Illuminate\Console\Events\ArtisanStarting&#39;, function ($event) {    // 其他用法同上    $event-&gt;artisan-&gt;resolve(&#39;Example\BarCommand&#39;);});</code></pre><a id="more"></a><p>Laravel 5.1：</p><pre><code class="php">Event::listen(&#39;artisan.start&#39;, function ($event) {    // 其他用法同上    $event-&gt;artisan-&gt;resolve(&#39;Example\WtfCommand&#39;);});</code></pre><p>接下来就是我摸索时尝试的步骤，写下来权当记录<del>水博文</del>，发了发牢骚，有兴趣的就继续看下去吧。</p><h2 id="0x01-初步尝试"><a href="#0x01-初步尝试" class="headerlink" title="0x01 初步尝试"></a>0x01 初步尝试</h2><p>既然 Laravel 最常见的注册 Artisan 命令的方式是修改 <code>APP\Console\Kernel</code> 类中的 <code>$commands</code>，那么一般正常人都会从这边开始下手。可以看到，这个类是继承自 <code>Illuminate\Foundation\Console\Kernel</code> 类并覆写了 <code>$commands</code> 属性。让我们稍微看一下这个 <code>$commands</code> 属性用在哪了：</p><pre><code class="php">/** * Get the Artisan application instance. * * @return \Illuminate\Console\Application */protected function getArtisan(){    if (is_null($this-&gt;artisan)) {        return $this-&gt;artisan = (new Artisan($this-&gt;app, $this-&gt;events, $this-&gt;app-&gt;version()))                            -&gt;resolveCommands($this-&gt;commands);    }    return $this-&gt;artisan;}</code></pre><p>可以看到，这个方法用单例模式实例化了一个 Artisan（<code>Artisan</code> 是 <code>Illuminate\Console\Application</code> 的别名），其中最重要的是调用了 <code>Illuminate\Console\Application::resolveCommands</code> 这个方法，并且将那个注册了自定义 Artisan 命令的属性给传了进去。我们跳转到那个 <code>resolveCommands</code> 方法看一看……</p><pre><code class="php">/** * Add a command, resolving through the application. * * @param  string  $command * @return \Symfony\Component\Console\Command\Command */public function resolve($command){    return $this-&gt;add($this-&gt;laravel-&gt;make($command));}/** * Resolve an array of commands through the application. * * @param  array|mixed  $commands * @return $this */public function resolveCommands($commands){    $commands = is_array($commands) ? $commands : func_get_args();    foreach ($commands as $command) {        $this-&gt;resolve($command);    }    return $this;}</code></pre><p>代码条理很清晰，挨个儿把那些 <code>$commands</code> 中的元素给丢进 Laravel 服务容器里实例化之后，调用父类方法 <code>Symfony\Component\Console\Application::add</code> （是的，Laravel 用了很多很多 Symfony 的组件）添加到自身实例中，持引用以供之后的调用所需。</p><p>继续翻看 <code>Illuminate\Foundation\Console\Kernel</code> 的源码，可以看到 Laravel 贴心地开放了一个 <code>registerCommand</code> 方法：</p><pre><code class="php">/** * Register the given command with the console application. * * @param  \Symfony\Component\Console\Command\Command  $command * @return void */public function registerCommand($command){    $this-&gt;getArtisan()-&gt;add($command);}</code></pre><p>那么我们要做的就是，在运行时中拿到 <code>Kernel</code> 的实例，并且通过调用 <code>registerCommand</code> 方法把我们的自定义 Artisan 命令也给加进去。那么我们要怎样才能拿到这个实例呢？</p><p>相信对 Laravel 有所了解的各位都会想到 —— 服务容器。</p><p>通过查阅 Laravel 命令行入口（根目录下的 <code>artisan</code> 文件）源码可以知道，Laravel 就是使用服务容器来实例化 <code>Kernel</code> 的：</p><pre><code class="php">$kernel = $app-&gt;make(Illuminate\Contracts\Console\Kernel::class);</code></pre><p>如果你有心的话，会发现 Laravel 框架的 Web 入口文件（<code>public/index.php</code>）和命令行入口文件中实例化 <code>Kernel</code> 的语句都是一样的，那么为什么通过 Web 访问时解析出来的是 <code>App\Http\Kernel</code> 的实例而通过命令行访问时解析出来的就是 <code>App\Console\Kernel</code> 的实例了呢？</p><p>这里就涉及 Laravel 服务容器的一个强大的核心功能 —— 绑定接口至实现。因为这些实例都实现了相同的接口，所以我们可以使用相同的代码并且很方便地更换接口后的具体实现，这也是使用 IoC 容器的好处之一，有兴趣的多去了解了解吧 :)</p><p>闲话休提，那么我们只要通过服务容器就可以拿到 <code>Kernel</code> 实例了（当然，如果你愿意，你也可以直接通过 <code>$GLOBAL[&#39;kernel&#39;]</code> 来访问全局作用域下定义的那个 <code>$kernel</code> 变量，效果都是一样的，但是太 tmd lowb 了，所以我不愿意用），看起来已经离成功了一大半呢！</p><pre><code class="php">$kernel = app(&#39;Illuminate\Contracts\Console\Kernel&#39;);// 因为 registerCommand 方法只接受 Symfony\Component\Console\Command\Command 的实例作为参数$kernel-&gt;registerCommand(app(&#39;Example\FooCommand&#39;));</code></pre><p>然后我们执行一下 <code>php artisan list</code>，就能看到我们的命令已经出现啦：</p><pre><code>Laravel Framework version 5.2.45Usage:  command [options] [arguments]Available commands:  help           Displays help for a command  list           Lists commands  foo            Example command</code></pre><p>但是等等……Laravel 自带的那些 <code>make</code>、<code>migrate</code> 等命令哪里去了？我最开始出现这个问题的时候还以为是我太早把 <code>Kernel</code> 解析出来了，后来直接使用 <code>$GLOBALS[&#39;kernel&#39;]</code> 也是一样的问题时才认识到问题另有原因。仔细阅读源码后发现 Artisan 命令行在调用（<code>handle</code>、<code>call</code> 等方法）之前都会调用这样一个方法：</p><pre><code class="php">$this-&gt;bootstrap();</code></pre><style>.post-content table, .post-content code { word-wrap: break-word; }</style><p>通过阅读源码可以知道这个 <code>bootstrap</code> 方法就是用来加载 Laravel 框架的基本组件的，包括 <code>Illuminate\Foundation\Providers\ArtisanServiceProvider</code> 这个服务提供者中提供的所有框架内置 Artisan 命令。好在这个方法是 public 的，所以我们只要在 <code>registerCommand</code> 之前调用一下这个方法就可以啦：</p><pre><code class="php">$kernel = app(&#39;Illuminate\Contracts\Console\Kernel&#39;);$kernel-&gt;bootstrap();$kernel-&gt;registerCommand(app(&#39;Example\FooCommand&#39;));</code></pre><p>如果你愿意，你甚至还可以直接使用 <code>Artisan</code> 这个 <code>Facade</code>，因为它就是指向 <code>Illuminate\Contracts\Console\Kernel</code> 的：</p><pre><code class="php">Artisan::bootstrap();Artisan::registerCommand(app(&#39;InsaneProfileCache\Commands\Clean&#39;));</code></pre><p>结果如下：</p><p><img src="https://i.loli.net/2017/07/30/597df1d0e5231.png" alt="Screenshot"></p><h2 id="0x02-继续尝试"><a href="#0x02-继续尝试" class="headerlink" title="0x02 继续尝试"></a>0x02 继续尝试</h2><p>虽然这样确实能够实现我们的需求，但是我觉得这样不行（话说我都不晓得嘻哈梗怎么突然就流行起来了，虽然确实蛮有意思的啦）。</p><p><img src="https://img.blessing.studio/images/2017/07/30/934f97e408371023.png" alt="我觉得不行"></p><p>又要自己取出 <code>Kernel</code> 实例，又要自己调用 <code>bootstrap</code> 方法，调用 <code>registerCommand</code> 方法之前还有自己先把 Command 实例化……这么繁琐，肯定不是运行时添加 Artisan 命令的最佳实践，所以我决定继续寻找更优解。</p><p>虽然我们上面用的方法是取出 <code>Kernel</code> 实例并进行操作的，但是其实该方法里的操作也是基于 <code>getArtisan</code> 所获取的  <code>Illuminate\Console\Application</code> （👈这玩意在 Laravel 源码里经常被 as 为 <code>Artisan</code>）实例进行的。可惜的是这个方法是 <code>protected</code> 的，我们无法直接调用它，所以我们还是先去看这个类的源码吧：</p><pre><code class="php">/** * Create a new Artisan console application. * * @param  \Illuminate\Contracts\Container\Container  $laravel * @param  \Illuminate\Contracts\Events\Dispatcher  $events * @param  string  $version * @return void */public function __construct(Container $laravel, Dispatcher $events, $version){    parent::__construct(&#39;Laravel Framework&#39;, $version);    $this-&gt;laravel = $laravel;    $this-&gt;setAutoExit(false);    $this-&gt;setCatchExceptions(false);    $events-&gt;fire(new Events\ArtisanStarting($this));}</code></pre><p>瞧我发现了什么？Artisan 在实例化之后会触发一个 <code>Illuminate\Console\Events\ArtisanStarting</code> 事件，并且把自身实例给传递过去。那么我们要做的就很简单了：监听该事件，拿到 Artisan 实例，调用 <code>resolve</code> 或 <code>resolveCommands</code> 方法来注册我们的 Artisan 命令即可。</p><p>具体的方法在最上面给出了，我这里就不多说了。另外需要注意的是，Laravel 5.1 版本并没有 <code>ArtisanStarting</code> 这个事件，而是 <code>artisan.start</code>，不过原理都是一样的：</p><pre><code class="php">$events-&gt;fire(&#39;artisan.start&#39;, [$this]);</code></pre><p>另外，在 Laravel 5.3 及以上版本中，Artisan 还贴心地提供了 <code>Artisan::starting</code> 这个方法，和监听事件的效果差不多，不过是直接修改实例的 <code>$bootstrappers</code> 属性的，传递一个闭包进去即可，示例代码见最上方。</p><h2 id="0x03-一些牢骚"><a href="#0x03-一些牢骚" class="headerlink" title="0x03 一些牢骚"></a>0x03 一些牢骚</h2><p>虽然只要看源码就能知道，Laravel 框架很多地方都预留了非常多的接口，让我们可以方便优雅地实现很多自定义功能，这也是我为什么喜欢这个框架的原因之一。</p><p>但是……但是，你的文档就不能写好一点吗！哪怕提一下这些 API 也好啊！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然 Laravel 官方文档提供的添加 Artisan Command 的方法是直接修改 &lt;code&gt;app/Console/Kernel.php&lt;/code&gt; 文件并在 &lt;code&gt;$commands&lt;/code&gt; 属性中注册要添加的 Artisan 命名的类名（Laravel 服务容器会自动解析），但是，如果我们出现需要「动态（运行时）添加 Artisan 命令」的需求的话，就会很容易吃瘪。因为，Laravel 的文档（当然，我说的是官网上的）几乎没有提到任何关于这方面的内容。&lt;/p&gt;
&lt;p&gt;这也是我为什么总是吐槽 Laravel 文档有些地方很烂的原因 —— 很多时候你为了实现一个文档里没提到的功能，需要去翻半天 Laravel 的框架源码才能找到解决方法（我博客的 &lt;a href=&quot;https://blessing.studio/tag/Laravel/&quot;&gt;Laravel 标签&lt;/a&gt; 下已经有不少这样的踩坑文了）。虽然 Laravel 框架的源码很优雅，看着也不会难受，但是在一堆文件中跳来跳去寻找逻辑浪费脑细胞的行为还是能省则省吧 :(&lt;/p&gt;
&lt;p&gt;这次要实现的功能是在运行时动态加载自定义的 Artisan Command（更详细一些的需求就是在皮肤站的一个插件中注册 Artisan 命令，Laravel 插件系统的实现可以参考我之前的 &lt;a href=&quot;https://blessing.studio/laravel-plugin-system-1/&quot;&gt;另一篇文章&lt;/a&gt;）。&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-太长不看&quot;&gt;&lt;a href=&quot;#TL-DR-太长不看&quot; class=&quot;headerlink&quot; title=&quot;TL;DR 太长不看&quot;&gt;&lt;/a&gt;TL;DR 太长不看&lt;/h2&gt;&lt;p&gt;总之先上干货，毕竟不是所有人都喜欢听我废话一大堆后才拿到解决方案的。&lt;/p&gt;
&lt;p&gt;Laravel 5.3 及以上：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;Artisan::starting(function ($artisan) {
    // 传入类名字符串即可，会被服务容器自动解析
    $artisan-&amp;gt;resolve(&amp;#39;Example\FooCommand&amp;#39;);
    // 批量添加
    $artisan-&amp;gt;resolveCommands([
        &amp;#39;Example\FuckCommand&amp;#39;,
        &amp;#39;Example\ShitCommand&amp;#39;
    ]);
    // 参数必须为 Symfony\Component\Console\Command\Command 的实例
    // 继承自 Illuminate\Console\Command 的类实例也可以
    $artisan-&amp;gt;add($command);
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Laravel 5.2：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;php&quot;&gt;Event::listen(&amp;#39;Illuminate\Console\Events\ArtisanStarting&amp;#39;, function ($event) {
    // 其他用法同上
    $event-&amp;gt;artisan-&amp;gt;resolve(&amp;#39;Example\BarCommand&amp;#39;);
});
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="Laravel" scheme="https://blessing.studio/tag/Laravel/"/>
    
      <category term="PHP" scheme="https://blessing.studio/tag/PHP/"/>
    
  </entry>
  
  <entry>
    <title>饥荒联机版独立服务器搭建踩坑记录</title>
    <link href="https://blessing.studio/deploy-dont-starve-together-dedicated-server/"/>
    <id>https://blessing.studio/deploy-dont-starve-together-dedicated-server/</id>
    <published>2017-07-15T09:54:24.000Z</published>
    <updated>2017-07-15T09:54:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近和几个同学一起联机玩饥荒（Don’t Starve Together），虽然饥荒游戏本身就可以直接创建房间让别人加入，但还是有诸多不便驱使我去开一个饥荒的独立服务端（Dedicated Server），其中最主要的就是 ——「<strong>你退了游戏其他人就玩不了了</strong>」。</p><p>本来家里还有一个用旧主板和以前换下的配件攒成的二奶机，安装的是 Elementary OS，确实可以拿来跑饥荒服务器（以前还拿它跑过 MC 服务器），但是不幸的是，由于我直接把主板硬盘之类的一股脑塞在牛奶盒子里放在窗边还不加盖儿，一个雨后的下午，我推开家门后发现那个被我当做机箱的牛奶盒子已经开始积水了……前略，天国的 Pegatron IPX31-GS (・_ゝ・)</p><p>直接在主力机上开一个服务器也不是不行，但是我的奔腾 G3258 选手实在是带不动饥荒游戏 + 游戏服务器 + 其他杂七杂八的东西了，所以只好另觅他方，去搞一台 VPS 来开服。而且这里不得不吐槽一下，饥荒联机版独立服务器的配置要求还是比较高的，几个人的小服，再多开几个 Mod，最起码就要 1G 的内存（我那台阿里云宕机好几次，还得去网页控制台强制重启），更不要想开洞穴了。</p><p>现在我拿来开服的是免费试用一个月的京东云（Xeon-E5，2G DDR4，1Mbps 的带宽），不开洞穴，目前看起来还是没什么压力的，延迟丢包率什么的也都可以接受。网上关于开服的教程也不少了，这篇文章也不会过多赘述，差不多就是记录一下主要步骤，以及提一下可能会遇到的坑。所以，想要那种很详细的教程的同学还是绕道吧，或者翻到文章最下面的「参考链接」看看。</p><p>下面的步骤在 64 位 CentOS 7.3 和 Ubuntu 16.04 上测试通过，至于 Windows……我认为实在没有啥必要特别去写，直接从 Steam 客户端就可以打开，操作方便，也没啥坑，看看网上那些教程就可以了。继续阅读之前，我希望你能有一些 Linux 的操作基础，不然会很懵。</p><h2 id="0x01-事前准备"><a href="#0x01-事前准备" class="headerlink" title="0x01 事前准备"></a>0x01 事前准备</h2><p>首先你要有一台装了 Linux 的服务器，配置要求如下（摘自 <a href="http://dontstarve.wikia.com/wiki/Don%E2%80%99t_Starve_Together_Dedicated_Servers" target="_blank" rel="noopener">DST Wiki</a>）：</p><ul><li>上行带宽：8KBps 一个玩家；</li><li>内存：差不多一个玩家 65Mbytes；</li><li>CPU：没太大要求</li></ul><p>需要注意的是，饥荒联机版的服务器对内存的要求其实挺大的，亲测只开 Overworld 不开洞穴，空载 RAM 占用约 800MB，再加上差不多 65MB 一个玩家，开 Mod 还会占用更多，所以还是要衡量一下机器的配置。</p><a id="more"></a><p>然后是喜闻乐见的依赖安装环节：</p><pre><code class="shell"># Ubuntu/Debian 32 位$ sudo apt-get -y install libgcc1 libcurl4-gnutls-dev# Ubuntu/Debian 64 位$ sudo apt-get -y install lib32gcc1 libcurl4-gnutls-dev:i386# RedHat/CentOS 32 位$ sudo yum -y install glibc libstdc++ libcurl4-gnutls-dev# RedHat/CentOS 64 位$ sudo yum -y install glibc.i686 libstdc++.i686 libcurl4-gnutls-dev.i686</code></pre><p>有些源里可能没有 libcurl4-gnutls-dev，那直接安装 <code>libcurl</code> 然后做个软链接也是可以的：</p><pre><code class="shell">$ cd /usr/lib/$ ln -s libcurl.so.4 libcurl-gnutls.so.4</code></pre><h2 id="0x02-安装-SteamCMD"><a href="#0x02-安装-SteamCMD" class="headerlink" title="0x02 安装 SteamCMD"></a>0x02 安装 SteamCMD</h2><p>SteamCMD，顾名思义，就是 Steam 的命令行版本。虽然饥荒服务器本身并不需要用 Steam 进行验证啊之类的，但我们还是得用它来把服务器更新到最新版本，不然其他人是进不来的。</p><p>我们最好新建一个用户来运行 SteamCMD，如果直接用 root 用户运行游戏服务端的话可能会导致严重的安全隐患。在 root 权限下使用以下命令来创建一个新用户：</p><pre><code class="shell">$ useradd -m steam$ su - steam</code></pre><p>然后在你喜欢的地方创建一个为 SteamCMD 准备的目录：</p><pre><code class="shell">$ mkdir ~/steamcmd &amp;&amp; cd ~/steamcmd</code></pre><p>下载并解压 Linux 专用的 SteamCMD：</p><pre><code class="shell">$ wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz$ tar -xvzf steamcmd_linux.tar.gz</code></pre><p>运行 SteamCMD：</p><pre><code class="shell">$ ./steamcmd.sh</code></pre><p>登录安装退出一气呵成：</p><pre><code># 匿名登录，没必要用用户名密码登录login anonymous# 这里我们强制要 Steam 把饥荒服务端安装到此目录下# 最好用绝对路径，否则可能会安装到奇怪的地方去force_install_dir /home/steam/dstserverapp_update 343050 validatequit</code></pre><p><img src="https://i.loli.net/2017/07/15/596a251199343.png" alt="SteamCMD 截图"></p><p>等进度跑完，饥荒服务端就已经安装在指定位置了：</p><p><img src="https://img.blessing.studio/images/2017/07/15/snipaste_20170715_222348.png" alt="dstserver 截图"></p><p>另外，SteamCMD 也是可以用 apt、yum 之类的包管理器来安装的，如果你的源里有的话（阿里云的镜像源里是有的，Debian 的话还得在源里加上 non-free area）。直接用包管理器安装的话 SteamCMD 可执行文件是安装到 <code>/usr/games</code> 目录下的，可以软链接到方便的地方去：</p><pre><code class="shell">$ ln -s /usr/games/steamcmd ~/steamcmd</code></pre><p>用法和上面的 <code>steamcmd.sh</code> 是一样的。</p><h2 id="0x03-运行饥荒服务端"><a href="#0x03-运行饥荒服务端" class="headerlink" title="0x03 运行饥荒服务端"></a>0x03 运行饥荒服务端</h2><p>如果上面 SteamCMD 里没有用 <code>force_install_dir</code> 强制指定安装目录的话，服务端默认是安装到 <code>~/Steam/steamapps/common/Don&#39;t Starve Together Dedicated Server</code> 目录下的。我们先进去运行一下服务端，确保依赖之类的配置正确：</p><pre><code class="shell">$ cd ~/dstserver/bin$ ./dontstarve_dedicated_server_nullrenderer</code></pre><p>有可能会报这样的错：</p><pre><code>error while loading shared libraries: libcurl-gnutls.so.4: cannot open shared object file: No such file or directory</code></pre><p>这说明你 libcurl-gnutls 依赖没安装或者没配置好，可参照上面的「事前准备」安装依赖。</p><p>注意，<strong>千万不要</strong> 在其他目录下使用类似 <code>./bin/dontstarve_dedicated_server_nullrenderer</code> 的命令来运行服务端，否则你会得到类似这样的找不到 <code>scripts/main.lua</code> 文件的报错信息：</p><pre><code>[00:00:00]: Starting Up...[00:00:00]: DoLuaFile scripts/main.lua[00:00:00]: DoLuaFile Could not load lua file scripts/main.lua[00:00:00]: Error loading main.lua...[00:00:00]: Shutting down</code></pre><p>我估计是相对路径的锅，害我在这个报错上疯狂找资料卡了半小时，说不出话。</p><p>另外注意开放 VPS 的 10999 端口（或者你的自定义端口）的 UDP 访问（iptables、firewalld、主机商的防火墙 etc.）。接下来的服务器配置之类的我就不多说了。</p><p>如果以后要升级服务端的话，直接再重复一遍上面 SteamCMD 安装的步骤就可以了，也可以直接一句话解决：</p><pre><code class="shell">$ ./steamcmd.sh +login anonymous +force_install_dir ~/dst +app_update 343050 validate +quit</code></pre><h2 id="0x04-服务端配置"><a href="#0x04-服务端配置" class="headerlink" title="0x04 服务端配置"></a>0x04 服务端配置</h2><p><style>.post-content table, .post-content code { word-wrap: break-word; }</style><br>虽然我们上面直接运行了 <code>dontstarve_dedicated_server_nullrenderer</code>，但是这个程序还是有其他的启动参数的。主要参数如下：</p><table><thead><tr><th>参数</th><th>用法</th></tr></thead><tbody><tr><td>-persistent_storage_root</td><td>指定存档根目录的位置，必须是绝对目录。默认为 <code>~/.klei</code>。</td></tr><tr><td>-conf_dir</td><td>指定配置文件的目录名。默认为 <code>DoNotStarveTogether</code>，和上一个参数拼在一起就是你存档的完整位置了，默认为 <code>~/.klei/DoNotStarveTogether</code>，所有的存档都在这里。</td></tr><tr><td>-cluster</td><td>指定启动的世界，默认为 <code>Cluster_1</code>。服务端启动时会去找 <code>&lt;persistent_storage_root&gt;/&lt;conf_dir&gt;/&lt;cluster&gt;</code> 目录下的 <code>cluster.ini</code> 这个配置文件，你的世界名称、密码、游戏模式之类的都是在这里配置的（网上有些教程里用的 <code>setting.ini</code>，那个是旧版的）。同理，你的存档文件夹也可以不使用类似 <code>Cluster_X</code> 的名字，改成其他什么乱七八糟的都可以，只要启动时指定本参数就行了。</td></tr><tr><td>-shard</td><td>默认为 <code>Master</code>，启动时将此参数指定为 <code>Cave</code> 就可以启动洞穴服务器。</td></tr></tbody></table><p>其他的参数我就不一一说明了，具体的参数列表可以在<a href="http://forums.kleientertainment.com/topic/64743-dedicated-server-command-line-options-guide/" target="_blank" rel="noopener">这里</a>查看。举个栗子：</p><pre><code class="shell"># 同时启动主世界服务器和洞穴服务器$ ./dontstarve_dedicated_server_nullrenderer -console -cluster MyClusterName -shard Master$ ./dontstarve_dedicated_server_nullrenderer -console -cluster MyClusterName -shard Caves</code></pre><p>游戏服务端会读取这些文件中的配置：</p><pre><code># 如果你用了 -persistent_storage_root 和 -conf_dir 指定了另外的目录# 那游戏就会去 &lt;persistent_storage_root&gt;/&lt;conf_dir&gt;/&lt;cluster&gt; 下查找这些文件# 如果没指定，默认如下：~/.klei/DoNotStarveTogether/MyClusterName/cluster.ini~/.klei/DoNotStarveTogether/MyClusterName/Master/server.ini~/.klei/DoNotStarveTogether/MyClusterName/Caves/server.ini</code></pre><p>至于如何在 <code>cluster_token.txt</code> 中填入你的 Token，以及 <code>cluster.ini</code> 和 <code>server.ini</code> 的内容之类的，我这里也不多说，具体可参照下面的「参考链接」。</p><h2 id="0x05-Mod-安装"><a href="#0x05-Mod-安装" class="headerlink" title="0x05 Mod 安装"></a>0x05 Mod 安装</h2><p>给饥荒联机版服务器添加 Mod 主要分两步。</p><p><strong>第一步</strong>，让服务器知道我们要用到什么，这样游戏运行时就会自动帮我们下载并安装这些 Mod（如果没有下载的话），并更新到最新版本。首先进入你服务器安装目录下的 <code>mods</code> 文件夹：</p><pre><code class="shell">$ cd /home/steam/dstserver/mods</code></pre><p>打开 <code>dedicated_server_mods_setup.lua</code> 文件，添加如下内容：</p><pre><code>ServerModSetup(&quot;758532836&quot;)</code></pre><p>其中那一串数字就是 Mod 在 Steam 创意工坊里的 ID（地址栏上就有），至于怎么获取，就看你的了。注意，每一个 Mod 都要用这样的格式在该文件中添加一行，所以最后添加完毕的画风应该是这样的：</p><p><img src="https://i.loli.net/2017/07/16/596b0d54cc5ed.png" alt="Mod List"></p><p>从这个文件的注释里你也能知道（如果你看得懂洋文的话），我们还可以直接在这个文件中使用类似 <code>ServerModCollectionSetup(&quot;ID&quot;)</code> 的格式来订阅合集中的所有 Mod，方便不少。</p><p><strong>第二步</strong>，启用 Mod。安装 Mod 之后，我们还需要配置一下每个存档对应要启用什么 Mod。</p><pre><code class="shell"># 如果你用启动参数把存档位置改到其他位置的话，就进去你自定义存档位置下的 Master 目录$ cd ~/.klei/DoNotStarveTogether/Cluster_1/Master</code></pre><p>然后编辑 <code>modoverrides.lua</code> 文件，填入以下内容：</p><pre><code class="lua">return {  [&quot;workshop-797304209&quot;]={ configuration_options={  }, enabled=true },  [&quot;workshop-806984122&quot;]={ configuration_options={  }, enabled=true },  [&quot;workshop-758532836&quot;]={    configuration_options={      AUTOPAUSECONSOLE=false,      AUTOPAUSEMAP=false,      AUTOPAUSESINGLEPLAYERONLY=true,      ENABLECLIENTPAUSE=false,      ENABLEHOTKEY=false,      KEYBOARDTOGGLEKEY=&quot;P&quot;     },    enabled=true   }}</code></pre><p>如果你懂一点 Lua 语法的话修改起来会比较得心应手。其中 <code>[&quot;workshop-758532836&quot;]</code> 就是 ID 为 <code>758532836</code> 的 Mod，<code>enabled=true</code> 表示启用该 Mod，<code>configuration_options = {}</code> 里的就是 Mod 的配置，具体可以去 Mod 的 <code>modinfo.lua</code> 文件里查阅。</p><p>但是，这是一个很麻烦的过程，所以我们可以用一些取巧的办法完成 Mod 的配置。</p><p><img src="https://i.loli.net/2017/07/16/596b1269ce00a.png" alt="可视化配置"></p><p>首先我们去 Steam 客户端里打开饥荒联机版的游戏，然后创建一个世界，把那些「你想要在服务器里启用的 Mod」都给启用了，并且直接在游戏的「Mod 配置」页面里配置好（有可视化界面，配置很方便），配置完毕后进入世界再退掉。这时候进去你的存档位置（比如：<code>Documents\Klei\DoNotStarveTogether\Cluster_3\Master</code>），把你本地的 <code>modoverrides.lua</code> 文件内容上传到服务器里就好了。</p><p>不然直接在文件里配置真的很痛苦，真的。</p><h2 id="0x06-存档迁移"><a href="#0x06-存档迁移" class="headerlink" title="0x06 存档迁移"></a>0x06 存档迁移</h2><p>另开新档的可以不用看了，这节主要是讲怎样把电脑 Steam 客户端里的饥荒联机版存档放到服务器里跑。</p><p>饥荒客户端的存档位置如下：</p><pre><code># WindowsDocuments\Klei\DoNotStarveTogether# Linux~/.klei/DoNotStarveTogether# MacOS~/Documents/Klei/DoNotStarveTogether</code></pre><p>接下来需要注意的是，你直接在饥荒联机版客户端里开的世界，如果没有开洞穴的话，存档是在 <code>client_save</code> 目录下的；只有当你开启了洞穴时，世界存档才会在 <code>Cluster_X</code> 目录下（X 就是世界在游戏中「创建世界」里对应的位置）。曾经我就因为备份错目录，当后来被删档想要回档时，发现以前备份的都是无效文件。我相信你不会想要碰到这种情况的🌚</p><p><img src="https://img.blessing.studio/images/2017/07/16/snipaste_20170716_140614.png" alt="存档"></p><p>那么 <code>Cluster_X</code> 里的内容和 <code>client_save</code> 里的有啥不一样呢？其实只要观察一下就能发现 <code>client_save</code> 里的目录结构是和 <code>Cluster_X/Master/save</code> 目录是一样的。如果你原来客户端里的存档就是开了洞穴的，那么直接把对应 <code>Cluster_X</code> 里的内容上传到服务端对应的目录下就 OK 了。如果不是，那也不会很麻烦：</p><p>首先，你可以先运行一下饥荒服务端，这样服务端就会自动帮你生成一个完整的存档目录（目录结构什么的都是完整的，就不用你自己去一个一个新建了），然后把 <code>client_save</code> 里的文件一股脑上传至 <code>YourClusterName/Master/save</code> 里面去就好了。</p><p>如果你想要自己建立存档目录，那么主要需要建立这几个目录及文件：</p><pre><code class="shell">$ tree.├── Caves # 如果你想要开洞穴的话│   └── server.ini├── cluster.ini├── cluster_token.txt└── Master    ├── modoverrides.lua    └── server.ini</code></pre><p>配置文件的内容可参考饥荒论坛的文档或下方「参考链接」。</p><h2 id="0x07-参考链接"><a href="#0x07-参考链接" class="headerlink" title="0x07 参考链接"></a>0x07 参考链接</h2><ul><li><a href="http://steamcommunity.com/sharedfiles/filedetails/?id=687261496" target="_blank" rel="noopener">从 steam 客户端建房 到 linux 建立服务器</a></li><li><a href="http://steamcommunity.com/sharedfiles/filedetails/?id=382584094" target="_blank" rel="noopener">DST Dedicated Server 服务器配置教程</a> 👈这篇的内容有些过期了</li><li><a href="https://www.nevermoe.com/?p=695" target="_blank" rel="noopener">Don’t Starve Together（饥荒）服务器搭建</a></li><li><a href="http://dontstarve.wikia.com/wiki/Don%E2%80%99t_Starve_Together_Dedicated_Servers" target="_blank" rel="noopener">Guides/Don’t Starve Together Dedicated Servers</a> 👈DST Wiki</li><li><a href="https://www.linode.com/docs/game-servers/install-dont-starve-together-game-server-on-ubuntu" target="_blank" rel="noopener">Install Don’t Starve Together Game Server on Ubuntu 14.04</a></li><li><a href="http://steamcommunity.com/sharedfiles/filedetails/?id=590565473" target="_blank" rel="noopener">How to setup dedicated server with cave on Linux</a> 👈洋文，很详尽，推荐</li><li><a href="http://blog.ttionya.com/article-1235.html" target="_blank" rel="noopener">饥荒联机独立服务器搭建教程（三）：配置篇</a> 👈不知道配置文件怎么填的看这个</li><li><a href="http://forums.kleientertainment.com/topic/64743-dedicated-server-command-line-options-guide/" target="_blank" rel="noopener">Dedicated Server Command Line Options Guide</a></li></ul><p><img src="https://img.blessing.studio/images/2017/07/16/QQ20170714161422.png" alt="小偷背包"></p><p>最后，祝诸君游戏愉快 ;)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近和几个同学一起联机玩饥荒（Don’t Starve Together），虽然饥荒游戏本身就可以直接创建房间让别人加入，但还是有诸多不便驱使我去开一个饥荒的独立服务端（Dedicated Server），其中最主要的就是 ——「&lt;strong&gt;你退了游戏其他人就玩不了了&lt;/strong&gt;」。&lt;/p&gt;
&lt;p&gt;本来家里还有一个用旧主板和以前换下的配件攒成的二奶机，安装的是 Elementary OS，确实可以拿来跑饥荒服务器（以前还拿它跑过 MC 服务器），但是不幸的是，由于我直接把主板硬盘之类的一股脑塞在牛奶盒子里放在窗边还不加盖儿，一个雨后的下午，我推开家门后发现那个被我当做机箱的牛奶盒子已经开始积水了……前略，天国的 Pegatron IPX31-GS (・_ゝ・)&lt;/p&gt;
&lt;p&gt;直接在主力机上开一个服务器也不是不行，但是我的奔腾 G3258 选手实在是带不动饥荒游戏 + 游戏服务器 + 其他杂七杂八的东西了，所以只好另觅他方，去搞一台 VPS 来开服。而且这里不得不吐槽一下，饥荒联机版独立服务器的配置要求还是比较高的，几个人的小服，再多开几个 Mod，最起码就要 1G 的内存（我那台阿里云宕机好几次，还得去网页控制台强制重启），更不要想开洞穴了。&lt;/p&gt;
&lt;p&gt;现在我拿来开服的是免费试用一个月的京东云（Xeon-E5，2G DDR4，1Mbps 的带宽），不开洞穴，目前看起来还是没什么压力的，延迟丢包率什么的也都可以接受。网上关于开服的教程也不少了，这篇文章也不会过多赘述，差不多就是记录一下主要步骤，以及提一下可能会遇到的坑。所以，想要那种很详细的教程的同学还是绕道吧，或者翻到文章最下面的「参考链接」看看。&lt;/p&gt;
&lt;p&gt;下面的步骤在 64 位 CentOS 7.3 和 Ubuntu 16.04 上测试通过，至于 Windows……我认为实在没有啥必要特别去写，直接从 Steam 客户端就可以打开，操作方便，也没啥坑，看看网上那些教程就可以了。继续阅读之前，我希望你能有一些 Linux 的操作基础，不然会很懵。&lt;/p&gt;
&lt;h2 id=&quot;0x01-事前准备&quot;&gt;&lt;a href=&quot;#0x01-事前准备&quot; class=&quot;headerlink&quot; title=&quot;0x01 事前准备&quot;&gt;&lt;/a&gt;0x01 事前准备&lt;/h2&gt;&lt;p&gt;首先你要有一台装了 Linux 的服务器，配置要求如下（摘自 &lt;a href=&quot;http://dontstarve.wikia.com/wiki/Don%E2%80%99t_Starve_Together_Dedicated_Servers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;DST Wiki&lt;/a&gt;）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上行带宽：8KBps 一个玩家；&lt;/li&gt;
&lt;li&gt;内存：差不多一个玩家 65Mbytes；&lt;/li&gt;
&lt;li&gt;CPU：没太大要求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;需要注意的是，饥荒联机版的服务器对内存的要求其实挺大的，亲测只开 Overworld 不开洞穴，空载 RAM 占用约 800MB，再加上差不多 65MB 一个玩家，开 Mod 还会占用更多，所以还是要衡量一下机器的配置。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="ACGN" scheme="https://blessing.studio/tag/ACGN/"/>
    
      <category term="Linux" scheme="https://blessing.studio/tag/Linux/"/>
    
  </entry>
  
  <entry>
    <title>我 TMD 到底要怎样才能在生产环境中用上 ES6 模块化？</title>
    <link href="https://blessing.studio/how-could-i-use-es6-modules-in-production/"/>
    <id>https://blessing.studio/how-could-i-use-es6-modules-in-production/</id>
    <published>2017-07-06T08:57:23.000Z</published>
    <updated>2017-07-06T08:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>Python3 已经发布了九年了，Python 社区却还在用 Python 2.7；而 JavaScript 社区正好相反，大家都已经开始把还没有实现的语言特性用到生产环境中了 (´_ゝ `)</p><p>虽然这种奇妙情况的形成与 JavaScript 自身早期的设计缺陷以及浏览器平台的特殊性质都有关系，但也确实能够体现出 JavaScript 社区的技术栈迭代是有多么屌快。如果你昏迷个一年半载再去看前端圈，可能社区的主流技术栈已经变得它妈都不认识了（如果你没什么实感，可以看看<a href="https://zhuanlan.zhihu.com/p/22782487" target="_blank" rel="noopener">《在 2016 年学习 JavaScript 是一种怎样的体验》</a>这篇文章，你会感受到的，你会的）。</p><h2 id="JavaScript-模块化现状"><a href="#JavaScript-模块化现状" class="headerlink" title="JavaScript 模块化现状"></a>JavaScript 模块化现状</h2><p>随着 JavaScript 越来越广泛的应用，朝着单页应用（SPA）方向发展的网页与代码量的愈发庞大，社区需要一种更好的代码组织形式，这就是模块化：将你的一大坨代码分装为多个不同的模块。</p><p>但是在 ES6 标准出台之前，由于标准的缺失（连 CSS 都有 <code>@import</code>，JavaScript 却连个毛线都没），这几年里 JavaScript 社区里冒出了各种各样的模块化解决方案<del>（群魔乱舞）</del>，懵到一种极致。主要的几种模块化方案举例如下：</p><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><p>主要用于服务端，模块同步加载（也因此不适合在浏览器中运行，不过也有 <code>Browserify</code> 之类的转换工具），Node.js 的模块化实现就是基于 CommonJS 规范的，通常用法像这样：</p><a id="more"></a><pre><code class="javascript">// index.jsconst {bullshit} = require(&#39;./bullshit&#39;);console.log(bullshit());// bullshit.jsfunction someBullshit() {  return &quot;hafu hafu&quot;;}modules.export = {  bullshit: someBullshit};</code></pre><p>而且 <code>require()</code> 是动态加载模块的，完全就是模块中 <code>modules.export</code> 变量的传送门，这也就意味着更好的灵活性（按条件加载模块，参数可为表达式 etc.）。</p><h3 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h3><p>即异步模块定义（Asynchronous Module Definition），<del>不是那个日常翻身的农企啦</del>。</p><p>主要用于浏览器端，模块异步加载（还是用的回调函数），可以给模块注入依赖、动态加载代码块等。具体实现有 RequireJS，代码大概长这样：</p><pre><code class="javascript">// index.jsrequire([&#39;bullshit&#39;], words =&gt; {  console.log(words.bullshit());});// bullshit.jsdefine(&#39;bullshit&#39;, [&#39;dep1&#39;, &#39;dep2&#39;], (dep1, dep2) =&gt; {  function someBullshit() {    return &quot;hafu hafu&quot;;  }  return { bullshit: someBullshit };});</code></pre><p>可惜不能在 Node.js 中直接使用，而且模块定义与加载也比较冗长。</p><h3 id="ES6-Module🚀"><a href="#ES6-Module🚀" class="headerlink" title="ES6 Module🚀"></a>ES6 Module🚀</h3><p>在 ES6 模块标准出来之前，主要的模块化方案就是上述 CommonJS 和 AMD 两种了，一种用于服务器，一种用于浏览器。其他的规范还有：</p><ul><li>最古老的 IIFE（立即执行函数）；</li><li>CMD（Common Module Definition，和 AMD 挺像的，可以参考：<a href="https://github.com/seajs/seajs/issues/277" target="_blank" rel="noopener">与 RequireJS 的异同</a>）；</li><li>UMD（Universal Module Definition，兼容 AMD 和 CommonJS 的语法糖规范）；</li></ul><p>等等，这里就按下不表。</p><p>ES6 的模块化代码大概长这样：</p><pre><code class="javascript">// index.jsimport {bullshit} from &#39;./bullshit&#39;;console.log(bullshit());// bullshit.jsfunction someBullshit() {  return &quot;hafu hafu&quot;;}export {  someBullshit as bullshit};</code></pre><p>那我们为啥应该使用 ES6 的模块化规范呢？</p><ul><li>这是 ECMAScript 官方标准（嗯）；</li><li>语义化的语法，清晰明了，同时支持服务器端和浏览器；</li><li>静态 / 编译时加载（与上面俩规范的动态 / 运行时加载不同），可以做静态优化（比如下面提到的 tree-shaking），加载效率高（不过相应地灵活性也降低了，期待 <a href="https://github.com/tc39/proposal-dynamic-import" target="_blank" rel="noopener"><code>import()</code></a> 也成为规范）；</li><li>输出的是值的引用，可动态修改；</li></ul><p>嗯，你说的都对，那我tm到底要怎样才能在生产环境中用上 ES6 的模块化特性呢？</p><p>很遗憾，你永远无法控制用户的浏览器版本，可能要等上一万年，你才能直接在生产环境中写 ES6 而不用提心吊胆地担心兼容性问题。因此，你还是需要各种各样杂七杂八的工具来转换你的代码：Babel、Webpack、Browserify、Gulp、Rollup.js、System.js ……</p><p>噢，我可去你妈的吧，这些东西都tm是干嘛的？我就是想用个模块化，我到底该用啥子？</p><p><img src="https://img.blessing.studio/images/2017/07/06/QQ20170706155858.jpg" alt="我可去你妈的吧"></p><p>本文正旨在列出几种可用的在生产环境中放心使用 ES6 模块化的方法，希望能帮到诸位后来者（这方面的中文资源实在是忒少了）。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>想要开心地写 ES6 的模块化代码，首先你需要一个转译器（Transpiler）来把你的 ES6 代码转换成大部分浏览器都支持的 ES5 代码。这里我们就选用最多人用的 Babel（我不久之前才知道原来 Babel 就是巴别塔里的「巴别」……）。</p><p>用了 Babel 后，我们的 ES6 模块化代码会被转换为 ES5 + CommonJS 模块规范的代码，这倒也没什么，毕竟我们写的还是 ES6 的模块，至于编译生成的结果，管它是个什么屌东西呢（笑）</p><p>所以我们需要另外一个打包工具来将我们的模块依赖给打包成一个 bundle 文件。目前来说，依赖打包应该是最好的方法了。不然，你也可以等上一万年，等你的用户把浏览器升级到全部支持 HTTP/2（支持连接复用后模块不打包反而比较好）以及 <code>&lt;script type=&quot;module&quot; src=&quot;fuck.js&quot;&gt;</code> 定义 ( ﾟ∀。)</p><p>所以我们整个工具链应该是这样的：</p><p><img src="https://img.blessing.studio/images/2017/07/06/snipaste_20170706_104001.png" alt="处理流程"></p><p>而目前来看，主要可用的模块打包工具有这么几个：</p><ul><li>Browserify</li><li>Webpack</li><li>Rollup.js</li></ul><p>本来我还想讲一下 FIS3 的，结果去看了一下，人家竟然还没原生的支持 ES6 Modules，而且 <code>fis3-hook-commonjs</code> 插件也几万年没更新了，所以还是算了吧。至于 SystemJS 这类动态模块加载器本文也不会涉及，就像我上面说的一样，在目前这个时间点上还是先用模块打包工具比较好。</p><p>下面分别介绍这几个工具以及如何使用它们配合 Babel 实现 ES6 模块转译。</p><h2 id="Browserify"><a href="#Browserify" class="headerlink" title="Browserify"></a>Browserify</h2><p>Browserify 这个工具也是有些年头了，它通过打包所有的依赖来让你能够在浏览器中使用 CommonJS 的语法来 <code>require(&#39;modules&#39;)</code>，这样你就可以像在 Node.js 中一样在浏览器中使用 npm 包了，可以爽到。</p><p><img src="https://img.blessing.studio/images/2017/07/06/browserify.png" class="head-img" title="而且我也很喜欢 Browserify 这个 LOGO"></p><p>既然 Babel 会把我们的 ES6 Modules 语法转换成 ES5 + CommonJS 规范的模块语法，那我们就可以直接用 Browserify 来解析 Babel 的转译生成物，然后把所有的依赖给打包成一个文件，岂不是美滋滋。</p><p>不过除了 Babel 和 Browserify 这俩工具外，我们还需要一个叫做 <code>babelify</code> 的东西……好吧好吧，这是最后一个了，真的。</p><p>那么，babelify 是拿来干嘛的呢？因为 Browserify 只看得懂 CommonJS 的模块代码，所以我们得把 ES6 模块代码转换成 CommonJS 规范的，再拿给 Browserify 去看：这一步就是 Babel 要干的事情了。但是 Browserify 人家是个模块打包工具啊，它是要去分析 AST（抽象语法树），把那些 <code>reuqire()</code> 的依赖文件给找出来再帮你打包的，你总不能把所有的源文件都给 Babel 转译了再交给 Browserify 吧？那太蠢了，我的朋友。</p><p><code>babelify</code> (Browserify transform for Babel) 要做的事情，就是在所有 ES6 文件拿给 Browserify 看之前，先把它用 Babel 给转译一下（<code>browserify().transform</code>），这样 Browserify 就可以直接看得懂并打包依赖，避免了要用 Babel 先转译一万个文件的尴尬局面。</p><p>好吧，那我们要怎样把这些工具捣鼓成一个完整的工具链呢？下面就是喜闻乐见的依赖包安装环节：</p><pre><code class="shell"># 我用的 yarn，你用 npm 也差不多# gulp 也可以全局安装，方便一点# babel-preset 记得选适合自己的# 最后那俩是用来配合 gulp stream 的$ yarn add --dev babel-cli babel-preset-env babelify browserify gulp vinyl-buffer vinyl-source-stream</code></pre><p>这里我们用 Gulp 作为任务管理工具来实现自动化（什么，都 7012 年了你还不知道 Gulp？那为什么不去问问<a href="https://www.google.com/" target="_blank" rel="noopener">神奇海螺</a>呢？），<code>gulpfile.js</code> 内容如下：</p><pre><code class="javascript">var gulp       = require(&#39;gulp&#39;),    browserify = require(&#39;browserify&#39;),    babelify   = require(&#39;babelify&#39;),    source     = require(&#39;vinyl-source-stream&#39;),    buffer     = require(&#39;vinyl-buffer&#39;);gulp.task(&#39;build&#39;, function () {    return browserify([&#39;./src/index.js&#39;])        .transform(babelify)        .bundle()        .pipe(source(&#39;bundle.js&#39;))        .pipe(gulp.dest(&#39;dist&#39;))        .pipe(buffer());});</code></pre><p>相信诸位都能看得懂吧，<code>browserify()</code> 第一个参数是入口文件，可以是数组或者其他乱七八糟的，具体参数说明请自行参照 Browserify 文档。而且记得在根目录下创建 <code>.babelrc</code> 文件指定转译的 preset，或者在 <code>gulpfile.js</code> 中配置也可以，这里就不再赘述。</p><p>最后运行 <code>gulp build</code>，就可以生成能直接在浏览器中运行的打包文件了。</p><pre><code class="shell">➜  browserify $ gulp build[12:12:01] Using gulpfile E:\wwwroot\es6-module-test\browserify\gulpfile.js[12:12:01] Starting &#39;build&#39;...[12:12:01] Finished &#39;build&#39; after 720 ms</code></pre><p><img src="https://img.blessing.studio/images/2017/07/06/snipaste_20170706_111125.png" alt="Browserify Result"></p><h2 id="Rollup-js"><a href="#Rollup-js" class="headerlink" title="Rollup.js"></a>Rollup.js</h2><p>我记得这玩意最开始出来的时候号称为「下一代的模块打包工具」，并且自带了可大大减小打包体积的 <code>tree-shaking</code> 技术（DCE 无用代码移除的一种，运用了 ES6 静态分析语法树的特性，只打包那些用到了的代码），在当时很新鲜。</p><p><img src="https://img.blessing.studio/images/2017/07/06/rollupjs.jpg" alt="Rollup.js"></p><p>但是现在 Webpack2+ 已经支持了 Tree Shaking 的情况下，我们又有什么特别的理由去使用 Rollup.js 呢？不过毕竟也是一种可行的方法，这里也提一提：</p><pre><code class="shell"># 我也不知道为啥 Rollup.js 要依赖这个 external-helpers$ yarn add --dev rollup rollup-plugin-babel babel-preset-env babel-plugin-external-helpers</code></pre><p>然后修改根目录下的 <code>rollup.config.js</code>：</p><pre><code class="javascript">import babel from &#39;rollup-plugin-babel&#39;;export default {  entry: &#39;src/index.js&#39;,  format: &#39;esm&#39;,  plugins: [    babel({      exclude: &#39;node_modules/**&#39;    })  ],  dest: &#39;dist/bundle.js&#39;};</code></pre><p>还要修改 <code>.babelrc</code> 文件，把 Babel 转换 ES6 模块到 CommonJS 模块的转换给关掉，不然会导致 Rollup.js 处理不来：</p><pre><code class="json">{  &quot;presets&quot;: [    [&quot;env&quot;, {      &quot;modules&quot;: false    }]  ],  &quot;plugins&quot;: [    &quot;external-helpers&quot;  ]}</code></pre><p>然后在根目录下运行 <code>rollup -c</code> 即可打包依赖，也可以配合 Gulp 来使用，官方文档里就有，这里就不赘述了。可以看到，Tree Shaking 的效果还是很显著的，经测试，未使用的代码确实不会被打包进去，比起上面几个工具生成的结果要清爽多了：</p><p><img src="https://img.blessing.studio/images/2017/07/06/snipaste_20170706_140641.png" alt="Rollup.js Result"></p><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p>对，Webpack，就是那个丧心病狂想要把啥玩意都给模块化的模块打包工具。既然人家已经到了 <code>3.0.0</code> 版本了，所以下面的都是基于 Webpack3 的。什么？现在还有搞前端的不知道 Webpack？神奇海螺以下略。</p><p><img src="https://img.blessing.studio/images/2017/07/06/webpack.png" alt="Webpack"></p><p>喜闻乐见的依赖安装环节：</p><pre><code class="shell"># webpack 也可以全局安装，方便一些$ yarn add --dev babel-loader babel-core babel-preset-env webpack</code></pre><p>然后配置 <code>webpack.config.js</code>：</p><pre><code class="javascript">var path = require(&#39;path&#39;);module.exports = {  entry: &#39;./src/index.js&#39;,  output: {    filename: &#39;bundle.js&#39;,    path: path.resolve(__dirname, &#39;dist&#39;)  },  module: {    rules: [      {        test: /\.js$/,        exclude: /node_modules/,        use: {          loader: &#39;babel-loader&#39;,          options: {            presets: [&#39;env&#39;]          }        }      }    ]  }};</code></pre><p>差不多就是这么个配置，<code>babel-loader</code> 的其他 <code>options</code> 请参照文档，而且这个配置文件的括号嵌套也是说不出话，ZTMJLWC。</p><p>然后运行 <code>webpack</code>：</p><pre><code class="shell">➜  webpack $ webpackHash: 5c326572cf1440dbdf64Version: webpack 3.0.0Time: 1194ms    Asset     Size  Chunks             Chunk Namesbundle.js  2.86 kB       0  [emitted]  main   [0] ./src/index.js 106 bytes {0} [built]   [1] ./src/bullshit.js 178 bytes {0} [built]</code></pre><p>情况呢就是这么个情况：</p><p><img src="https://img.blessing.studio/images/2017/07/06/snipaste_20170706_114129.png" alt="Webpack Result"></p><div class="alert alert-info"><p><strong>Tips: 关于 Webpack 的 Tree Shaking</strong></p><p>Webpack 现在是自带 Tree-Shaking 的，不过需要你把 Babel 默认的转换 ES6 模块至 CommonJS 格式给关掉，就像上面 Rollup.js 那样在 <code>.babelrc</code> 中添加个 <code>&quot;modules&quot;: false</code>。原因的话上面也提到过，tree-shaking 是基于 ES6 模块的静态语法分析的，如果交给 Webpack 的是已经被 Babel 转换成 CommonJS 的代码的话那就没戏了。</p><p>而且 Webpack 自带的 tree-shaking 只是把没用到的模块从 <code>export</code> 中去掉而已，之后还要再接一个 UglifyJS 之类的工具把冗余代码干掉才能达到 Rollup.js 那样的效果。</p></div><p>Webpack 也可以配合 Gulp 工作流让开发更嗨皮，有兴趣的可自行研究。目前来看，这三种方案中，我本人更倾向于使用 Webpack，不知道诸君会选用什么呢？</p><h2 id="写在后面"><a href="#写在后面" class="headerlink" title="写在后面"></a>写在后面</h2><p>前几天我在捣鼓 <a href="https://github.com/printempw/blessing-skin-server" target="_blank" rel="noopener">printempw/blessing-skin-server</a> 那坨 shi 一样 JavaScript 代码的模块化的时候，打算试着使用一下 ES6 标准中的模块化方案，并找了 Google 大老师问 ES6 模块转译打包相关的资源，找了半天，几乎没有什么像样的中文资源。全是讲 ES6 模块是啥、有多好、为什么要用之类的，没几个是讲到底该怎么在生产环境中使用的（也有可能是我搜索姿势不对），说不出话。遂撰此文，希望能帮到后来人。</p><p>且本人水平有限，如果文中有什么错误，欢迎在下方评论区批评指出。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><ul><li><a href="Getting import/export working ES6 style using Browserify + Babelify + Gulp = -5hrs of life">Getting import/export working ES6 style using Browserify + Babelify + Gulp = -5hrs of life</a></li><li><a href="https://rollupjs.org/" target="_blank" rel="noopener">rollup.js • guide</a></li><li><a href="http://brooch.me/2017/06/30/webpack-tree-shaking/" target="_blank" rel="noopener">使用 webpack 2 tree-shaking 机制时需要注意的细节</a></li><li><a href="http://xwjgo.github.io/2016/09/23/webpack+babel%E5%AE%9E%E7%8E%B0%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%AB%AF%E4%BD%BF%E7%94%A8es6%E6%A8%A1%E5%9D%97%E8%AF%AD%E6%B3%95/" target="_blank" rel="noopener">webpack+babel 加载 es6 模块</a></li><li><a href="https://webpack.js.org/configuration/" target="_blank" rel="noopener">Documentation - webpack</a></li><li><a href="https://www.zhihu.com/question/41922432" target="_blank" rel="noopener">如何评价 Webpack 2 新引入的 Tree-shaking 代码优化技术？</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python3 已经发布了九年了，Python 社区却还在用 Python 2.7；而 JavaScript 社区正好相反，大家都已经开始把还没有实现的语言特性用到生产环境中了 (´_ゝ `)&lt;/p&gt;
&lt;p&gt;虽然这种奇妙情况的形成与 JavaScript 自身早期的设计缺陷以及浏览器平台的特殊性质都有关系，但也确实能够体现出 JavaScript 社区的技术栈迭代是有多么屌快。如果你昏迷个一年半载再去看前端圈，可能社区的主流技术栈已经变得它妈都不认识了（如果你没什么实感，可以看看&lt;a href=&quot;https://zhuanlan.zhihu.com/p/22782487&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《在 2016 年学习 JavaScript 是一种怎样的体验》&lt;/a&gt;这篇文章，你会感受到的，你会的）。&lt;/p&gt;
&lt;h2 id=&quot;JavaScript-模块化现状&quot;&gt;&lt;a href=&quot;#JavaScript-模块化现状&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 模块化现状&quot;&gt;&lt;/a&gt;JavaScript 模块化现状&lt;/h2&gt;&lt;p&gt;随着 JavaScript 越来越广泛的应用，朝着单页应用（SPA）方向发展的网页与代码量的愈发庞大，社区需要一种更好的代码组织形式，这就是模块化：将你的一大坨代码分装为多个不同的模块。&lt;/p&gt;
&lt;p&gt;但是在 ES6 标准出台之前，由于标准的缺失（连 CSS 都有 &lt;code&gt;@import&lt;/code&gt;，JavaScript 却连个毛线都没），这几年里 JavaScript 社区里冒出了各种各样的模块化解决方案&lt;del&gt;（群魔乱舞）&lt;/del&gt;，懵到一种极致。主要的几种模块化方案举例如下：&lt;/p&gt;
&lt;h3 id=&quot;CommonJS&quot;&gt;&lt;a href=&quot;#CommonJS&quot; class=&quot;headerlink&quot; title=&quot;CommonJS&quot;&gt;&lt;/a&gt;CommonJS&lt;/h3&gt;&lt;p&gt;主要用于服务端，模块同步加载（也因此不适合在浏览器中运行，不过也有 &lt;code&gt;Browserify&lt;/code&gt; 之类的转换工具），Node.js 的模块化实现就是基于 CommonJS 规范的，通常用法像这样：&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="JavaScript" scheme="https://blessing.studio/tag/JavaScript/"/>
    
      <category term="前端" scheme="https://blessing.studio/tag/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>为 Hexo 博客添加页面访问计数器</title>
    <link href="https://blessing.studio/add-page-view-counter-for-hexo/"/>
    <id>https://blessing.studio/add-page-view-counter-for-hexo/</id>
    <published>2017-06-25T05:12:53.000Z</published>
    <updated>2017-06-25T05:12:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般来说，写博客的都喜欢在页面上加上一个访问计数器，来<del>满足虚荣心</del>显示某篇文章或者整个站点的访问量。这种需求在 WordPress 等动态博客上都是比较容易满足的，安装个插件即可（辣鸡 Ghost 除外），但是对于小部分静态博客来说就比较头疼了。</p><p>目前来看，互联网上的静态博客访问计数器解决方案大致有这么几种：</p><ul><li>使用「<a href="http://busuanzi.ibruce.info/" target="_blank" rel="noopener">不蒜子</a>」访问计数服务；</li><li>利用 LeanCloud 平台搭建统计服务。</li></ul><p>其中「不蒜子」是个自称「永久免费使用」的极简网页计数器，仅需两行代码即可为静态博客添加访问计数功能，这种简单的解决方案也受到很多静态博客作者的喜爱。但正如我之前在这篇文章（<a href="https://blessing.studio/add-page-view-counter-for-ghost-blog/">为 Ghost 博客添加页面访问计数器</a>）中所述，不蒜子虽然提供了 <code>site_pv</code>、<code>site_uv</code>、<code>page_pv</code> 等多种统计，但是其并不提供这些服务的开放 API。而我的需求是在「首页」或者其他文章列表页中的每篇文章都要显示各自的访问量，并且需要一个「最受欢迎的文章」功能（按访问量倒序排序）。很可惜不蒜子无法满足我的需求，只好将其 PASS。</p><p>至于使用 LeanCloud 的方法（详情参见<a href="http://crescentmoon.info/2014/12/11/popular-widget/" target="_blank" rel="noopener">这篇博文</a>），其实是利用了这个平台所提供的「数据存储」后端功能，大部分逻辑都在前端完成，而 LeanCloud 只负责存储数据。但是，这个现成的访问计数程序也不支持输出「最受欢迎的文章」功能，只能自己实现。而且，既然我已经有了 VPS，那我为啥还要去弄个 LeanCloud 呢？</p><p>综上，我决定自己写一个网页访问量计数服务。</p><a id="more"></a><h2 id="0x01-技术选型"><a href="#0x01-技术选型" class="headerlink" title="0x01 技术选型"></a>0x01 技术选型</h2><p>前端 <code>increase</code>（访问量自增）、<code>get</code>（获取访问量）等操作用 JavaScript 来写，这没得选，关键是后端。本来打算后端也用 Node.js 来写的，但是想想我 VPS 上还跑着其他 PHP 项目，使用 PHP 的话运维比较方便（不需要再去另外运行 <code>forever</code> 之类的守护进程），而且我对 PHP 也很熟悉，开发效率比 Node、Python 等语言要高。</p><p>之前（2016 年一月份）我写的那个适用于 Ghost 博客的访问计数器（<a href="https://github.com/printempw/ghost-hit-counter" target="_blank" rel="noopener">printempw/ghost-hit-counter</a>）也是用 PHP 写的，不过当时并没有使用什么框架，直接原生 PHP 肛上去。这次的项目我打算使用 Lumen 这个「为速度而生的 Laravel 框架」，一来之前在开发 Minecraft 皮肤站（<a href="https://github.com/printempw/blessing-skin-server" target="_blank" rel="noopener">printempw/blessing-skin-server</a>）时已经摸清了 Laravel 那一套，二来 Lumen 在性能强大的同时还能保持 Laravel 高效率开发特性，可以省去不少无用功，专注于业务逻辑本身的开发。</p><h2 id="0x02-开发"><a href="#0x02-开发" class="headerlink" title="0x02 开发"></a>0x02 开发</h2><p>事实证明我选择 Lumen 是正确的。</p><p>整个项目包括前端和后端，开发以及测试总共花了我大概三个小时的时间，Lumen 便捷的基础组件让我少走了不少冤枉路：</p><ul><li><code>DB</code> Facade 的一套代码可以同时支持 MySQL 和 SQLite，只需在 <code>.env</code> 中配置即可切换数据库源，简直不要再方便；</li><li>好用且优雅的查询构造器（Query Builder），告别手写 SQL，也无需臃肿的 ORM；</li><li>优雅且轻量级的路由系统，不用再像原来那样使用丑陋的 Query String 或者手动处理路由；</li><li><code>Migration</code> 数据库迁移功能，将数据表结构信息纳入版本控制系统，部署仅需一句 <code>php artisan migrate</code>，不小心搞砸数据库也只需要一句 <code>php artisan migrate:refresh</code> 就能完好如新；</li><li>便捷的 <code>Cache</code> 缓存系统，开箱即用的文件缓存，修改 <code>.env</code> 配置即可将后端无缝切换至 Redis；</li><li>可直接使用 Laravel 的 <code>ThrottleRequests</code> 节流阀中间件，哪里限流套哪里；</li><li>自带超好用的时间处理类库 <code>Carbon</code>；</li><li>开箱即用的异常处理系统以及完整的日志记录，etc.</li></ul><p>成品开源在 GitHub 上（<a href="https://github.com/printempw/hexo-view-counter" target="_blank" rel="noopener">printempw/hexo-view-counter</a>），采用 GPLv3 协议，欢迎 star 或修改自用，Live Demo 就是这个博客。另外这也是我第一次使用 Atom 编辑器从头开始开发一个项目，一路用下来使用体验还是蛮不错的（之前都用的 Sublime Text3）。</p><p><img src="https://img.blessing.studio/images/2017/06/25/snipaste_20170624_222645.png" alt="Atom"></p><h2 id="0x03-使用方法"><a href="#0x03-使用方法" class="headerlink" title="0x03 使用方法"></a>0x03 使用方法</h2><p>安装部署方法我不多说，自己去项目 README 看，反正就是 Laravel 那套。而且我顺便魔改了下 Lumen 的框架结构，删掉了一大票目前用不着的东西，同时把入口文件从 <code>/public</code> 子目录移到项目根目录下了，所以 Nginx 用户只需要配置好 URL 重写，Apache 用户啥都不用干就行。</p><p>这个项目只提供基本的 API（具体看 README），其他逻辑需要在博客前端完成，下面贴一下我自己在用的脚本（某些语句依赖于 jQuery，可自行修改）：</p><script src="//work.prinzeugen.net/gist/2e0e0c127a0f5081434b4dbe136327c1.js"></script><p>需要注意的是，「最受欢迎的文章」页面需要后端提供文章标题，但是我思来想去，都想不到什么好的解决方法。原先搞 Ghost 的访问计数器时可以直接访问 Ghost 的数据库来获取文章信息，但是静态博客就不行了。虽然想过各种自动化的方法（譬如自动去爬标题之类的），但想想还是作罢。目前情况是，文章相关的 record 会随着访问而自动生成（<code>slug</code>、<code>pv</code>、<code>created_at</code> 等字段），但是 <code>title</code> 字段并不会自动填写（NULL）。所以如果你需要热门文章功能的话，可以定期访问计数器的数据库，手动填写文章的标题信息。</p><p>而且这样虽然不优雅，但也能有效防止他人恶意请求造成垃圾数据过多（静态博客没有好办法去验证请求的 <code>slug</code> 是否存在），想要清除无效数据只需运行 <code>DELETE FROM post_views WHERE title = &quot;&quot;</code> 即可。</p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>对比一下使用现成服务和自己搭建的优缺点，顺便测试下 Hexo 的 GFM 表格支持：</p><table><thead><tr><th>功能支持</th><th>不蒜子</th><th>LeanCloud</th><th>自建</th></tr></thead><tbody><tr><td>数据导入与管理<del>作弊</del></td><td>不可</td><td>可，比较麻烦</td><td>完全可以自己瞎搞</td></tr><tr><td>开放 API</td><td>无</td><td>业务逻辑都在前端</td><td>有</td></tr><tr><td>部署难度</td><td>超方便</td><td>还行</td><td>最麻烦</td></tr><tr><td>可扩展性（热门文章 etc.）</td><td>无</td><td>需要自己编写</td><td>需要自己编写</td></tr><tr><td>部署费用</td><td>免费</td><td>免费</td><td>需要支持 PHP 的主机</td></tr><tr><td>靠谱程度</td><td>也许靠谱</td><td>挺靠谱的</td><td>看你主机靠不靠谱</td></tr><tr><td>装逼程度</td><td>还行</td><td>还行</td><td>逼格高</td></tr></tbody></table><p>_(:3」∠)_ 以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一般来说，写博客的都喜欢在页面上加上一个访问计数器，来&lt;del&gt;满足虚荣心&lt;/del&gt;显示某篇文章或者整个站点的访问量。这种需求在 WordPress 等动态博客上都是比较容易满足的，安装个插件即可（辣鸡 Ghost 除外），但是对于小部分静态博客来说就比较头疼了。&lt;/p&gt;
&lt;p&gt;目前来看，互联网上的静态博客访问计数器解决方案大致有这么几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用「&lt;a href=&quot;http://busuanzi.ibruce.info/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不蒜子&lt;/a&gt;」访问计数服务；&lt;/li&gt;
&lt;li&gt;利用 LeanCloud 平台搭建统计服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中「不蒜子」是个自称「永久免费使用」的极简网页计数器，仅需两行代码即可为静态博客添加访问计数功能，这种简单的解决方案也受到很多静态博客作者的喜爱。但正如我之前在这篇文章（&lt;a href=&quot;https://blessing.studio/add-page-view-counter-for-ghost-blog/&quot;&gt;为 Ghost 博客添加页面访问计数器&lt;/a&gt;）中所述，不蒜子虽然提供了 &lt;code&gt;site_pv&lt;/code&gt;、&lt;code&gt;site_uv&lt;/code&gt;、&lt;code&gt;page_pv&lt;/code&gt; 等多种统计，但是其并不提供这些服务的开放 API。而我的需求是在「首页」或者其他文章列表页中的每篇文章都要显示各自的访问量，并且需要一个「最受欢迎的文章」功能（按访问量倒序排序）。很可惜不蒜子无法满足我的需求，只好将其 PASS。&lt;/p&gt;
&lt;p&gt;至于使用 LeanCloud 的方法（详情参见&lt;a href=&quot;http://crescentmoon.info/2014/12/11/popular-widget/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这篇博文&lt;/a&gt;），其实是利用了这个平台所提供的「数据存储」后端功能，大部分逻辑都在前端完成，而 LeanCloud 只负责存储数据。但是，这个现成的访问计数程序也不支持输出「最受欢迎的文章」功能，只能自己实现。而且，既然我已经有了 VPS，那我为啥还要去弄个 LeanCloud 呢？&lt;/p&gt;
&lt;p&gt;综上，我决定自己写一个网页访问量计数服务。&lt;/p&gt;
    
    </summary>
    
      <category term="技术" scheme="https://blessing.studio/categories/tech/"/>
    
    
      <category term="博客" scheme="https://blessing.studio/tag/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="PHP" scheme="https://blessing.studio/tag/PHP/"/>
    
      <category term="Hexo" scheme="https://blessing.studio/tag/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Twitter 账号被锁定是种怎样的体验</title>
    <link href="https://blessing.studio/twitter-account-has-been-locked/"/>
    <id>https://blessing.studio/twitter-account-has-been-locked/</id>
    <published>2017-06-19T03:09:22.000Z</published>
    <updated>2017-06-19T03:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>两天前（2017-06-17），我的 Twitter 账号莫名其妙被锁定了，原因是有「自动行为」。</p><p><img src="https://img.blessing.studio/images/2017/06/19/QQ20170617201254.png" alt="locked"></p><p>WTF？ 你特么在逗我？<img src="https://img.blessing.studio/images/2017/06/19/5628dd6ecd9fa100f371_size30_w521_h534.th.jpg" alt="黑人问号"></p><p>我思前想后，估计那一天关于 Twitter 我干的最值得怀疑的就是「多设备异地登录」了。具体流程如下（都是发生在 6.17 那一天，其实看我那一天被封前的推文也行）：</p><a id="more"></a><ul><li>被 Wabi 主题惊艳到，想要久违地尝试一下 ADUI；</li><li>备份好数据后，把手机（MI3）刷成了 MIUI（原来是 Lineage13）；</li><li>用了一段时间，很不满意<ul><li>卡顿超严重，已经到了无法正常使用的程度了，官方适配成这鸟样？还没有第三方适配的 CyanogenMod 流畅也是说不出话；</li><li>不知道出了什么问题，每次按 Home 键都要「正在加载桌面」，很烦；</li><li>MI3 上的 MIUI8 竟然是基于 Android 4.4 的……今年是几几年？</li><li>说实话，MIUI6 之后的那个上拉畸变（原生是上拉水波纹）真tm ruozhi，超不喜欢；</li><li>显示设置中的色温只能三级（暖色 - 标准 - 冷色）调整；</li><li>但是对于 Wabi Pro Ara 这个主题还是很满意的，很漂亮；</li></ul></li><li>在刷了 MIUI 的机器上登录 Twitter 账号，但是用的另外一个代理服务器；</li><li>发了一篇推文<sup><a href="https://twitter.com/printempw/status/876037651089903616" target="_blank" rel="noopener">[source]</a></sup>；</li><li>刷了 Lineage14（基于 Android 7.1.2），恢复了之前备份的应用数据，登录 Twitter 发推……然后，就没有然后了。这是我那天发表的最后一条推文：<a href="https://twitter.com/printempw/status/876049475407560705" target="_blank" rel="noopener">@printempw/status</a>；</li></ul><p>看来也就只有发的那几条推文可能有问题了，但这也够不上 Automatic Behaviors 吧？真不晓得 Twitter 怎么搞的。</p><p>虽然我不喜欢 MIUI，但是 <a href="http://zhuti.xiaomi.com/detail/810fd4e9-72cd-4cce-bbff-846dd5a709e9" target="_blank" rel="noopener">Wabi Pro Ara</a> 这个主题我还是要盛赞的，喜欢原生 Android 风格的朋友值得购买：</p><p><img src="https://ooo.0o0.ooo/2017/06/19/5947313c2b742.png" alt="Wabi Theme Screenshot"></p><p>那我该咋解锁我的 Twitter 账号呢？</p><p><img src="https://img.blessing.studio/images/2017/06/19/locked_verification_required.png" alt="Verification Required"></p><p>Twitter 官方说会给我绑定的手机号打电话，叫我把电话中的验证码输入进去，但是……</p><p><strong>我TM根本没有收到半个电话啊！</strong></p><p>明明能绑定中国大陆的手机号，却打不过来电话，我要你何用！骂归骂，总是要找个解决办法的，毕竟我还是蛮依赖 Twitter 来满足自己的分享欲的。既然官方解锁渠道走不通，那就该提出申诉了（<em>Appeal an account suspension or locked account</em>）。</p><h3 id="一、填写申诉表单"><a href="#一、填写申诉表单" class="headerlink" title="一、填写申诉表单"></a>一、填写申诉表单</h3><p>访问「<a href="https://support.twitter.com/forms/general?subtopic=suspended" target="_blank" rel="noopener">帮助中心 &gt; 提交请求  &gt; ACCOUNT ACCESS</a>」这个页面填写一个 ticket，描述你所遇到的问题和你为啥要申诉（e.g. 没有做出任何违反 Twitter Rules 的行为，中国大陆手机号收不到 Twitter 打来的电话），一般来说用英文比较好：</p><p><img src="https://img.blessing.studio/images/2017/06/19/snipaste_20170619_102152.png" alt="申诉页面"></p><p><em>▲ Twitter 这个页面的  Localization 可真 Good 啊</em></p><p>如果你不懂洋文，这里我提供个复制用范文（瞎写的，诸君不要吐槽）：</p><blockquote><p>Hi, </p><p>My account is currently suspended by Twitter, but I have no idea why my account was locked. To unlock my account, it seems that I need to enter the confirmation code which I should receive in a phone call from Twitter. However, I am in China Mainland, and the “Call Me” button dosen’t work at all. I’ve tried for many times but still no phone calls came.</p><p>I am sure that I did NOT have any violation of the Twitter Rules. This account is very important to me and I would like to have my account reactivated. Could you please unlock my account or provide another method to unlock it?</p><p>Thank you!</p></blockquote><h3 id="二、邮件回复-Twitter-的自动回复"><a href="#二、邮件回复-Twitter-的自动回复" class="headerlink" title="二、邮件回复 Twitter 的自动回复"></a>二、邮件回复 Twitter 的自动回复</h3><p>提交之后，Twitter 会自动给你发送一封以 <code>Case# {编号}: Appealing a locked account - @{Twitter 用户名} [ref:{神秘编号}:ref]</code> 为 Subject 的邮件，内容全都是教你怎么操作的废话可以不用看。有用的就一句：<em>If you’re still experiencing an issue after confirming your identity, please reply to this message and provide us with specific details of the problem you’re experiencing.</em></p><p>然后你就直接把上面那一段复制过去，再在这封邮件底下回复一下就好了 ‾\_(ツ)_/‾</p><p><img src="https://img.blessing.studio/images/2017/06/19/snipaste_20170619_104702.png" alt="邮件记录"></p><p>你急的话，也可以再继续回复催催看，不过记得言辞得体。也可以用其他语言再去开一个 ticket，我是用中文再发了一遍，本来打算今天要是还不解封的话就拿日文再发一封的（笑）而且不晓得申诉单填写页面的那个 <em>“Where are you experiencing this issue?”</em> 的平台选择对处理优先级有没有啥实际影响。</p><h3 id="三、收到解封通知"><a href="#三、收到解封通知" class="headerlink" title="三、收到解封通知"></a>三、收到解封通知</h3><p>一般来说，填写申诉单，回复邮件的两三天后就能收到 Twitter 的解封通知了：</p><p><img src="https://img.blessing.studio/images/2017/06/19/snipaste_20170619_105254.png" alt="Unlock"></p><p>我是在两天后（2017-06-19）<a href="https://twitter.com/printempw/status/876603531930722305" target="_blank" rel="noopener">早上起来时</a>收到邮件的，申诉处理速度和网上其他人<strong>两年前</strong>描述的也差不多（ummmm……）。所以被封申诉后一天两天没有回复还算是正常的，不用太慌。</p><hr><p>总之中国大陆申诉 Twitter 账号解锁差不多就是这么个流程，看网上关于这个的文章屈指可数（大部分都是好几年前的），所以稍微写篇文章记录一下，希望能帮到后来人。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;两天前（2017-06-17），我的 Twitter 账号莫名其妙被锁定了，原因是有「自动行为」。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.blessing.studio/images/2017/06/19/QQ20170617201254.png&quot; alt=&quot;locked&quot;&gt;&lt;/p&gt;
&lt;p&gt;WTF？ 你特么在逗我？&lt;img src=&quot;https://img.blessing.studio/images/2017/06/19/5628dd6ecd9fa100f371_size30_w521_h534.th.jpg&quot; alt=&quot;黑人问号&quot;&gt;&lt;/p&gt;
&lt;p&gt;我思前想后，估计那一天关于 Twitter 我干的最值得怀疑的就是「多设备异地登录」了。具体流程如下（都是发生在 6.17 那一天，其实看我那一天被封前的推文也行）：&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="https://blessing.studio/categories/diary/"/>
    
    
      <category term="记录" scheme="https://blessing.studio/tag/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="Twitter" scheme="https://blessing.studio/tag/Twitter/"/>
    
  </entry>
  
  <entry>
    <title>博客已迁移至 Hexo</title>
    <link href="https://blessing.studio/migrated-to-hexo/"/>
    <id>https://blessing.studio/migrated-to-hexo/</id>
    <published>2017-06-18T15:48:40.000Z</published>
    <updated>2017-06-18T16:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>是的，我又双叒叕换博客程序了。</p><p>话是这样说，其实也没有很频繁啦，上一次从 <a href="https://blessing.studio/hello-ghost-goodbye-wordpress/">WordPress 迁移至 Ghost</a> 已经是一年多前的事了。这次是从 Ghost 迁移至 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>，一个静态博客生成器。总体来看，我对博客程序的选择是越来越轻<del>（zhuang）</del>量<del>（bi）</del>化了。</p><p>目前，本博客已经完全迁移至 Hexo，包括所有的文章和主题。不过话说回来现在回头去看两年多前写的文章，真的挺尬的，行文风格完全不一样，超尬 (つд⊂) 目前我在用的这个主题（<a href="https://qaq.cat/kotori/100" target="_blank" rel="noopener">Seventeen</a>）已经陪了我快三年了，之前我把它从 WordPress 移植到 Ghost，现在到了 Hexo 我又把它给移植过来了，我也是爱得深沉啊（笑）</p><p>既然现在迁移完成了，我打算列举一下我迁移的理由，算是个记录。</p><h3 id="一、动态博客的优点"><a href="#一、动态博客的优点" class="headerlink" title="一、动态博客的优点"></a>一、动态博客的优点</h3><p>动态博客肯定是有一些静态博客所无法实现的优点的，不然我之前也不会一直使用动态博客，而没有考虑过使用静态博客了。</p><ul><li>动态博客功能强大，插件众多，甚至能当 CMS 用；</li><li>数据存储基于数据库，灵活性强；</li><li>有管理后台，发布、更新文章等操作方便；</li><li>自带的附件、站内搜索、评论系统等功能。</li></ul><p>那我为毛要选择迁移至静态博客呢？</p><a id="more"></a><h3 id="二、Ghost-太鶸了，真的鶸"><a href="#二、Ghost-太鶸了，真的鶸" class="headerlink" title="二、Ghost 太鶸了，真的鶸"></a>二、Ghost 太鶸了，真的鶸</h3><p>在迁移之前，我使用的是 Ghost 这个基于 Node.js 构建的动态博客程序。</p><p>我最开始选择它就是因为受够了臃肿的 WordPress 而看中了 Ghost 的简洁。但是这一年使用下来，我对 Ghost 的热情也渐渐冷却，对它感到不爽的地方也多了起来。说到底，作为一个普通的用户来看，我认为 Ghost 并没有实现多少<strong>「只有动态博客才能做到」</strong>的功能。</p><ul><li>孱弱的主题系统。是的，如果你开发过 Ghost 主题，你就会感到 Ghost 的主题功能是有多么的鶸（以下情况截止至 Ghost 的 0.11.9 版，即 2017-05-07，也许 Ghost 之后的版本会有所改善）。<ul><li>在 Handlebars 模板中，你只能使用 Ghost 提供的有限变量，你甚至无法在 <a href="https://themes.ghost.org/v0.11.9/docs/if" target="_blank" rel="noopener">if statement</a> 中使用稍微复杂一些的表达式（当然，你也可以称赞这是遵循逻辑与视图分离）；</li><li>用户自定义？不存在的，用户在不修改主题文件的前提下能修改的就只有博客标题、LOGO 等基本信息以及导航栏。而且导航栏标题中的 HTML 标签永远都会被转义，不修改 Ghost 源码关不掉，想放个图标都不行；</li><li>小工具、换主题颜色、换 Schema？直接改主题或者 Ghost 的源码去吧，否则你没有任何方法为你的 Ghost 主题添加一个自定义配置文件，因为你根本读取不到。</li></ul></li><li>没有原生评论系统，你必须和其他静态博客一样去使用如 Disqus、多说（已经倒闭了）之类的第三方评论系统；</li><li>没有搜索功能。为什么你一个动态博客和静态博客一样不支持站内搜索？极简风？</li><li>没有附件上传功能。好吧我也用不到这个，交给图床去做；</li><li>不支持用户自行截取文章摘要，不<a href="https://blessing.studio/add-more-tag-for-ghost/">修改源码</a>无法实现类似 WordPress 的 <code>&lt;!--more--&gt;</code> 功能；</li><li>虽是打着简洁轻便优美的名头，但是在我看来 Ghost 整体已经日渐臃肿，尤其是 1.0 Alpha 版，看源码看得我一个头两个大。当然，你也可以说是我太low，不懂它的架构优雅😀</li><li>Markdown 支持不好，渲染经常出问题，而且连个表格都没得插；</li></ul><p>虽然 Ghost 有这么多不完善的地方，但毕竟人家还处在 0.x 的版本号阶段嘛，也不是不能理解，因此我也愿意继续使用它，等待它慢慢成长完善。但是后来我在试用 Ghost 1.0 Alpha 的早期版本时（当时 Alpha 页面上介绍的是 <em>Brand New Editor</em>，我挺心动的），我惊讶地发现 Ghost 团队在 Alpha 甚至做出了<strong>【取消 Markdown 编辑器改为普通富文本编辑器】</strong>的神奇决定……虽然半个月前的 <a href="https://github.com/TryGhost/Ghost/releases/tag/1.0.0-alpha.21" target="_blank" rel="noopener">Alpha.21</a> 已经重新回归了 markdown-only 编辑器，而且换了个新的 Markdown renderer（官方自己也承认原来的渲染器有着 <em>a whole heap of syntax bugs</em>）。但是很可惜，当我得知这条消息时，我已经完成了博客的迁移工作 ‾\_(ツ)_/‾</p><h3 id="三、市面上其他的动态博客"><a href="#三、市面上其他的动态博客" class="headerlink" title="三、市面上其他的动态博客"></a>三、市面上其他的动态博客</h3><p>我也有想过换成其他的动态博客，但苦于找不到合适的。</p><ul><li><strong>WordPress</strong>：臃肿，运行速度慢，架构落后；</li><li><strong>Typecho</strong>：速度什么的都很不错，但感觉架构不够现代化；</li><li><strong>Canvas</strong>：够现代化了（基于 Laravel），但是运行速度屌慢，功能也不完善。</li></ul><h3 id="四、静态博客的优点"><a href="#四、静态博客的优点" class="headerlink" title="四、静态博客的优点"></a>四、静态博客的优点</h3><p>相比起动态博客，静态博客肯定是有一些它独有的优点的，不然我也不可能会考虑耗费时间精力去做迁移工作。</p><ul><li>文章以一个个纯文本文件保存，便于管理备份（Git 或者直接一股脑 zip）；</li><li>可以直接用我喜欢的编辑器编辑博文（推荐 Typora，超好用）；</li><li>生成的结果就是些静态页面，放哪里都行，托管、迁移也方便，不用耗费太多精力去维护；</li><li>性能铁定比动态博客强（我就是因为性能问题而放弃了 WordPress）；</li><li>安全性高，不用担心博客程序曝出各种 SQL 注入之类的漏洞（参见 WP）；</li><li>我喜欢纯文本、Markdown，和简单优美的东西 :P</li><li>Jekyll、Octopress、Hexo 等静态博客生成器的生态圈也很发达；</li><li><del>静态博客 ZHUANG BI 啊</del></li></ul><h3 id="五、静态博客的缺点"><a href="#五、静态博客的缺点" class="headerlink" title="五、静态博客的缺点"></a>五、静态博客的缺点</h3><p>当然，静态博客也是有缺点的，不然大家都去用静态博客了。</p><ul><li>没有自带的评论系统（我用 Disqus）；</li><li>没有自带的搜索功能（我直接用 Google 的 <code>site:</code> 搜索限定符）；</li><li>没有后台，不能随时随地发表文章（毕业了，坐在电脑前的时间也多了）；</li><li>操作复杂，难以上手，一般人玩不转（对于 Geek 来说当然小菜一碟）</li></ul><h3 id="六、为啥不自己写个博客程序呢？"><a href="#六、为啥不自己写个博客程序呢？" class="headerlink" title="六、为啥不自己写个博客程序呢？"></a>六、为啥不自己写个博客程序呢？</h3><p>其实我也不是没有想过啦。</p><ul><li>不想造轮子，现有的博客程序都挺好的；</li><li>我自认为不需要通过写一个博客程序的方式来巩固我的知识以及展示「我会○○技能哦」，维护也麻烦。写个博客程序不难，但我希望写一些更有意义的玩意儿；</li><li><strong>懒</strong>。</li></ul><h3 id="七、我依然坚持独立博客的理由"><a href="#七、我依然坚持独立博客的理由" class="headerlink" title="七、我依然坚持独立博客的理由"></a>七、我依然坚持独立博客的理由</h3><p>引用阮一峰老师所言<sup><a href="http://www.ruanyifeng.com/blog/2012/08/blogging_with_jekyll.html" target="_blank" rel="noopener">[source]</a></sup>：</p><blockquote><p>喜欢写 Blog 的人，会经历三个阶段。</p><p>第一阶段，刚接触 Blog，觉得很新鲜，试着选择一个免费空间来写。</p><p>第二阶段，发现免费空间限制太多，就自己购买域名和空间，搭建独立博客。</p><p>第三阶段，觉得独立博客的管理太麻烦，最好在保留控制权的前提下，让别人来管，自己只负责写文章。</p></blockquote><p>三年过去了，目前我依然处于第二阶段。那我是为什么没有放弃独立博客呢？</p><ul><li>免费的静态站点托管服务（GitHub Pages、Coding Pages）总有不少限制和不便之处，而且免费的才是最贵的；</li><li>至于收费托管服务……那为啥不自己买个 VPS 呢？还能跑其他程序；</li><li>Medium、简书之类的平台虽然可以专注于写作，但是不好进行自定义与功能的添加，个性化功能过于局限，样式模板千篇一律，<del>不好装逼</del>；</li><li>并没有觉得维护独立博客很麻烦，专注产出内容之余折腾下搭建、模板，也挺有意思的 ;)</li></ul><p>最后引用一句 <a href="https://www.farbox.com/" target="_blank" rel="noopener">Farbox</a> 首页上我很喜欢的一段话：</p><blockquote><p>博客的意义</p><p>除了记录生活，博客让作者变得平静、幸福、以及更优秀，结交到性情相近的朋友，甚至让薪资涨幅超过不写博客的一些人。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;是的，我又双叒叕换博客程序了。&lt;/p&gt;
&lt;p&gt;话是这样说，其实也没有很频繁啦，上一次从 &lt;a href=&quot;https://blessing.studio/hello-ghost-goodbye-wordpress/&quot;&gt;WordPress 迁移至 Ghost&lt;/a&gt; 已经是一年多前的事了。这次是从 Ghost 迁移至 &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;，一个静态博客生成器。总体来看，我对博客程序的选择是越来越轻&lt;del&gt;（zhuang）&lt;/del&gt;量&lt;del&gt;（bi）&lt;/del&gt;化了。&lt;/p&gt;
&lt;p&gt;目前，本博客已经完全迁移至 Hexo，包括所有的文章和主题。不过话说回来现在回头去看两年多前写的文章，真的挺尬的，行文风格完全不一样，超尬 (つд⊂) 目前我在用的这个主题（&lt;a href=&quot;https://qaq.cat/kotori/100&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Seventeen&lt;/a&gt;）已经陪了我快三年了，之前我把它从 WordPress 移植到 Ghost，现在到了 Hexo 我又把它给移植过来了，我也是爱得深沉啊（笑）&lt;/p&gt;
&lt;p&gt;既然现在迁移完成了，我打算列举一下我迁移的理由，算是个记录。&lt;/p&gt;
&lt;h3 id=&quot;一、动态博客的优点&quot;&gt;&lt;a href=&quot;#一、动态博客的优点&quot; class=&quot;headerlink&quot; title=&quot;一、动态博客的优点&quot;&gt;&lt;/a&gt;一、动态博客的优点&lt;/h3&gt;&lt;p&gt;动态博客肯定是有一些静态博客所无法实现的优点的，不然我之前也不会一直使用动态博客，而没有考虑过使用静态博客了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;动态博客功能强大，插件众多，甚至能当 CMS 用；&lt;/li&gt;
&lt;li&gt;数据存储基于数据库，灵活性强；&lt;/li&gt;
&lt;li&gt;有管理后台，发布、更新文章等操作方便；&lt;/li&gt;
&lt;li&gt;自带的附件、站内搜索、评论系统等功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那我为毛要选择迁移至静态博客呢？&lt;/p&gt;
    
    </summary>
    
      <category term="日常" scheme="https://blessing.studio/categories/diary/"/>
    
    
      <category term="博客" scheme="https://blessing.studio/tag/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="Ghost" scheme="https://blessing.studio/tag/Ghost/"/>
    
      <category term="Hexo" scheme="https://blessing.studio/tag/Hexo/"/>
    
  </entry>
  
</feed>
