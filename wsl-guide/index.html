<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />


<meta name="theme-color" content="#3C8DBC">
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="HandheldFriendly" content="True" />


<meta name="description" content="这里是 @printempw 的个人博客，基本上啥都写：开发心得分享，日常吐槽吹逼，偶尔也会写正经文字，欢迎订阅。" />

  <meta name="keywords" content="Windows,CLI,WSL," />




<meta name="google-site-verification" content="WUNRfYChNMDduwLOFHG41TsVrre6BOaI7jKshEvtRts" />



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">


<meta name="generator" content="Hexo" />


<meta name="description" content="在两年前的八月，Microsoft 正式发布了 Windows 10 Anniversary Update 周年更新（它还有着 RS1，Version 1607，Build 14393 等一大堆别名）。其中最让包括我在内的众多开发者感到兴奋的特性之一，就是 WSL（Windows Subsystem for Linux，当时还叫 Bash on Ubuntu on Windows）的正式加入。 在">
<meta name="keywords" content="Windows,CLI,WSL">
<meta property="og:type" content="article">
<meta property="og:title" content="WSL 配置指北：打造 Windows 最强命令行">
<meta property="og:url" content="https://blessing.studio/wsl-guide/index.html">
<meta property="og:site_name" content="Blessing Studio">
<meta property="og:description" content="在两年前的八月，Microsoft 正式发布了 Windows 10 Anniversary Update 周年更新（它还有着 RS1，Version 1607，Build 14393 等一大堆别名）。其中最让包括我在内的众多开发者感到兴奋的特性之一，就是 WSL（Windows Subsystem for Linux，当时还叫 Bash on Ubuntu on Windows）的正式加入。 在">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/get-wsl.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/manga-system-admin-girl-sp-wsl.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/wsl-architecture.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/ls-exe-in-cygwin.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/enable-windows-optional-feature.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/microsoft-store-wsl.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/initialize-wsl.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/08/22/my-terminals.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/multiple-wsl-distributions.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/invoking-wsl-in-many-ways.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/ls-with-wrong-file-permission.png">
<meta property="og:image" content="https://img.blessing.studio/images/2018/09/08/ls-with-fixed-file-permission.png">
<meta property="og:updated_time" content="2018-09-08T07:07:41.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="WSL 配置指北：打造 Windows 最强命令行">
<meta name="twitter:description" content="在两年前的八月，Microsoft 正式发布了 Windows 10 Anniversary Update 周年更新（它还有着 RS1，Version 1607，Build 14393 等一大堆别名）。其中最让包括我在内的众多开发者感到兴奋的特性之一，就是 WSL（Windows Subsystem for Linux，当时还叫 Bash on Ubuntu on Windows）的正式加入。 在">
<meta name="twitter:image" content="https://img.blessing.studio/images/2018/09/08/get-wsl.png">
<meta name="twitter:creator" content="@printempw">





  <link rel="alternate" href="/atom.xml" title="Blessing Studio">



  <link rel="canonical" href="https://blessing.studio/wsl-guide/"/>



<link rel="shortcut icon" href="/images/favicon.ico">
<link rel="icon" sizes="192x192" href="/images/icon.png" />
<link rel="apple-touch-icon" sizes="144x144" href="/images/touch-icon.png" />


<link rel="stylesheet" href="/css/main.css">
<link rel="stylesheet" href="/libs/fancybox/source/jquery.fancybox.css">
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">


<link rel="stylesheet" type="text/css" href="https://fonts.cat.net/css?family=Alegreya" />
<link rel="stylesheet" type="text/css" href="https://fonts.cat.net/css?family=Alegreya+SC" />
<link rel="stylesheet" type="text/css" href="https://fonts.cat.net/css?family=Roboto+Slab">
<link rel="stylesheet" type="text/css" href="https://fonts.cat.net/css?family=PT+Serif">


    <title>WSL 配置指北：打造 Windows 最强命令行 - Blessing Studio</title>
  </head>

  <body lang="zh-CN">

    <div id="pageframe" class="fw">
      <script type="text/javascript" src="/js/nanobar.js"></script>
<script type="text/javascript">
    /* Initial NanoBar */
    var nanobar = new Nanobar({
        bg: "#BEDBEC",
        target: document.getElementById("pageframe"),
        id: "inb"
    });
</script>


      <div id="top" class="fw clf">
        <div id="header" class="wc center">
  <div class="logo-container left">
    
    <div class="logo left">
      <a href="https://blessing.studio"><img src="/images/logo.png"></a>
    </div>
  </div>

  <div class="social right">
    
    <div class="ico right" id="tg-s"><a href="javascript:void()" class="fa fa-search"></a></div>
    <form role="search" method="get" id="searchform-top" action="https://www.google.com/search">
      <input type="hidden" name="sitesearch" value="https://blessing.studio">
      <input type="text" name="q" id="s-top" placeholder="搜一搜 (ゝω·)☆ " />
    </form>

    
    <div id="toggler" class="right">
      
        
          <div class="ico">
            <a href="https://twitter.com/printempw" target="_blank" title="Twitter" class="fa fa-twitter"></a>
          </div>
        
          <div class="ico">
            <a href="https://github.com/printempw" target="_blank" title="GitHub" class="fa fa-github"></a>
          </div>
        
      
      <div class="ico">
        <a href="/atom.xml" target="_blank" class="fa fa-rss" ></a>
      </div>
    </div>

    <div class="ico right" id="tg-m"><a href="javascript:;" class="fa fa-bars"></a></div>
  </div>

  <div class="topmenu left">
    <div class="menu-container">
      <ul class="menu">
  
    
    <li class="menu-item menu-item-tech">
      <a href="/categories/tech/" title="提高姿势水平" rel="section">
      技术
      </a>
    </li>
  
    
    <li class="menu-item menu-item-archive">
      <a href="/archives/" title="总览历史文章" rel="section">
      归档
      </a>
    </li>
  
    
    <li class="menu-item menu-item-kaomoji">
      <a href="javascript:void;" title="点我点我" rel="section">
      (´・ω・`)
      </a>
    </li>
  
</ul>

    </div>
  </div>
  <div class="left clf"></div>

</div>

      </div>

      <div id="container" class="wc center clf page-post">
        <script type="text/javascript">nanobar.go(20);</script>

        <div id="content" class="wp">
          

  
  <article class="post post-type-normal hentry">
    <h1 class="post-title">
      <a href="/wsl-guide/">WSL 配置指北：打造 Windows 最强命令行</a>
    </h1>

    






    <div class="post-content">
      
      <div class="toc-container">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-我理想中的命令行界面"><span class="toc-text">1. 我理想中的命令行界面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-难用的-Windows-命令行"><span class="toc-text">2. 难用的 Windows 命令行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Windows-Subsystem-for-Linux，参上！"><span class="toc-text">3. Windows Subsystem for Linux，参上！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-安装-WSL，拥抱可爱的-Linux"><span class="toc-text">4. 安装 WSL，拥抱可爱的 Linux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-使用更专业的终端模拟器"><span class="toc-text">5. 使用更专业的终端模拟器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-让我们更深入一些"><span class="toc-text">6. 让我们更深入一些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-使用软件源镜像"><span class="toc-text">6.1 使用软件源镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-安装-zsh-与-oh-my-zsh"><span class="toc-text">6.2 安装 zsh 与 oh-my-zsh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-安装多个发行版"><span class="toc-text">6.3 安装多个发行版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-多种进入-WSL-的方式比较"><span class="toc-text">6.4 多种进入 WSL 的方式比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-与-Windows-的互操作性"><span class="toc-text">6.5 与 Windows 的互操作性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-DrvFs-文件权限问题"><span class="toc-text">6.6 DrvFs 文件权限问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-其他关于-WSL-的折腾"><span class="toc-text">6.7 其他关于 WSL 的折腾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-总结"><span class="toc-text">7. 总结</span></a></li></ol>
      </div>
      
      <p>在两年前的八月，Microsoft 正式发布了 Windows 10 Anniversary Update 周年更新（它还有着 RS1，Version 1607，Build 14393 等一大堆别名）。其中最让包括我在内的众多开发者感到兴奋的特性之一，就是 WSL（Windows Subsystem for Linux，当时还叫 Bash on Ubuntu on Windows）的正式加入。</p>
<p><strong>在 Windows 上原生运行 Linux 可执行文件，牛逼疯了！</strong></p>
<p>然而 Bug10 也不是浪得虚名，原本只提供给 Insider 的 WSL 在正式发布后依然问题多多（不仅 zsh、tmux 等工具无法使用，网络相关的操作更是一概欠奉，还有各种各样 <a href="https://twitter.com/printempw/status/927862325280772096" target="_blank" rel="noopener">奇妙的 BUG</a>），基本没有可用性，我在尝鲜了一段时间后也不得不重回 Cygwin 的怀抱。不过好消息是，在之后的更新中，<a href="https://blogs.msdn.microsoft.com/commandline/2017/04/11/windows-10-creators-update-whats-new-in-bashwsl-windows-console/" target="_blank" rel="noopener">这些 BUG 都已被逐一消灭</a>。</p>
<p>经过了两年的发展，WSL 已经<a href="https://twitter.com/printempw/status/927898980385677312" target="_blank" rel="noopener">足够成熟</a>，我也是时候完成这篇<a href="https://twitter.com/printempw/status/928656863310200832" target="_blank" rel="noopener">一咕再咕</a>的博文了。</p>
<p>（开学在即，仓促成文，如有谬误，还请指正。）</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/get-wsl.png" alt="get-wsl"></p>
<a id="more"></a>
<h2 id="1-我理想中的命令行界面"><a href="#1-我理想中的命令行界面" class="headerlink" title="1. 我理想中的命令行界面"></a>1. 我理想中的命令行界面</h2><p>既然<del>违反广告法</del>取了这么个标题，那我自然得先描述一下我的目标，也就是我理想中的命令行界面应该是什么样子的（如果你不清楚命令行的概念，可以看看我之前写的 <a href="https://blessing.studio/the-difference-between-cli-terminal-shell-tty/">这篇文章</a>）：</p>
<ul>
<li><strong>好看</strong>（配色、字体可以自由设定）；</li>
<li>支持 UTF-8 字符的输入与显示；</li>
<li>支持常见的 *NIX 命令行工具（cat、grep、awk 等）；</li>
<li>自动补全、语法高亮、历史记录；</li>
<li>完善的复制粘贴支持；</li>
<li>互操作性（共享文件系统、网络栈，可调用 Win32 程序）；</li>
<li>支持常用的脚本语言（PHP、Python、Node.js 等）；</li>
<li>包管理器，以及其他各种常用软件的支持；</li>
<li>快速呼出（快捷键、右键菜单入口）。</li>
</ul>
<p>然而遗憾的是，Windows 上的命令行一直以来都很微妙。</p>
<h2 id="2-难用的-Windows-命令行"><a href="#2-难用的-Windows-命令行" class="headerlink" title="2. 难用的 Windows 命令行"></a>2. 难用的 Windows 命令行</h2><p>停停停，那边的 PowerShell 爱好者 ，咱别动粗成吗？</p>
<p>首先我要对标题做出一些订正，Windows 原生命令行其实也可以不那么难用。虽然 cmd.exe 是公认的难用到反人类（毕竟是用来兼容 DOS 的老古董），但后来推出的 PowerShell 已经足够强大且现代化，能够称得上是一个成熟的命令行 Shell 了。<strong>如果你愿意学习的话，PowerShell 几乎可以满足你对命令行的所有期待。</strong>这一点可以参见：<a href="https://stackoverflow.com/a/573861" target="_blank" rel="noopener">Is PowerShell ready to replace my Cygwin shell on Windows?</a></p>
<p>但是，PowerShell 与 Bash 等类 Unix 系统上的 Shell 程序几乎是两个完全不同的世界。不仅语法不同，其平台上各类常用的命令行工具也基本不一致（比如类 Unix 系统中的 <code>grep</code> 对应 PowerShell 中的 <code>Select-String</code>，<code>uniq</code> 对应 <code>Select-Object -Unique</code> 等）。往深了说，他们的系统设计理念都是不一样的，比如很多人推崇的 <a href="https://zh.wikipedia.org/wiki/Unix%E5%93%B2%E5%AD%A6" target="_blank" rel="noopener">Unix 哲学</a>，在 Windows 上就基本不见踪影；而 COM 等概念也是 Windows 独一份。</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/manga-system-admin-girl-sp-wsl.png" alt="manga-system-admin-girl-sp-wsl"></p>
<p><em>▲ 图片来源：<a href="https://system-admin-girl.com/comic/begins/sp-wsl/" target="_blank" rel="noopener">シス管系女子 BEGINS 特別編 まんがでわかる WSL</a></em></p>
<p>当然，我无意在此挑起操作系统间的圣战。Windows 和类 Unix 系统中的命令行哪个好用，见仁见智。不过对于包括我在内的很多用户都认为 Windows 命令行不怎么好用，仅此而已。</p>
<p>回到正题。</p>
<p><strong>虽然 Windows 的命令行一直遭人诟病，但是人家的图形界面牛逼啊。</strong>于是无数工程师前赴后继，试图在 Windows 上创造出不输给类 Unix 系统的命令行体验 —— 却绝大多数以失败告终。曾经努力过的人，或者回到可爱的 Linux 上，或者进入高贵冷艳的 macOS 的世界。其中有先辈留下了 Cygwin、GnuWin32 等工具集，让我们可以在 Windows 下使用类 Unix 系统中常见的命令行工具，成为了不少 Windows 用户的救赎。</p>
<p>然而，就当大家都觉得「也就这样了」的时候，Microsoft 出人意料地站了出来。</p>
<p>带着他新鲜出炉的 WSL。</p>
<h2 id="3-Windows-Subsystem-for-Linux，参上！"><a href="#3-Windows-Subsystem-for-Linux，参上！" class="headerlink" title="3. Windows Subsystem for Linux，参上！"></a>3. Windows Subsystem for Linux，参上！</h2><p>大家都把 WSL 吹得这么牛逼，那 WSL 究竟是个什么玩意儿呢？</p>
<p>简单来说，WSL 是一个 <strong><a href="https://zh.wikipedia.org/wiki/%E5%85%BC%E5%AE%B9%E5%B1%82" target="_blank" rel="noopener">兼容层</a></strong>，有点像反过来的 Wine。</p>
<hr>
<p>首先，我问个问题，为什么 Linux 上的程序无法在 Windows 上运行呢？</p>
<p>了解过一点操作系统原理的同学应该都知道，这是 Windows 与 Linux 的内核提供的接口不同（系统调用、API 等）导致的。举个栗子，我们想知道某目录下的内容，在 Linux 下我们会使用 <code>ls</code> 命令，而在 Windows 下我们会使用 <code>dir</code> 命令。</p>
<p>当我们在 Linux 上执行 <code>ls</code> 命令，<code>ls</code> 会调用 <code>getdents</code> 这个系统调用，Linux 内核收到请求，将目录的内容返回给应用程序；当我们在 Windows 上执行 <code>dir</code> 命令，<code>dir</code> 会调用 <code>NtQueryDirectoryFile</code> 这个 API，NT 内核收到请求，将目录的内容返回给应用程序。虽然系统不同，但基本上都是一个道理。</p>
<p>然而，当我们把 Linux 上的应用程序拿到 Windows 上运行时，应用程序和内核就双双懵逼了。比如 <code>ls</code> 会尝试调用 <code>getdents</code> 系统调用（理想化的情况下，暂不考虑可执行文件格式等问题），Windows 的 NT 内核一看，心说：「这他娘的什么东西，老子不认识啊，啥情况啊」，<code>ls</code> 也想：「尼玛，内核怎么不回话啊，咋回事儿啊」……两边语言不通，应用程序自然无法正确执行。</p>
<p>但是有了 WSL，情况就不一样了。</p>
<p>依然拿 <code>ls</code> 举例，当我们在 WSL 中运行 <code>ls</code> 命令时，<code>ls</code> 会调用 <code>getdents</code> 系统调用（这个系统调用接口是 WSL 提供的，Windows 本身并没有这个接口），WSL 收到这个请求，明白了应用程序是想要知道目录的内容，<strong>于是把 Linux 的系统调用转换为 NT API <code>NtQueryDirectoryFile</code></strong>。NT 内核收到 WSL 的请求，将目录的内容返回给 WSL，WSL 再把返回的内容包装好后返回给 <code>ls</code>。</p>
<p>也就是说，WSL 在 Linux 应用程序与 Windows NT 内核之间起到了<strong>翻译者</strong>的作用。很简单的道理，既然 NT 内核无法理解 Linux 应用程序的 POSIX 系统调用，那就弄个翻译来将 POSIX 系统调用实时转换为 NT 内核能理解的 API 调用，突出一个见人说人话、见鬼说鬼话。</p>
<p>只要实现了足够多的系统调用翻译，那么理论上 WSL 可以完全模拟成一个 Linux 内核。</p>
<hr>
<p>相信各位都听说过鼎鼎大名的 Cygwin。同样是能让 Linux 应用程序运行在 Windows 上，WSL 和 Cygwin 有什么不同呢？其实差别还是挺大的。</p>
<p>虽然 Cygwin 提供了完整的 POSIX 系统调用 API（以运行库  <code>Cygwin*.dll</code> 的形式提供），但其依然工作在 User Mode；而 WSL 中的 Linux 应用程序进程会被包裹在一个叫做 Pico Process 的东西里，这个东西里发出的所有系统调用请求都会被直接送往 Kernel Mode 中的 <code>lxcore.sys</code> 与 <code>lxss.sys</code> 处理。</p>
<p>同样是将 POSIX 系统调用转换为 Windows 中的 API，Cygwin 是转换成 Win32 API 的调用（因为它架设在 Win32 子系统上，很多内核操作受限于 Win32 的实现，比如 <code>fork</code>），而 WSL 则是转换为更底层的 NT API 调用（WSL 是与 Win32 平行的子系统，直接架设在 NT 内核上，可以通过 NT API 原生实现 <code>fork</code> 等系统调用）。</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/wsl-architecture.png" alt="wsl-architecture"></p>
<p><em>▲ WSL 架构示意图。图片来源：<a href="https://blog.jessfraz.com/post/windows-for-linux-nerds/" target="_blank" rel="noopener">Windows for Linux Nerds</a></em></p>
<p>最重要的一点：如果使用 Cygwin，Linux 应用程序的源码必须 link 至 Cygwin 运行库（<code>Cygwin*.dll</code>），<strong>修改源码重新编译后才能在 Windows 下运行</strong>。这些重新编译后的 Linux 应用程序在调用 POSIX API 时不会直接去请求内核，而是会去调用 Cygwin 运行库，由运行库翻译成 Win32 API、执行调用后返回结果。这也就意味着，重新编译后的应用程序需要依赖 Cygwin 运行库才能正常运行（有时候你会碰到的「缺少 <code>Cygwin1.dll</code>」报错就是这个原因），而且这样编译出来的可执行程序是纯正的 Win32 PE 格式封装，只能在 Windows 上运行。</p>
<p>而在 WSL 下，我们可以直接运行未经任何修改的 ELF 格式 Linux 可执行程序。</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/ls-exe-in-cygwin.png" alt="ls-exe-in-cygwin"></p>
<p><em>▲ Cygwin 目录下，被编译成 Win32 可执行程序的 Linux 应用程序们。</em></p>
<p>最后总结一波：</p>
<p>WSL 就像是一个翻译官，就算那些未经修改的 Linux 应用程序们操着一口纯正的 POSIX 系统调用语法，WSL 也能快速准确地将其翻译为 NT 内核能听懂的 API 调用；</p>
<p>而那些使用了 Cygwin 重新编译后的 Linux 应用程序，就像是改造人一样变成了 Win32 应用程序的形状，还被套了个翻译机。程序自己（源码中）说的是 POSIX，经过翻译机（Cygwin 运行库）之后就变成 Win32 API 调用了，这样 NT 内核也能听得懂。</p>
<p>但是每次添加新程序都要改造，多麻烦啊，还是 WSL 原生态更健康（笑）。</p>
<hr>
<p>以上只是我对 WSL 的粗浅解释，其具体实现原理可以参考官方博客上的 <a href="https://blogs.msdn.microsoft.com/wsl/2016/04/22/windows-subsystem-for-linux-overview/" target="_blank" rel="noopener">这一系列文章</a>。</p>
<h2 id="4-安装-WSL，拥抱可爱的-Linux"><a href="#4-安装-WSL，拥抱可爱的-Linux" class="headerlink" title="4. 安装 WSL，拥抱可爱的 Linux"></a>4. 安装 WSL，拥抱可爱的 Linux</h2><p>好了不说废话，让我们开始安装 WSL。<strong>注意，WSL 仅支持 64 位系统，且本文中所描述的安装方法仅适用于 Windows 10 Fall Creators Update</strong>（秋季创意者更新，RS3，Version 1709，Build 16299）及以上版本。</p>
<p><strong>第一步</strong>，打开「控制面板」中的「程序与功能」，点击左侧边栏的「启用或关闭 Windows 功能」选项，在弹出的窗口中勾选「适用于 Linux 的 Windows 子系统」，然后点击确定（可能需要重启）。</p>
<p>如果你懒得用 GUI，也可以直接在 PowerShell 中以管理员权限执行命令：</p>
<pre><code class="powershell">Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux
</code></pre>
<p><img src="https://img.blessing.studio/images/2018/09/08/enable-windows-optional-feature.png" alt="enable-windows-optional-feature"></p>
<p><strong>第二步</strong>，打开 Microsoft Store，搜索「WSL」。挑选一个你喜欢的 Linux 发行版，然后点击安装。（截至目前，商店中可用的发行版有 Ubuntu、openSUSE、SUSE Linux Enterprise Server、Debian 以及 Kali Linux。）</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/microsoft-store-wsl.png" alt="microsoft-store-wsl"></p>
<p><strong>第三步</strong>，在开始菜单中找到你刚刚安装的发行版，打开它。等待几分钟的初始化过程，设定好用户名与密码后（不需要与 Windows 的相同，用过 Linux 的选手应该都懂的）就会自动进入 Linux 环境。</p>
<p>至此，你已经完成了 WSL 的安装。</p>
<p>你也可以同时安装多个发行版，它们的数据都是独立的，互不影响。</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/initialize-wsl.png" alt="initialize-wsl"></p>
<h2 id="5-使用更专业的终端模拟器"><a href="#5-使用更专业的终端模拟器" class="headerlink" title="5. 使用更专业的终端模拟器"></a>5. 使用更专业的终端模拟器</h2><p>我猜你现在正在对上面那个窗口发呆。</p>
<p><strong>—— 这个新宋体他娘的是个什么情况？</strong></p>
<p>如果你正在使用中文 Windows 系统，而且之前并没有修改过 Win32 Console 的默认配置，那么你的 WSL 终端默认就会是这样的。新宋体，就是这么 Hardcore。惊不惊喜，意不意外？</p>
<p>好吧不开玩笑，Windows 这个控制台窗口就是很多人讨厌它的原因之一，难用又难看。丑这一点倒还有解决方法（经过一番设置后还算能看，我以前就写过一篇关于 <a href="https://blessing.studio/windows-change-cmd-font/">自定义 Windows 控制台字体</a> 的文章），难用却是实打实的。尽管 Win10 上的控制台已经改进了不少（可以看看 Microsoft 的官方博客：<a href="https://blogs.msdn.microsoft.com/commandline/" target="_blank" rel="noopener">Windows Command Line Tools For Developers</a>），但其依然是最难用的终端模拟器之一，或许没有之一。</p>
<p>因此，为了实现我们的目标，一个更强大的终端模拟器是必须的。</p>
<blockquote>
<p>终端模拟器是什么？为了这个回答这个问题，我专门写了一篇文章，<a href="https://blessing.studio/the-difference-between-cli-terminal-shell-tty/">去看看吧</a>。:P</p>
</blockquote>
<p>我个人比较推荐的终端模拟器有：</p>
<ul>
<li><p><strong><a href="https://github.com/goreliu/wsl-terminal" target="_blank" rel="noopener">wsl-terminal</a></strong></p>
<p>专门为 WSL 开发的终端模拟器，基于 mintty 与 wslbridge，稳定易用。</p>
</li>
<li><p><strong><a href="https://conemu.github.io/" target="_blank" rel="noopener">ConEmu</a></strong></p>
<p>Windows 上的老牌终端模拟器，功能极为强大，要啥有啥。</p>
</li>
<li><p><strong><a href="https://hyper.is/" target="_blank" rel="noopener">Hyper</a></strong></p>
<p>基于 Electron 的跨平台终端模拟器，好看和可扩展性是卖点，<a href="https://github.com/zeit/hyper/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc" target="_blank" rel="noopener">BUG 不少</a>。</p>
</li>
</ul>
<p>还有其他各种各样的终端模拟器，选个自己喜欢的就好。反正不管选哪个，都比默认的那玩意儿要好用。🌚</p>
<p>另外，设定终端模拟器的 Shell 入口时有个坑，需要注意一下（参见下文 6.4）。</p>
<p><img src="https://img.blessing.studio/images/2018/08/22/my-terminals.png" alt="my-terminals"></p>
<p><em>▲ 我正在使用的终端，wsl-terminal 与 Hyper。<del>好看是第一生产力。</del></em></p>
<h2 id="6-让我们更深入一些"><a href="#6-让我们更深入一些" class="headerlink" title="6. 让我们更深入一些"></a>6. 让我们更深入一些</h2><p>以下是 WSL 的一些优化技巧。</p>
<h3 id="6-1-使用软件源镜像"><a href="#6-1-使用软件源镜像" class="headerlink" title="6.1 使用软件源镜像"></a>6.1 使用软件源镜像</h3><p>由于众所周知的原因，各大发行版默认的软件源在中国大陆的访问速度都很屎。</p>
<p>我目前使用的是 <a href="https://mirror.tuna.tsinghua.edu.cn/help/ubuntu/" target="_blank" rel="noopener">清华大学的 Ubuntu 镜像源</a>。</p>
<h3 id="6-2-安装-zsh-与-oh-my-zsh"><a href="#6-2-安装-zsh-与-oh-my-zsh" class="headerlink" title="6.2 安装 zsh 与 oh-my-zsh"></a>6.2 安装 zsh 与 oh-my-zsh</h3><p>想要快乐地使用命令行，一个趁手的 Shell 是必不可少的。</p>
<p>我个人习惯使用 zsh，安装步骤不再赘述。<a href="https://gist.github.com/printempw/1ae3b8ae3091a6cfd65a22e1872af7ab" target="_blank" rel="noopener">我的自定义 oh-my-zsh 主题</a>：</p>
<pre><code class="shell"># ~/.oh-my-zsh/custom/themes/robbyrussell-ascii.zsh-theme
# Modified from robbyrussell, the default theme of oh-my-zsh.
# &gt; blog git:(source) x $

local ret_status=&quot;%(?:%{$fg_bold[green]%}&gt;:%{$fg_bold[red]%}&gt;%s)&quot;
PROMPT=&#39;${ret_status} %{$fg[cyan]%}%c%{$reset_color%} $(git_prompt_info)$ &#39;

ZSH_THEME_GIT_PROMPT_PREFIX=&quot;%{$fg_bold[blue]%}git:(%{$fg[red]%}&quot;
ZSH_THEME_GIT_PROMPT_SUFFIX=&quot;%{$reset_color%} &quot;
ZSH_THEME_GIT_PROMPT_DIRTY=&quot;%{$fg[blue]%}) %{$fg[yellow]%}x%{$reset_color%}&quot;
ZSH_THEME_GIT_PROMPT_CLEAN=&quot;%{$fg[blue]%})&quot;
</code></pre>
<pre><code class="shell"># ~/.zshrc
ZSH_THEME=&quot;robbyrussell-ascii&quot;
plugins=(git zsh-completions zsh-autosuggestions zsh-syntax-highlighting)
</code></pre>
<h3 id="6-3-安装多个发行版"><a href="#6-3-安装多个发行版" class="headerlink" title="6.3 安装多个发行版"></a>6.3 安装多个发行版</h3><p>Windows 10 Fall Creators Update 之后，WSL 支持同时安装多个 Linux 发行版，直接在 Microsoft Store 中搜索想要的发行版并点击安装即可。这些发行版可以同时运行，并且数据互相独立。你可以使用 <code>wslconfig.exe</code> 来查询已安装的发行版，或者更改默认的发行版。</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/multiple-wsl-distributions.png" alt="multiple-wsl-distributions"></p>
<p>删除发行版也很简单，直接卸载对应的商店应用即可（记得备份哦）。</p>
<h3 id="6-4-多种进入-WSL-的方式比较"><a href="#6-4-多种进入-WSL-的方式比较" class="headerlink" title="6.4 多种进入 WSL 的方式比较"></a>6.4 多种进入 WSL 的方式比较</h3><p>新版支持同时安装多个发行版，那自然不能像以前那样只提供一个 <code>bash.exe</code> 入口了。</p>
<p>秋季创意者更新之后的 Windows 提供了 <a href="https://blogs.msdn.microsoft.com/commandline/2017/11/28/a-guide-to-invoking-wsl/" target="_blank" rel="noopener">多种进入 WSL 环境的方式</a>：</p>
<ul>
<li><p><code>wsl.exe</code></p>
<p>打开<strong>默认</strong>发行版中的默认 Shell。</p>
</li>
<li><p><code>&lt;distroname&gt;.exe</code></p>
<p>打开<strong>指定</strong>发行版中的默认 Shell。</p>
</li>
<li><p><code>bash.exe</code> (DEPRECATED)</p>
<p>打开<strong>默认</strong>发行版中的 <strong>bash</strong> Shell。</p>
<p>如果你更改了默认 Shell 却总是打开 bash，就说明你使用了这个入口。</p>
</li>
</ul>
<p>你也可以通过这些入口直接在 WSL 中执行命令并返回结果：</p>
<ul>
<li><code>&lt;distroname&gt; -c [command]</code></li>
<li><code>bash -c [command]</code></li>
<li><code>wsl [command]</code>（不再需要指定 <code>-c</code>）</li>
</ul>
<p><img src="https://img.blessing.studio/images/2018/09/08/invoking-wsl-in-many-ways.png" alt="invoking-wsl-in-many-ways"></p>
<h3 id="6-5-与-Windows-的互操作性"><a href="#6-5-与-Windows-的互操作性" class="headerlink" title="6.5 与 Windows 的互操作性"></a>6.5 与 Windows 的互操作性</h3><p>WSL 与 Windows 之间的互操作性 (Interoperability) 很牛逼。怎么个牛逼法呢？</p>
<p>Windows 下的所有盘符都挂载在 WSL 中的 <code>/mnt</code> 目录下，可以直接操作。WSL 中的所有数据则存放于 <code>C:\Users\{你的用户名}\AppData\Local\Packages\{Linux发行版包名}\LocalState\rootfs</code> 目录中（不要在 Windows 中修改这些文件，这会造成文件权限错误）：</p>
<pre><code>$ ls /mnt
c  d  e
$ mount -l
rootfs on / type lxfs (rw,noatime)
C: on /mnt/c type drvfs (rw,noatime,uid=1000,gid=1000)
D: on /mnt/d type drvfs (rw,noatime,uid=1000,gid=1000)
E: on /mnt/e type drvfs (rw,noatime,uid=1000,gid=1000)
</code></pre><p>你可以在 Windows 命令行环境中直接调用 WSL 中的命令：</p>
<pre><code class="cmd">PS C:\temp&gt; wsl ls -al
total 0
drwxrwxrwx 1 printempw printempw 4096 Sep  7 19:04 .
drwxrwxrwx 1 printempw printempw 4096 Sep  7 18:38 ..
-rwxrwxrwx 1 printempw printempw    4 Sep  7 19:04 foo.txt
</code></pre>
<p>你也可以在 WSL 中调用 Windows 中的命令行程序：</p>
<pre><code class="shell">$ which ipconfig.exe
/mnt/c/Windows/System32/ipconfig.exe
$ ipconfig.exe
Windows IP Configuration
...
</code></pre>
<p>你可以在 WSL 中直接启动 Windows 应用：</p>
<pre><code>$ notepad.exe &quot;C:\temp\foo.txt&quot;
</code></pre><p>你还可以通过 pipes 与 Windows 程序通信：</p>
<pre><code># 复制内容至 Windows 剪贴板
$ cat foo.txt | clip.exe
</code></pre><p>你甚至可以把 Windows 命令和 WSL 命令混着用：</p>
<pre><code>PS&gt; ipconfig | wsl grep IPv4
IPv4 Address. . . . . . . . . . . : 192.168.1.114

$ ipconfig.exe | grep IPv4 | cut -d: -f2
192.168.1.114

$ ls -al | findstr.exe foo.txt
-rwxrwxrwx 1 printempw printempw    4 Sep  7 19:04 foo.txt

$ cmd.exe /c dir
 Volume in drive C is Windows
 Volume Serial Number is B263-****

 Directory of C:\temp

2018/09/07  19:04    &lt;DIR&gt;          .
2018/09/07  19:04    &lt;DIR&gt;          ..
2018/09/07  19:04                 4 foo.txt
               1 File(s)              4 bytes
               2 Dir(s)  194,422,341,632 bytes free
</code></pre><p>同时，WSL 与 Windows 共享网络栈，也就是说你可以：</p>
<ul>
<li>在 WSL 中启动 web server，在 Windows 上使用浏览器访问；</li>
<li>在 Windows 下启动 MySQL/Redis 服务器，在 WSL 中连接；</li>
<li>诸如此类。</li>
</ul>
<p>如果你对 WSL 与 Windows 之间互操作的原理有兴趣，可以参考一下这些文章：</p>
<ul>
<li><a href="https://docs.microsoft.com/en-us/windows/wsl/interop" target="_blank" rel="noopener">WSL interoperability with Windows</a></li>
<li><a href="https://blogs.msdn.microsoft.com/wsl/2016/10/19/windows-and-ubuntu-interoperability/" target="_blank" rel="noopener">Windows and Ubuntu Interoperability</a></li>
</ul>
<h3 id="6-6-DrvFs-文件权限问题"><a href="#6-6-DrvFs-文件权限问题" class="headerlink" title="6.6 DrvFs 文件权限问题"></a>6.6 DrvFs 文件权限问题</h3><p>虽然 WSL 中可以直接访问 Windows 磁盘的内容，但如果你曾经这么做过，你应该对这样绿油油一片的 <code>ls</code> 不会感到陌生。为什么 NTFS 文件系统中的文件到 WSL 下权限就全部成 <code>0777</code> 了呢？</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/ls-with-wrong-file-permission.png" alt="ls-with-wrong-file-permission"></p>
<p>这主要是 DrvFs 中 Linux 文件权限的实现导致的。</p>
<p>在 WSL 中，<a href="https://blogs.msdn.microsoft.com/wsl/2016/06/15/wsl-file-system-support/" target="_blank" rel="noopener">Microsoft 实现了两种文件系统</a>，用于支持不同的使用场景：</p>
<ul>
<li><p><strong>VolFs</strong></p>
<p>着力于在 Windows 文件系统上提供完整的 Linux 文件系统特性，通过各种手段实现了对 Inodes、Directory entries、File objects、File descriptors、Special file types 的支持。比如为了支持 Windows 上没有的 Inodes，VolFs 会把文件权限等信息保存在文件的 NTFS Extended Attributes 中。记得我上面警告过你不要在 Windows 中修改 WSL 里的文件吗？就是因为 Windows 中新建的文件缺少这个扩展参数，VolFs 无法正确获取该文件的 metadata，而且有些 Windows 上的编辑器会在保存时抹掉这些附加参数。</p>
<p>WSL 中的 <code>/</code> 使用的就是 VolFs 文件系统。</p>
</li>
<li><p><strong>DrvFs</strong></p>
<p>着力于提供与 Windows 文件系统的互操作性。与 VolFs 不同，为了提供最大的互操作性，DrvFs 不会在文件的 NTFS Extended Attributes 中储存附加信息，而是从 Windows 的文件权限（Access Control Lists，就是你右键文件 &gt; 属性 &gt; 安全选项卡中的那些权限配置）推断出该文件对应的的 Linux 文件权限。</p>
<p>所有 Windows 盘符挂载至 WSL 下的 <code>/mnt</code> 时都是使用的 DrvFs 文件系统。</p>
</li>
</ul>
<p>由于 DrvFs 的文件权限继承机制很微妙，最后导致的结果就是所有文件的权限都变成了 <code>0777</code>。而且由于早期的 DrvFs 不支持 metadata，所以你无法给这些文件 chown/chmod，只能对着绿油油的 <code>ls</code> 干瞪眼。不过好消息是，Windows Insider Build 17063 之后，<a href="https://blogs.msdn.microsoft.com/commandline/2018/01/12/chmod-chown-wsl-improvements/" target="_blank" rel="noopener">DrvFs 也像 VolFs 一样支持给文件写入 metadata 了</a>。</p>
<p>要启用 DrvFs 的 metadata 支持，你需要添加参数重新挂载磁盘：</p>
<pre><code># 修改成你自己的盘符
$ sudo umount /mnt/e
$ sudo mount -t drvfs E: /mnt/e -o metadata
</code></pre><p>不过如果仅仅是执行了这个，虽然支持了文件权限的修改，但磁盘下的文件权限默认依然还是 <code>0777</code>，除非你给它们整个 <code>chmod</code> 一遍。如果你不想这么做，也可以指定其他的 mount 参数：</p>
<pre><code>$ sudo mount -t drvfs E: /mnt/e -o metadata,uid=1000,gid=1000,umask=22,fmask=111
</code></pre><p>这样磁盘下的文件的默认权限就是 <code>0644</code>，<code>ls</code> 也不会再是绿油油一片啦。</p>
<p><img src="https://img.blessing.studio/images/2018/09/08/ls-with-fixed-file-permission.png" alt="ls-with-fixed-file-permission"></p>
<p>不过每次使用时都要重新挂载未免也太烦，我们可以通过另一个新特性 <a href="https://blogs.msdn.microsoft.com/commandline/2018/02/07/automatically-configuring-wsl/" target="_blank" rel="noopener">Automatically Configuring WSL</a> 实现自动挂载。在 WSL 中创建 <code>/etc/wsl.conf</code>，在其中填写如下内容：</p>
<pre><code class="ini">[automount]
enabled = true
root = /mnt/
options = &quot;metadata,umask=22,fmask=111&quot;
mountFsTab = true

# 这个文件里还可以添加其他配置项，有兴趣的可以看看上面的链接
</code></pre>
<p>重启终端，所有的盘符就会使用上面的配置自动挂载啦（可以使用 <code>mount -l</code> 查看）。</p>
<p>另外，如果你想要给不同的盘符设定不同的挂载参数（上面的方法对所有盘符都有效，如果你想在 WSL 中运行 Windows 下的应用程序，就得每次都 <code>chmod +x</code> 一下，所以我一般都会把 <code>C:</code> 排除掉），就需要手动修改 <code>/etc/fstab</code>。首先确保 <code>wsl.conf</code> 中的 <code>mountFsTab</code> 为 <code>true</code>，然后编辑 <code>/etc/fstab</code>，添加如下内容：</p>
<pre><code># 不在此列表中的盘符会使用 wsl.conf 中的参数挂载
# 格式可以自己去查 fstab 的帮助文档
E: /mnt/e drvfs rw,relatime,uid=1000,gid=1000,metadata,umask=22,fmask=111 0 0
</code></pre><h3 id="6-7-其他关于-WSL-的折腾"><a href="#6-7-其他关于-WSL-的折腾" class="headerlink" title="6.7 其他关于 WSL 的折腾"></a>6.7 其他关于 WSL 的折腾</h3><p>虽然 Microsoft 开发 WSL 出来主要是着重于命令行环境的使用，但经过测试，WSL 是可以通过 X Server 执行 GUI 应用程序的，<a href="https://news.ycombinator.com/item?id=13603451" target="_blank" rel="noopener">甚至还可以在 WSL 里面用 Wine 执行 Windows 程序</a>……（🤔？）</p>
<p>也有人试过在 WSL 中运行完整的 DE，体验似乎还不错，有兴趣的同学可以去试试。</p>
<p>另外，你也可以通过某些神秘的方法用上 Microsoft Store 未提供的 Linux 发行版，比如 <a href="https://wiki.archlinux.org/index.php/Install_on_WSL_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29" target="_blank" rel="noopener">Arch Linux</a>。</p>
<p>如果你对 WSL 的底层实现有兴趣，也可以去围观一下 WSL 的官方博客：</p>
<ul>
<li><a href="https://blogs.msdn.microsoft.com/wsl/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/wsl/</a></li>
<li><a href="https://blogs.msdn.microsoft.com/commandline/tag/wsl/" target="_blank" rel="noopener">https://blogs.msdn.microsoft.com/commandline/tag/wsl/</a></li>
</ul>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>虽然 WSL 很不错，但是其比起真正的 Linux 系统还是有很多不足（Docker 等涉及未实现的内核特性的软件无法使用，Raw socket 相关的操作依然容易出错，I/O 性能相比之下较为孱弱等）。如果你日常开发中需要使用到那些 WSL 未提供的 Linux 特性，那么还是乖乖跑 VM 或者装 Linux 吧。</p>
<p><strong>对我来说，WSL 最大的意义就是，让我能够用我熟悉的 Linux 那一套去操作 Windows</strong>。</p>
<p>如果你和我的需求一样，那么比起 Cygwin、VM 等解决方案，WSL 有着完整的 Linux 环境、强大的互操作性、更低的资源占用。离不开 Windows，却又羡慕 Linux 下强大命令行工具的各位，相信你们会喜欢 WSL 的。</p>
<p>而且最近几年 Microsoft 在笼络开发者方面的努力大家有目共睹，这里就容我夸上一句：</p>
<p><strong>Microsoft，干得漂亮！</strong></p>

      <div class="post-about"><p>除另有声明外，本博客文章均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/">知识共享(Creative Commons) 署名-非商业性使用-相同方式共享 3.0 中国大陆许可协议</a> 进行许可。</p></div>
    </div>

    <div class="post-meta clf">
  <span class="pmt pms fa-book">
    
      <a class="category-link" href="/categories/tech/">技术</a>
    
  </span>
  <span class="pmt pms fa-clock-o">2018-09-08</span>
  <span class="pmt pms fa-eye">
    <span id="post-view" data="wsl-guide/">Loading</span> Hits
  </span>
  <span class="pmt pms extra fa-tag">
    
      <a class="tag-link" href="/tag/CLI/">CLI</a>, <a class="tag-link" href="/tag/WSL/">WSL</a>, <a class="tag-link" href="/tag/Windows/">Windows</a>
    
  </span>
</div>

  </article>

  
    <div class="disqus"></div>

<p class="disqus-notice hentry"  style="display: none;">
  <i class="fa fa-spinner fa-spin" aria-hidden="true"></i>  如果评论框加载不出来，那就说明 Disqus 被墙了，你看着办吧 |ー` )
</p>

  

        </div>

        <div id="sidebar" class="fl">

  <div id="abovesb">
    <div class="card">
      <div class="gr center">
        <p id="music-toggle">
          <i class="fa fa-play-circle" aria-hidden="true"></i>
        </p>
        <img src="/images/avatar.jpg" width="112" height="112">
      </div>

      <div class="blogname">Blessing Studio</div>
      <div class="blogdesc">半吊子全栈开发者的日常</div>

      <div class="sbmenu">
        <div class="menu-container">
          <ul class="menu">
  
    
    <li class="menu-item menu-item-friends">
      <a href="/friends" title="友情链接" rel="section">
        <i class="fa fa-link"></i>我的小伙伴们
      </a>
    </li>
  
    
    <li class="menu-item menu-item-about">
      <a href="/about" title="(*ﾟ∀ﾟ*)" rel="section">
        <i class="fa fa-code"></i>关于我
      </a>
    </li>
  
</ul>

        </div>
      </div>
    </div>
    
    <div id="music-player" class="aplayer hide rotated"></div>
  </div>

  <script type="text/javascript">nanobar.go(40);</script>

  <div id="sb">
    
<div id="sbpin">
  
  
  <div class="clf widget-item widget-toc">
    <h3 class="widget-title">文章目录</h3>
    <div class="textwidget">
      <div class="toc-container">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-我理想中的命令行界面"><span class="toc-text">1. 我理想中的命令行界面</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-难用的-Windows-命令行"><span class="toc-text">2. 难用的 Windows 命令行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Windows-Subsystem-for-Linux，参上！"><span class="toc-text">3. Windows Subsystem for Linux，参上！</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-安装-WSL，拥抱可爱的-Linux"><span class="toc-text">4. 安装 WSL，拥抱可爱的 Linux</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-使用更专业的终端模拟器"><span class="toc-text">5. 使用更专业的终端模拟器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-让我们更深入一些"><span class="toc-text">6. 让我们更深入一些</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-使用软件源镜像"><span class="toc-text">6.1 使用软件源镜像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-安装-zsh-与-oh-my-zsh"><span class="toc-text">6.2 安装 zsh 与 oh-my-zsh</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-安装多个发行版"><span class="toc-text">6.3 安装多个发行版</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-多种进入-WSL-的方式比较"><span class="toc-text">6.4 多种进入 WSL 的方式比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-与-Windows-的互操作性"><span class="toc-text">6.5 与 Windows 的互操作性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-DrvFs-文件权限问题"><span class="toc-text">6.6 DrvFs 文件权限问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-其他关于-WSL-的折腾"><span class="toc-text">6.7 其他关于 WSL 的折腾</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-总结"><span class="toc-text">7. 总结</span></a></li></ol>
      </div>
    </div>
  </div>
  

  
  <div class="clf widget-item widget_text">
    <div class="textwidget">
      <script type="text/javascript" src="https://work.prinzeugen.net/hitokoto/hitokoto.php?encode=javascript"></script>
      <p id="hitokoto"><script>hitokoto();</script></p>
    </div>
  </div>

  
  

</div>

  </div>

</div>

      </div><!-- #container -->

      <div id="foot" class="fw">
        <div id="bottom" class="fw">
  <div id="footer" class="wc center clf">
    <div class="info">
      <p>Copyleft 2018 <a href="https://blessing.studio">Blessing Studio</a>. Proudly published with <a href="https://hexo.io/" target="_blank">Hexo</a>. Made with ❤ by printempw.</p>
    </div>
  </div>
</div>

      </div>

    </div><!-- #pageframe.fw -->
    <script type="text/javascript">nanobar.go(80);</script>

    <div class="back-to-top">
      <span class="fa fa-angle-up"></span>
    </div>

    <script src="/js/jquery-2.2.0.min.js"></script>
<script src="/js/jquery.libs.js"></script>
<script src="/js/highlight.min.js"></script>
<script src="/libs/fancybox/source/jquery.fancybox.pack.js"></script>
<script src="/js/script.js"></script>

    
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-65656002-1', 'auto');
  ga('send', 'pageview');

</script>


    <script type="text/javascript">
    $("a.like-vote").mouseover(function() {
        $("#heart").removeClass("fa-heart-o");
        $("#heart").addClass("fa-heart");
    });

    $("a.like-vote").mouseout(function() {
        $("#heart").removeClass("fa-heart");
        $("#heart").addClass("fa-heart-o");
    });

    $.getJSON("//work.prinzeugen.net/do-you-like-me/like.php?action=get", function (data) {
        $('#count').html(data.like);
    });

    $('.like-vote').click(function () {
        if ($('.like-title').html() === 'Do you like me ?') {
            $.getJSON("//work.prinzeugen.net/do-you-like-me/like.php?action=add", function (data) {
                if (data.success) {
                    $('#count').fadeOut(200);
                    $('#count').html(String(parseInt(data.like)));
                    $('#count').fadeIn(200);
                    $('.like-title').html('我也喜欢你 (*≧▽≦)');
                }
                else {
                    $('.like-title').html('你的爱我已经感受到了~');
                }
            });
        }
    });
</script>

    <style type="text/css">
    .menu-item-kaomoji a {
        -moz-user-select: none;
        -webkit-user-select: none;
        -ms-user-select: none;
    }

    .info-rise {
        z-index: 99999;
        position: absolute;
        padding: 0 4px;
        border-radius: 1px;
        background-color: #f69;
        box-shadow: 0 0 1px rgba(0,0,0,0.1);
        color: #fff;
        text-align: center;
        font-size: 12px;
        line-height: 1.5;
        cursor: default
    }
</style>

<script type="text/javascript">
    var kaomoji_array = ["|∀ﾟ", "(´ﾟДﾟ`)", "(;´Д`)", "(｀･ω･)", "(=ﾟωﾟ)=", "| ω・´)", "|-` )", "|д` )", "|ー` )", "|∀` )", "(つд⊂)", "(ﾟДﾟ≡ﾟДﾟ)", "(＾o＾)ﾉ", "(|||ﾟДﾟ)", "( ﾟ∀ﾟ)", "( ´∀`)", "(*´∀`)", "(*ﾟ∇ﾟ)", "(*ﾟーﾟ)", "(　ﾟ 3ﾟ)", "( ´ー`)", "( ・_ゝ・)", "( ´_ゝ`)", "(*´д`)", "(・ー・)", "(・∀・)", "(ゝ∀･)", "(〃∀〃)", "(*ﾟ∀ﾟ*)", "( ﾟ∀。)", "( `д´)", "(`ε´ )", "(`ヮ´ )", "σ`∀´)", " ﾟ∀ﾟ)σ", "ﾟ ∀ﾟ)ノ", "(╬ﾟдﾟ)", "(|||ﾟдﾟ)", "( ﾟдﾟ)", "Σ( ﾟдﾟ)", "( ;ﾟдﾟ)", "( ;´д`)", "(　д ) ﾟ ﾟ", "( ☉д⊙)", "(((　ﾟдﾟ)))", "( ` ・´)", "( ´д`)", "( -д-)", "(>д<)", "･ﾟ( ﾉд`ﾟ)", "( TдT)", "(￣∇￣)", "(￣3￣)", "(￣ｰ￣)", "(￣ . ￣)", "(￣皿￣)", "(￣艸￣)", "(￣︿￣)", "(￣︶￣)", "ヾ(´ωﾟ｀)", "(*´ω`*)", "(・ω・)", "( ´・ω)", "(｀・ω)", "(´・ω・`)", "(`・ω・´)", "( `_っ´)", "( `ー´)", "( ´_っ`)", "( ´ρ`)", "( ﾟωﾟ)", "(oﾟωﾟo)", "(　^ω^)", "(｡◕∀◕｡)", "/( ◕‿‿◕ )\\", "ヾ(´ε`ヾ)", "(ノﾟ∀ﾟ)ノ", "(σﾟдﾟ)σ", "(σﾟ∀ﾟ)σ", "|дﾟ )", "┃電柱┃", "ﾟ(つд`ﾟ)", "ﾟÅﾟ )　", "⊂彡☆))д`)", "⊂彡☆))д´)", "⊂彡☆))∀`)", "(´∀((☆ミつ"];
    var hits = 0;
    var start_time = 0;

    $('.menu-item-kaomoji a').click(function(e) {

        if (start_time == 0) start_time = Date.now();

        hits ++;

        if (hits % 5 === 0) {
            index = Math.floor(Math.random() * kaomoji_array.length);
            $(this).html(kaomoji_array[index]);
        }

        x = $(this).offset().left + $(this).width();
        y = $(this).offset().top + $(this).height();

        if (hits % 50 === 0) {
            var duration = 2000;
            // actions per minite
            var apm = parseInt(hits / ((Date.now() - start_time) / 1000) * 60);
            start_time = 0;
            hits = 0;
            hit = $('<span class="info-rise" style="border: 1px solid #ffd6e4;font-size:13.5px;z-index:9999999;">手速：'+apm+' actions/min </span>');

            console.log('APM: '+apm);
        } else {
            var duration = 500;
            hit = $('<span class="info-rise">+1</span>');
        }

        hit.appendTo($("body"));

        hit.css({
            opacity: 0,
            left: x,
            top: y
        }).animate({
            opacity: 1,
            top: y - 16
        }, 250).animate({
            opacity: 1,
            top: y - 20
        }, duration).animate({
            top: y - 20
        }, duration).animate({
            opacity: 0,
            top: y - 32
        }, 250, function() {
            return $(this).remove();
        });

    });
</script>

    <style type="text/css">
    .p-load-gist {
        margin: 25px 0 25px !important;
        text-align: center;
    }
</style>

<script type="text/javascript">
    $('.load-gist').on('click', function() {
        var gist = {
            url: '//work.prinzeugen.net/gist/printempw/' + $(this).data('hash') + '.json?callback=?',
            dom: this
        };

        $.getJSON(gist.url, function(data) {
            gist.style      = document.createElement('link');
            gist.style.type = 'text/css';
            gist.style.rel  = 'stylesheet';
            gist.style.href = data.stylesheet;

            document.getElementsByTagName('HEAD')[0].appendChild(gist.style);

            $(gist.dom).after(data.div).remove();
        });
    });
</script>

    <script type="text/javascript">
    String.prototype.cleanSlug = function () {
        var search = '/index.html';

        if (this.indexOf(search) === -1) {
            return this.slice(0, -1)
        } else {
            return this.replace(search, '');
        }
    }

    var Counter = function (url) {
        this.baseCounterUrl = url;

        this.initAllPostViews = function () {
            var self = this;

            // 遍历 post-view
            $('[id=post-view]').each(function () {
                // 默认 PV 设为 0
                var span = $(this).html(0);
                var slug = span.attr('data').cleanSlug();

                self.getPostViewBySlug(slug, function (pv) {
                    span.html(pv);
                })
            });
        }

        this.getPostViewBySlug = function (slug, callback) {
            var url = this.baseCounterUrl + '/get/' + slug;

            $.getJSON(url, function (data) {
                callback(data.pv);
            });
        }

        this.incPostViewBySlug = function (slug) {
            var url = this.baseCounterUrl + '/increase/' + slug;

            $.post(url, {}, function (data) {
                $('#post-view').html(data.pv);
            });
        }
    }

    var counter = new Counter('https://work.prinzeugen.net/hexo-view-counter');

    $(document).ready(function () {
        counter.initAllPostViews();
    });
</script>


<script type="text/javascript">
    counter.incPostViewBySlug(
        $('#post-view').attr('data').cleanSlug()
    );
</script>


    <script src="/js/APlayer.min.js"></script>
<script type="text/javascript">
    var player = undefined;

    $.getJSON('https://work.prinzeugen.net/music/play_list.json', function (json) {
        // APlayer.addMusic sucks
        // And APlayer does not provide any method to remove
        // the automatically added music [undefined]
        player = new APlayer({
            element: document.getElementById('music-player'),
            narrow: false,
            autoplay: false,
            showlrc: false,
            mutex: true,
            preload: 'none',
            theme: '#367FA9',
            music: json
        });

        console.log('Music player initialized', json);
    });

    $('#music-toggle').click(function () {
        if (player === undefined) {
            return;
        }

        $('.card').addClass('rotated').addClass('hide');

        // I don't know why APlayer 1.6.0 tends to
        // attach "height: 0px" style to .aplayer-list automatically
        $('.aplayer-list').removeAttr('style')

        $('#music-player').removeClass('hide');

        $('#abovesb').css('padding', 0);

        setTimeout(function () {
            $('#music-player').removeClass('rotated');
        }, 10);
    });

    $('body').on('click', '.aplayer-icon-menu', function () {
        $('.aplayer-list').removeClass('aplayer-list-hide');

        $('#music-player').addClass('rotated').addClass('hide');

        $('.card').removeClass('hide');

        setTimeout(function () {
            $('.card').removeClass('rotated');
        }, 10);

        $('#abovesb').css('padding', '7px 0 1px');
    });
</script>


    
  <script src="/js/jquery.disqusloader.js"></script>

<script type="text/javascript">
  $.disqusLoader('.disqus', {
    scriptUrl: '//blessing-studio.disqus.com/embed.js',
    laziness: 0,
    preLoadCallback: function () {
        $('.disqus-notice').show()
    },
    disqusConfig: function () {
      this.callbacks.onReady = [function () {
        $('.disqus-notice').hide()
      }];
    }
  });
</script>



    <script type="text/javascript">nanobar.go(100);</script>
  </body>
</html>
